# WARNING - Generated by {fusen} from dev/flat_select.Rmd: do not edit by hand

#' Find gaps in an integer variable
#' 
#' Looks for gaps within a continuous variable. Number are rounded and gaps are found if one number is not represented. Gaps are returned only if the length of the gaps is 20% higher than the starting age of this gap.
#'
#' @param x \code{vector of numeric} variable to analyze
#' @param maxAlive \code{numeric} Return gaps higher than this maximum, only. Default = NA
#' @param plot \code{logical} whether to actually plot the histogram
#' @param ... arguments pass to hist()
#'
#' @return
#' A data frame where each line is a gap described by its initial/starting age, its final/ending age and its length
#' 
#' @export
#'
#' @importFrom graphics abline box hist par text
#'
#' @examples
#' x = runif(10,0,40)
#' out<-find_gaps(x,maxAlive = 5, plot = FALSE)
find_gaps <- function(x,maxAlive = NA, plot = FALSE,...) {
  
  assert_that(is.numeric(x))
  if(is.na(maxAlive)){
    maxAlive = max(x)
  }else{
    assert_that(is.numeric(maxAlive))}
  
  
  breaks <- floor(min(x, na.rm = TRUE)):ceiling(max(x, na.rm = TRUE))
  hs <- hist(x, breaks = breaks, plot = plot, ...)
  xc <- hs$counts
  xc[hs$counts > 0] <- 1
  
  fin <- FALSE
  i <- 1
  n <- length(xc)
  gaps <- tibble(iniAge= numeric(1), finAge= numeric(1), Gap= numeric(1))
  while(!fin & i < n) {
    id0st <- which(xc[i:n] == 0)[1]
    if (!is.na(id0st)) {
      id0fin <- which(xc[(i + id0st - 1):n] == 1)[1] - 1
      gaps <- rbind(gaps, c(hs$breaks[i + id0st - 1], 
                            hs$breaks[i + id0st + id0fin - 2], id0fin))
      i <- i + id0st + id0fin - 1
    } else {
      fin <- TRUE
    }
  }
  if(is.na(maxAlive))(maxAlive = max(x))
  
  idgap <- gaps%>%
    filter(Gap/iniAge > 0.2 ,
           finAge  >= maxAlive)
  
  if (nrow(idgap) > 0 & plot) {abline(v = idgap$iniAge, col = 2)}
  return(idgap)
}
