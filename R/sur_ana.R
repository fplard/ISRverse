# WARNING - Generated by {fusen} from dev/flat_survival.Rmd: do not edit by hand

#' Survival Analysis
#' 
#' Run basta models on the data after checking conditions for correct convergence of the models
#'
#' @param sexData \code{data.frame} including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param outlLev1 \code{numeric} Start threshold used to selected for the data: 100%, 99.9, 99 or 95%
#' @param models \code{vector of characters} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death date, in days
#' @param minNsur \code{numeric} Minimum number of individual records needed to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the survival analysis. Default = 1
#' @param minlx  \code{numeric} between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis. Default = 0.1
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data. Default = 0.3
#' @param niter  \code{numeric}. number of MCMC iterations to run. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#'
#' @return The output of a list including:
#' * a summary of the data used:
#'- NGlobal: Number of captive born individuals selected from global collections
#'- NBasta: Number of data (individuals) selected for the BaSTA/survival analysis
#'- Ndead:Number of individuals with known age of death used in the BaSTA/survival analysis
#'- maxAge: Maximum age of known age individuals
#'- maxAlive:Maximum number of years spent ex situ
#'- lxMin:Minimum survivorship reached with the raw Kaplan-Meier model
#'-  OutLev: threshold selected for the distribution of  time spent alive: 100%, 99.9, 99 or 95%
#'- a logical indicated if the growth analysis was performed
#'-  If the survival analysis was not performed, an error and its number (Nerr) are returned: The possibility for  this functions are: 1/No raw data; 2/lxMin > minlx; 3/NBasta = 0; 4/ %known births < MinBirthKnown; 5/Data from 1 Institution; 6/Nbasta < minNsur; 7/Nbasta < maxNsur; 8/no DIC from Basta.
#'* the basta fit of the best model
#'* the DIC table comparing the different fit of the models
#' 
#' @export
#'
#' @examples
#' data(core)
#' data(deathinformation)
#' out <- Sur_ana(core,  DeathInformation = deathinformation, models = "GO", shape = "simple",
#'                niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
Sur_ana <- function(sexData, DeathInformation, outlLev1 = 100, models = "GO", shape = "simple",
                    mindate = "1980-01-01", minNsur = 50,maxNsur = NULL, uncert_death=365,
                    minlx = 0.1, MinBirthKnown = 0.3, minInstitution = 1,
                    niter = 25000, burnin = 5001, thinning = 20, nchain = 3, ncpus = 2) {
  
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(sexData))
  assert_that(sexData %has_name% c("AnimalAnonID", "BirthDate", "DepartDate",
                                   "EntryDate", "MaxBirthDate", "MinBirthDate",
                                   "EntryType", "DepartType", "FirstHoldingInstitution", 
                                   "LastHoldingInstitution", "SexType", "BirthType"))
  assert_that(is.data.frame(DeathInformation))
  assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  assert_that(outlLev1 <= 100)
  assert_that(is.numeric(minNsur))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(uncert_death))
  if(!is.null(maxNsur)) {
    assert_that(is.numeric(maxNsur))
  }else{maxNsur = nrow(sexData)}
  assert_that(minNsur > 0)
  assert_that(is.numeric(minlx))
  assert_that(minlx > 0)
  assert_that(minlx <1)
  assert_that(is.numeric(MinBirthKnown))
  assert_that(MinBirthKnown > 0)
  assert_that(MinBirthKnown <1)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models))
  assert_that(all(models %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  
  
  #Initialize
  summar = list(
    NGlobal =  nrow(sexData), NBasta = 0, Ndead = 0, 
    maxAge = NULL, maxAlive = NULL, 
    lxMin = NULL, outLev = NULL, 
    analyzed = FALSE, Nerr = 0,  error ="")
  bastaRes = NULL
  DICmods = NULL
  
  #Remove individuals with uncertainty in death date
  sexData <- sexData%>%
    filter((Death_Uncertainty < uncert_death)%>% replace_na(TRUE))
  
  #Find the minimum threshold for which lxmin  >.1
  summar$lxMin <- 1
  outLev2 = outlLev1
  print(glue::glue("STEP 0: {Sys.time()}"))
  while(summar$lxMin > 0.1 & outLev2 >= 95){
    summar$outLev = outLev2
    if (summar$outLev ==100){
      data_sel <-  sexData
    }else{
      data_sel <-  sexData%>%
        filter(!!sym(paste0("above", summar$outLev))==0)
    }
    data_sel <- data_sel%>%
      mutate(
        deparAge = (DepartDate - BirthDate) / 365.25,
        entryAge = (EntryDate - BirthDate) / 365.25
      )
    
    if (!all(data_sel$DepartType == "C")) {
      rawPLE <- Sur_ple(data_sel)
      # Minimum value of lx:
      summar$lxMin <- min(rawPLE$ple)
    }
    if( summar$outLev == 100){outLev2 = 99.9}
    if( summar$outLev == 99.9){outLev2 = 99}
    if( summar$outLev == 99){outLev2 = 95}
    if( summar$outLev == 95){outLev2 = 90}
  }
  
print(glue::glue("STEP 1: {Sys.time()}"))

  if (summar$lxMin <= minlx) {
    #raw median life expectancy
    # summar$MedLE = median(deparAge[deparType == "D"])
    
    # Extract BaSTA table:
    bastalist <- surv_Bastab(data_sel, DeathInformation = DeathInformation, earliestDate = mindate,
                             excludeStillbirth = TRUE)
    bastatab <- bastalist%>%
      mutate(
        bdun = Max.Birth.Date-Min.Birth.Date,
        aliveTime = (Depart.Date - Entry.Date) / 365.25)
    
    summar$NGlobal <- nrow(data_sel)
    summar$NBasta <- nrow(bastatab)
    summar$Ndead <- nrow(bastatab%>%filter(Depart.Type =="D"))
    summar$maxAge <- as.numeric(max(bastatab$Depart.Date - bastatab$Birth.Date, na.rm = TRUE))
    summar$maxAlive <- as.numeric(max(bastatab$Depart.Date - bastatab$Entry.Date, na.rm = TRUE))
    
    if(summar$NBasta>0){
      #Check the percentage of individuals with known births
      Perbirthknown =  length(which(bastatab$bdun<32 & bastatab$Entry.Type=="B")) / 
        summar$NBasta
      if(Perbirthknown >= MinBirthKnown){
        #Check that we have more than 1 institution
        Instb =  unique(data_sel$FirstHoldingInstitution[data_sel$AnimalAnonID %in% bastatab$AnimalAnonID])
        Instl =  unique(data_sel$LastHoldingInstitution[data_sel$AnimalAnonID %in% bastatab$AnimalAnonID])
        if(length(unique(c(Instb,Instl)))>=minInstitution){
          print(glue::glue("STEP 2: {Sys.time()}"))
          if (summar$NBasta >= minNsur) {
            if(summar$NBasta <= maxNsur){
              print(glue::glue("STEP 3: {Sys.time()}"))
              tempList <- list()
              DICmods <- tibble(models,
                                DIC = 0)
              for (imod in 1:length(models)) {
                print(models[imod])
                tempList[[models[imod]]] <- BaSTA::basta(
                  bastatab, dataType = "census", shape = shape, 
                  model = models[imod], parallel = TRUE, 
                  ncpus = ncpus, nsim = nchain,
                  niter = niter, burnin = burnin, thinning = thinning)
                
                if (!is.na( tempList[[models[imod]]]$DIC[1])) {
                  DICmods$DIC[imod] <-  tempList[[models[imod]]]$DIC["DIC"]
                }
              }
              if (all(DICmods$DIC == 0)) {
                print("more chains")
                for (imod in 1:length(models)) {
                  print(models[imod])
                  tempList[[models[imod]]] <- BaSTA::basta(
                    bastatab, dataType = "census", shape = shape,
                    ncpus = ncpus, nsim = nchain, 
                    niter = niter*4, burnin = burnin*4-3, thinning = thinning)
                  if (!is.na(tempList[[models[imod]]]$DIC[1])) {
                    DICmods$DIC[imod] <-tempList[[models[imod]]]$DIC["DIC"]
                  }
                  
                  
                } 
              }
              
              # BaSTA outputs:
              if (any(DICmods$DIC != 0)) {
                idModSel <- which(DICmods$DIC == min(DICmods$DIC, na.rm = TRUE))
                bastaRes <- tempList[[idModSel]]
                summar$analyzed = TRUE
              } else {
                summar$error = 'no DIC from Basta'
                summar$Nerr = 8
              }
            } else {
              summar$error = "Nbasta > maxNsur"
              summar$Nerr = 7
            }} else {
              summar$error = "Nbasta < minNsur"
              summar$Nerr = 6
            }
        }else{
          summar$error = "Data from 1 Institution"
          summar$Nerr = 5
        }
      }else{ 
        summar$error = "%known births < MinBirthKnown"
        summar$Nerr = 4
      }
    }else{
      summar$error = "NBasta = 0"
      summar$Nerr = 3
    }
  } else {
    summar$ error = "lxMin > minlx"
    summar$ Nerr = 2
  }
  
  return(list(summary = summar, bastaRes = bastaRes, DICmods = DICmods))
}
