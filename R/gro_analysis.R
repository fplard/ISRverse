# WARNING - Generated by {fusen} from dev/flat_growth.Rmd: do not edit by hand


#' Growth model selection
#' 
#' This function fit a serie of growth models to a dataset, select the best one by AIC and estimates the percentiles of the predicted distribution of values.
#' 
#' @param data_weight \code{data.frame} including at least the numeric columns *Age* and *MeasurementValue* 
#' @param all_mods \code{vector of character} indicatingthe growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
#' @param percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#' @importFrom bbmle coef
#'
#' @return a list including:
#' * a data frame with the percentile selected
#' * the fit of the best model
#' * the AIC table of the model
#' * GOF: 3 GOF test including the normality of residuals and the test of trend in residuals against X and in the variance of the residuals
#' 
#' @export
#' @examples
#' Age <- sample(c(0:10), 100, replace = TRUE)
#' MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ rnorm(100,0,0.01))-1 
#' dat = data.frame(Age = Age, MeasurementValue = MeasurementValue)
#'
#' out = Gro_analysis(dat, 
#'                    all_mods = c("logistic", "vonBertalanffy"), 
#'                    percentiles = c(2.5, 97.5))
Gro_analysis <- function(data_weight, all_mods =c("vonBertalanffy"), percentiles = c(2.5,97.5)
) {
  assert_that(is.numeric(percentiles))
  assert_that(min(percentiles) > 0)
  assert_that(max(percentiles) < 100)
  assert_that(all(all_mods %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue","Age"))
  assert_that(all(data_weight$Age >= 0 ))
  assert_that(all(data_weight$MeasurementValue > 0 ))
  
  data_weight<-data_weight%>%
    mutate(logx = log(Age + 1),
           logz = log(MeasurementValue + 1))
  
  #Fitting the different growth models
  all_fits <- lapply( 1:length(all_mods),
                      Gro_fitlog,
                      all_mods = all_mods,
                      dat = data_weight
  )
  
  # fit_gam <- mgcv
  
  #Select the best model
  all_fits_tab=c()
  for (i in 1:length(all_mods)){
    all_fits_tab <- rbind(all_fits_tab,all_fits[[i]]$tab%>%as_tibble)
  }
  all_fits_tab <- all_fits_tab%>% arrange(AIC)
  best_std <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$fit
  growthMod <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$growthMod
  all_fits_tab <- all_fits_tab%>% 
    dplyr::select(-index)
  
  #Fitted values and residuals
  gam <- bbmle::coef(best_std)
  suppressWarnings(gam$logx <- data_weight$logx)
  
  logzfit <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
  
  #GOF
  
  conv = slot(best_std, "details")$convergence
  GOF = list(normal = T, X = T, var = T, conv = T)
  if(conv == 1){GOF$conv = FALSE}
  elogz <- data_weight$logz - logzfit
  elogz2 <- elogz^2
  test  = shapiro.test(elogz)
  if(test$p.value<0.01){GOF$normal = FALSE}
  a = summary(lm(elogz2 ~ data_weight$logx)) #test variance?
  if(a$coefficients[2,4]<0.01){GOF$X = FALSE}
  b = summary(lm(elogz ~ data_weight$logx)) #test pour senescence??
  if(b$coefficients[2,4]<0.01){GOF$var = FALSE}
  
  # Quantile calculation:
  zQuant <- tibble(Age = seq(min(data_weight$Age), max(data_weight$Age)+0.1, 0.1))
  gam$logx =  log(zQuant$Age+1)
  lzexp <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
  sig <- sd(elogz) 
  for (al in 1:length(percentiles)) {
    zQuant[[paste(percentiles[al])]] <- qlnorm(percentiles[al] / 100, mean = lzexp, sd = sig) - 1
    zQuant[[paste(percentiles[al])]] [which( zQuant[[paste(percentiles[al])]] < 0)] = 0
  }
  
  return(list(percent = zQuant, 
              fit = best_std,
              AIC_tab =all_fits_tab,
              GOF = GOF)
  )
}
