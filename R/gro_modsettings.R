# WARNING - Generated by {fusen} from dev/flat_growth.Rmd: do not edit by hand


#' Growth model settings
#' 
#' This function gets the parameter and equations for the growth model
#' 
#' @param data \code{data.frame} including at least the numeric columns *logx* and *logz* 
#' @param model \code{character} Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial 
#' 
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return a list including the function of the growth model,  the number of parameter, their names, their initial values and their lowest possible values
#' 
#' @export
#' @examples
#' logx <- rnorm(100, 0, 1)
#' logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
#' dat = data.frame(logx = logx, logz = logz)
#'
#' Gro_ModSettings(data = dat, model = "vonBertalanffy")
# Set growth model parameters:
Gro_ModSettings <- function(data, model = "vonBertalanffy") {
  
  assert_that(model %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial"), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c('logx', 'logz'))
  assert_that(is.numeric(data$logx))
  assert_that(is.numeric(data$logz))
  logx = data$logx
  logz = data$logz
  # Range of log(x) values:
  logxDiff <- diff(range(logx))
  
  if (model == "logistic") {
    growthMod <- logisGrowth
    np <- 3
    namesCoef <- c("zinf", "gamma", "xInfl")
    lowCoef <- c(0, 0, -Inf)
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- max(logz[idInf])
    
    # X inflection:
    xInfl <- mean(range(logx))
    
    # find starting gamma:
    nGams <- 7
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inrat <- zInf / logzMeans - 1
    idk <- which(inrat > 0)
    inlog <- - log(inrat[idk]) / (logxInts[idk] - xInfl)
    gamma <- mean(inlog)
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, xInfl = xInfl, gamma = gamma)
    
    
    
  } else if (model == "gompertz") {
    growthMod <- gompertzGrowth
    np <- 3
    namesCoef <- c("zinf", "beta", "gamma")
    lowCoef <- c(0, 0, 0)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = -log(abs(z0/zinf))
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- log(abs(log(abs(logzMeans/zinf)) / beta))
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-inlog[idkeep] / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma)
    
  } else if (model == "chapmanRichards") {
    growthMod <- chapmanRichards
    np <- 4
    namesCoef <- c("zinf", "beta", "gamma", "m")
    lowCoef <- c(0, 0, -Inf, -Inf)
    
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = 1-(z0/zinf)
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- (logzMeans/zinf - 1)/(-beta)
    idkeep <- which(inlog > 0)
    gamma <- mean(-log(inlog[idkeep]) / (logxInts[idkeep] + dxInts))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma, m = 0)
    
  } else if (model == "vonBertalanffy") {
    growthMod <- vbGrowth
    np <- 3
    namesCoef <- c("z0", "zinf", "gamma")
    lowCoef <- rep(0, np)
    # Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- mean(logz[idInf], na.rm = TRUE) - z0
    
    if (zInf <= 0) {
      zInf <- z0 + diff(range(logz))
    }
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:5, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- 1 - (logzMeans - z0) / zInf
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-log(inlog[idkeep]) / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, z0 = z0, gamma = gamma)
    
  } else if (model == "polynomial") {
    growthMod <- polyGrowth
    np <- 5
    namesCoef <- sprintf("gam%s", 0:np - 1)
    lowCoef <- rep(-Inf, np)
    gamStart <- list(gam0 = 0, gam1 = 0, gam2 = 0, gam3 = 0, gam4 = 0)
    
  }
  return(list(growthMod = growthMod, np = np, namesCoef = namesCoef,
              low = lowCoef, gamstart = gamStart))
}
