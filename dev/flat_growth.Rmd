---
title: "flat_growth.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
```


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = F)
```

# Gro_cleanmeasures


This function is used to prepare weight and length dataset. It unify the unity used, select clean measures and add individual age at each measure. This function takes as arguments:

* `data`: the weight or length data from ZIMS
* `coresubse`: the core data of the species from ZIMS
* `CaptiveBirths` Should captive born individuals be included, only? Default =  TRUE
* `InclUnkSex`Should undetermined sexes be included Default =  FALSE
* `mindate` Earlier date to include data ('YYYY-MM-DD')
* `MeasureType` Name of the type of measurements that should be included. Default = NULL, all measurement type are included.
* `type` Either 'weight' or 'length'.

The function returns the data frame including selected measures, plus individual birth date and individual age at each measure


```{r function-Gro_cleanmeasures}
#' Prepare weight and length Dataset
#'
#'Select clean measures, unify the unity used and add individual age at each measure
#'
#' @param data \code{data.frame} including the following columns *MeasurementValue*, *MeasurementDate*, *CollectionScopeType*, *UnitOfMeasure*, *ExcludedFromNorms*, *EstimatedMeasurement*, *RecordType*, *MeasurementType*, *anonID* and *AnonInstitutionID*.
#' @param coresubse \code{data.frame} including at least the following columns *binSpecies*, *Sex*, *anonID* and *Birthdate* (\code{date})
#' @param CaptiveBirths \code{logical} Should captive born individuals be included, only? Default =  TRUE
#' @param InclUnkSex \code{logical} Should undetermined sexes be included Default =  FALSE
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included. Default = NULL, all measurement type are included.
#' @param type \code{character} Either 'weight' or 'length'. Default =  'weight
#' @param corevariable \code{vector character} Name of the core columns that must be added to data
#' @param variablekeep \code{vector character} Name of the data columns that must also be returned
#' 
#' @return The data frame including selected measures, plus individual birth date and individual age at each measure
#' 
#' @import dplyr assertthat
#' 
#' @export
#'
#' @examples
Gro_cleanmeasures <- function(data, coresubse,
                              CaptiveBirths = TRUE, type = "weight", MeasureType = NULL,
                              InclUnkSex = FALSE, mindate = "1980-01-01",
                              corevariable = NULL, variablekeep =NULL) 
{
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(data))
  assert_that(is.data.frame(coresubse))
  assert_that(data %has_name% c("MeasurementValue", "MeasurementValue", "MeasurementDate", "CollectionScopeType", "UnitOfMeasure", "ExcludedFromNorms", "EstimatedMeasurement", "RecordType", "MeasurementType", "anonID", "AnonInstitutionID"))
  assert_that(coresubse %has_name% c("BirthDate", "binSpecies", "Sex", "anonID"))
  assert_that(is.logical(CaptiveBirths))
  assert_that(is.logical(InclUnkSex))
  assert_that(is.date(mindate))
  
  
  if(!is.null(corevariable)) {
    assert_that(is.character(corevariable))
    assert_that(coresubse %has_name% corevariable)}
  if(!is.null(variablekeep)) {
    assert_that(is.character(variablekeep))
    assert_that(data %has_name% variablekeep)}
  
  if(!is.null(MeasureType)){
    if(!all(MeasureType %in% unique(data$MeasurementType))){
      MeasureType_not = which(!(MeasureType %in% unique(data$MeasurementType)))
      warnings(paste0(MeasureType[MeasureType_not]," are not included in the data, check if they are spelled correctly"))
    }
  }
  assertthat::assert_that(type %in% c("weight",'length'))
  
  if(type =="weight"){
    Units <- data.frame(unit = c("kilogram", "gram", 
                                 "micrograms", "milligram", "ounce", 
                                 "pound", "stone", "tonne"), 
                        toKg = c(1,1/1000, 
                                 10^{
                                   -9
                                 }, 10^{
                                   -6
                                 }, 0.0283495, 0.453592, 6.35029, 1000),
                        stringsAsFactors = FALSE)
    
  }
  if(type =="length"){
    Units <- data.frame(unit = c("meter","m", "dm", "cm", "mm", 
                                 "foot", "inch", 
                                 "metre", "centimetre", "millimetre",  "kilometre"), 
                        toKg = c(1,1, 10^{-1}, 10^{-2},10^{-3},
                                 0.3048, 0.0254,
                                 1, 10^{-2},10^{-3},10^{3}),
                        stringsAsFactors = FALSE)
    
  }
  Corevariable = c("binSpecies", "BirthDate", "Sex", "anonID", corevariable) 
  Variablekeep = c(Corevariable,"AnonInstitutionID","MeasurementType", 
                   "MeasurementDate", "Age", "MeasurementValue", "Unit", variablekeep)
  
  coresubse<- coresubse%>%
    rowwise()%>%
    mutate(cond_captivebirth = ifelse(CaptiveBirths,stringr::str_detect(birthType, pattern = "Captive"),1 ),
           cond_sex = ifelse(InclUnkSex, 1, stringr::str_detect(Sex, pattern = "Undet", negate = T) ))%>%
    filter(cond_captivebirth == 1,
           cond_sex == 1)%>%
    dplyr::select(-c(cond_captivebirth, cond_sex))
  
  data <- data%>%
    filter(anonID %in% coresubse$anonID)%>%
    mutate(MeasurementDate = lubridate::as_date(MeasurementDate))%>%
    left_join(coresubse%>%dplyr::select(all_of(Corevariable)), by = "anonID")
  
  if(!is.null(MeasureType)){
    data<- data%>%
      filter(MeasurementType %in% MeasureType)}
  
  if(nrow(data)>0){
    
    datasub<- data%>%
      filter(Sex %in% unique(coresubse$Sex),
             MeasurementDate>= mindate,
             CollectionScopeType == "Global",
             !is.na(MeasurementValue),
             as.character(UnitOfMeasure) %in% Units$unit,
             ExcludedFromNorms == 0 , 
             EstimatedMeasurement == 0 , 
             MeasurementValue > 0,
             RecordType == "Husbandry"
      )
    
    
    
    if (nrow(datasub) > 0) {
      datasub <- datasub%>%
        mutate(Age = as.numeric((MeasurementDate - BirthDate)/365.25))%>%
        filter(Age >= 0)%>%
        left_join(Units, by =c("UnitOfMeasure"= "unit"))%>%
        mutate(MeasurementValue = MeasurementValue * toKg,
               Unit = Units$unit[1])%>%
        dplyr::select(all_of(Variablekeep))
      output <-datasub
    }else{output <- "There is no data selected"}
    
  }else{output <- "There is no data selected"}
  return(output)
}
```


```{r examples-Gro_cleanmeasures}
data(raw_weights)
data(core)

data_weights= Gro_cleanmeasures(raw_weights, core,
                                CaptiveBirths = TRUE,
                                MeasureType = 'Live weight',
                                InclUnkSex = FALSE, 
                                mindate = "1980-01-01")
```



```{r tests-Gro_cleanmeasures}
data(raw_weights)
data(core)

test_that("Gro_cleanmeasures works", {
  d=Gro_cleanmeasures(raw_weights, core)
  expect_named(
    d,
    c("binSpecies", "BirthDate", "Sex", "anonID", "AnonInstitutionID", "MeasurementType", "MeasurementDate", "Age", "MeasurementValue", "Unit"))
  expect_true(unique(d$Unit) == "kilogram")
})
```



# gro_remoutliers

This function removes the outliers from a dataset of weights. This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`.
* `taxa` the name of the taxa studied
* `ageMat` the MINIMUM age at sexual maturity. The function takes as threshold 1.2*ageMat to differentiate juveniles (still growing) from adults
* `maxweight`
* `variableid` name of the column including individual IDs. Defaut = "anonID". It must also be a column of `data_weight`
* `minq` Sensitivity of the function to remove outliers using percentiles, between 0 and 1. Default =  0.025
* `IQR` influences the sensitivity of the function to remove outliers using generalized additive model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year . Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year . Default =  2.5 (250%)

This function follow 4 different steps to highlight outliers:
1/ It removes the measures higher than the argument `maxweight` (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).  In the default case, default values are in kilograms and are set at 7000kg for Mammalia, 200kg for Aves, 1500kg for Reptilia, 100kg for Amphibia, 1000kg for Chondrichthyes and 500kg for Actinopterygii.
2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles. You can choose the number of intervals used for the sliding windows using the argument `Ninterval_juv`.
3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least `min_Nmeasures` measures and remove outliers based on the residuals of the models.
4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.

The function returns:

* The data frame including the column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3.



```{r function-Gro_remoutliers}

#' Remove outliers from weigth or length data
#'
#'Takes a data frame including weight measures and Age and look for possible outliers
#'
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric})
#' @param taxa  \code{character} the name of the taxa studied
#' @param ageMat \code{numeric} the age at sexual maturity to differentiate juveniles (still growing) from adults
#' @param maxweight \code{numeric} the maximum weight allowed for the dataset
#' @param variableid \code{character} name of the variable including individual ids. Defaut = "anonID". It must also be a column of data_weight.Default = 6. It must be at least 5
#' @param min_Nmeasures \code{integer} Minimum number of measures for an individual to check outliers along its growth trajectory. Default = 7. It must be at least 5
#' @param minq \code{numeric} Sensitivity of the function to remove outliers using percentiles, between 0 and 1. Default =  0.025
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers using log-linear model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year . Default =  0.2 (20%)
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year . Default =  2.5 (250%)
#' @param Ninterval_juv \code{integer} Number of intervals used for the sliding windows for juveniles. Default = 10
#' 
#' @return The data frame including the additional column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3.
#' 
#' @details
#'This function follow 4 different steps to highlight outliers:
#'1/ It removes the measures higher than \code{maxweight} (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).
#'2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles.
#'3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least 7 measures and remove outliers based on the residuals of the models.
#'4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.
#' 
#' @import dplyr assertthat
#' @importFrom stats lm predict.lm
#' 
#' @export
#'
#' @examples
Gro_remoutliers <- function(data_weight, taxa, ageMat = 0, maxweight = NULL, 
                            variableid = "anonID", min_Nmeasures = 7,
                            perc_weight_min=0.2, perc_weight_max=2.5,
                            IQR=2.75, minq=0.025, Ninterval_juv = 10) {
  
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue", "Age"))
  assert_that(taxa %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
                          "Chondrichthyes", "Actinopterygii"),
              msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  assert_that(is.numeric(ageMat))
  if(is.null(maxweight)){
    if(taxa == "Mammalia")       maxweight = 7000
    if(taxa == "Aves")           maxweight = 200
    if(taxa == "Reptilia")       maxweight = 1500
    if(taxa == "Amphibia")       maxweight = 100
    if(taxa == "Chondrichthyes") maxweight = 1000
    if(taxa == "Actinopterygii") maxweight = 500
  }
  assert_that(is.numeric(maxweight))
  assert_that(min_Nmeasures%%1==0, msg = "min_Nmeasures should be an integer")
  assert_that(min_Nmeasures>=5)
  assert_that(Ninterval_juv%%1==0, msg = "Ninterval_juv should be an integer")
  assert_that(all(data_weight$MeasurementValue>0))
  assert_that(all(data_weight$Age>=0))
  
  if(ageMat == 0){ageMat=1.5}
  #1) Removes very large weights using maxweight ----
  data_weight <- data_weight%>%
    mutate(keep1 = ifelse(MeasurementValue< maxweight, 1, 0))
  
  #2) Separate Juveniles and adults 
  ### JUVENILES ----
  juv <- data_weight%>%
    filter(Age >= 0, Age < ageMat*1.2)
  if (nrow(juv) > 0) {
    
    ##a/Uses sliding windows to check outliers based on percentile of the distribution 
    #Make Ninterval_juv for sliding windows
    nInts = Ninterval_juv
    windInts <- seq(0, ageMat, length = nInts+1)
    numInt <- table(findInterval(juv$Age[juv$keep1==1], windInts))
    nWindInts <- 0
    ii <- 1
    while (ii < nInts) {
      cumInt <- cumsum(numInt[ii:nInts])
      idnum <- which(cumInt > 30) + ii
      if (length(idnum) > 0) {
        nWindInts <- c(nWindInts, windInts[idnum[1]])
        ii <- idnum[1]
      } else {
        nWindInts <- c(nWindInts, windInts[nInts+1])
        ii <- nInts
      }
    }
    if (!ageMat %in% nWindInts)  nWindInts <- c(nWindInts, ageMat)
    nInts <- length(nWindInts) - 1
    juv$keep2 = juv$keep1
    for (iints in 1:nInts) {
      idwind <- which(juv$Age >= nWindInts[iints] & 
                        juv$Age <= nWindInts[iints + 1] & 
                        juv$keep1 == 1)
      juv$keep2[idwind] = Gro_Rout_quan(z = juv$MeasurementValue[idwind],  
                                        minq = minq, type = "upper")
    }
    
    ##b/Uses individual trajectories to find outliers for juveniles with at least 7 measures
    juv <-juv %>%
      group_by(anonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    juv$keep3 = juv$keep2
    if(any(juv$nb >= min_Nmeasures & juv$la>=4)){
      juv_temp  <- Gro_lin_ind(juv%>%filter(keep2 == 1, nb >= min_Nmeasures, la >= 4), 
                               perc_weight_min = perc_weight_min,
                               perc_weight_max = perc_weight_max,
                               IQR = IQR,
                               remove_ext = F, traj_ind = T
      )
      
      juv$keep3[juv$keep2==1 & juv$nb >= min_Nmeasures & juv$la >=4] = juv_temp$Keep2 
    }
  }
  
  ### ADULTS ----
  ad <- data_weight%>%
    filter(Age >=  ageMat*1.2)
  if (nrow(ad) > 0) {
    
    ##a/Check outliers based on percentile of the distribution 
    ad$keep2=ad$keep1
    ad$keep2[ad$keep1 == 1] = Gro_Rout_quan(z = ad$MeasurementValue[ad$keep1 == 1],  
                                            minq = minq, type = "both")
    
    ##b/Uses individual trajectories to find outliers for adults with at least 7 measures
    ad <-ad %>%
      group_by(anonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    ad$keep3 = ad$keep2
    if(any(ad$nb >= min_Nmeasures & ad$la>=4)){
      
      ad_temp <- Gro_lin_ind(ad%>%filter(keep2==1, nb >= min_Nmeasures, la >= 4), 
                             perc_weight_min = perc_weight_min,
                             perc_weight_max = perc_weight_max,
                             IQR = IQR,
                             remove_ext = F, traj_ind = T
      )
      ad$keep3[ad$keep2==1 & ad$nb >= min_Nmeasures & ad$la >=4] = ad_temp$Keep2 
    }
  }
  
  data_weight1 =rbind(juv,ad)%>%dplyr::select(-nb,-la)
  #3) Uses global GAM model to detect remaining outliers ----
  data_weight1$KEEP= data_weight1$keep3
  if(sum(data_weight1$KEEP)>4){
    if(length(unique(data_weight1$Age[data_weight1$KEEP==1]))>=4){
      data_weight1_temp <- Gro_lin_ind(data_weight1%>%filter(keep3==1), 
                                       perc_weight_min = perc_weight_min,
                                       perc_weight_max = perc_weight_max,
                                       IQR = IQR,
                                       remove_ext = F, traj_ind = F
      )
      data_weight1$KEEP [data_weight1$keep3 == 1] = data_weight1_temp$Keep2
    }
  }
  return(data_weight1)
  
}
```


```{r examples-Gro_remoutliers}
data(weights)
weights = Gro_remoutliers(weights, taxa = "Mammalia", ageMat = 10)

plot(MeasurementValue ~Age, data = weights)
#Show the four steps used to remove outliers
#1/ using maximum value
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep1==0),
       col = "red", pch = 16) 
#2/ using Inter quartile range
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep2==0, keep1==1 ),
       col = "green", pch = 16) 
#3a/ using individual trajectories
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep3==0, keep2==1),
       col = "cyan", pch = 16) 
#3b/ using global log-linear model
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(KEEP==0, keep3==1),
       col = "blue", pch = 16) 

#Checking outliers highlighted in Individual trajectories
anon = unique(weights$anonID[weights$keep3==0 & weights$keep2==1 ])
plot(MeasurementValue ~Age, data = weights%>%
       dplyr::filter(keep2==1, anonID == anon))
points(MeasurementValue ~Age, data = weights%>%
         dplyr::filter(keep3==0, anonID == anon, keep2==1),
       col = "cyan", pch = 16)
```


```{r development_examples-Gro_remoutliers}
plot(MeasurementValue ~Age, data = weights, ylim = c(0,400), xlim = c(0,50))
#Show the four steps used to remove outliers
#1/ using maximum value
points(MeasurementValue ~Age, data = weights%>%filter(keep1==0),
       col = "red", pch = 16) 
#2/ using Inter quartile range
points(MeasurementValue ~Age, data = weights%>%filter(keep2==0, keep1==1 ),
       col = "green", pch = 16) 
#3a/ using individual trajectories
points(MeasurementValue ~Age, data = weights%>%filter(keep3==0, keep2==1), 
       col = "cyan", pch = 16) 
#3b/ using global log-linear model
points(MeasurementValue ~Age, data = weights%>%filter(KEEP==0, keep3==1), 
       col = "blue", pch = 16) 

#Individual trajectories
i=0
anon = unique(weights$anonID[weights$keep3==0 & weights$keep2==1 ])
i=i+1
plot(MeasurementValue ~Age, data = weights%>%
       filter(keep2==1, anonID == anon[i]))
points(MeasurementValue ~Age, data = weights%>%
         filter(keep3==0, anonID == anon[i], keep2==1),
       col = "cyan", pch = 16)

#Other tests
data(weights_lion)
weights = Gro_remoutliers(weights_lion, taxa = "Mammalia", ageMat =2, IQR = 2.75, minq=0.025)
data(weights_bison)
weights = Gro_remoutliers(weights_bison, taxa = "Mammalia", ageMat =10, IQR = 2.75, minq=0.025)
data(weights_meerkat)
weights = Gro_remoutliers(weights_meerkat, taxa = "Mammalia", ageMat =1, IQR = 2.75, minq=0.025)
data(weights_gorilla)
weights = Gro_remoutliers(weights_gorilla, taxa = "Mammalia", ageMat =12, IQR = 2.75, minq=0.025)
```



```{r tests-Gro_remoutliers}

test_that("Gro_remoutliers errors", {
  expect_error(Gro_remoutliers(tibble(age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10),
               msg = "data_weight does not have all of these name(s): 'MeasurementValue', 'Age'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "mammalia", ageMat = 10),
               msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10, min_Nmeasures = 3.3),
               msg = "min_Nmeasures should be an integer")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10, min_Nmeasures = 3),
               msg = "min_Nmeasures not greater than or equal to 5")
})


test_that("Gro_remoutliers works", {
  data = tibble(Age = c(rep(c(1:5),2),4),
                MeasurementValue= c(5,10000,3,6,5,4,100,2,5,3,4),
                anonID = c(rep(1:2, each = 5),3))
  
  a= Gro_remoutliers(data, taxa = "Mammalia", ageMat = 10,
                     min_Nmeasures = 5, minq = 0.1, IQR = 1.2)
  expect_true(sum(a$keep1) == 10)
  expect_true(sum(a$keep2) == 9)
  expect_true(sum(a$keep3) == 9)
  expect_true(sum(a$KEEP) == 9)
})
```


## Remove outliers from percentiles

This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.

The measurement values must be positive

```{r function-Gro_Rout_quan}
#' Remove outliers from percentiles
#'
#' @param z  \code{numeric vector} Measurement values
#' @param minq \code{numeric} Sensitivity of the function to remove outliers, between 0 and 1. Default =  0.05
#' @param type \code{character} "both", "lower", or "upper" to choose if the lower or upper part of the distribution should be screened. Default =  0.05
#'
#' @return
#' Vector of 0 and 1 indicating the measurement values to keep (=1) vs. the outliers (=0).
#' 
#' @importFrom stats quantile
#' 
#' @export
#' 
#' @details
#' This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.
#'
#' @examples
Gro_Rout_quan <- function (z, minq = 0.05, type = "both") 
{
  
  assert_that(is.numeric(z))
  assert_that(is.numeric(minq))
  assert_that(is.character(type))
  assert_that(minq < 1, msg = "minq must be a proportion between 0 and 1")
  assert_that(minq > 0, msg = "minq must be a proportion between 0 and 1")
  assert_that(type %in% c("upper", "lower", "both"))
  qzn <- quantile(z, c(minq, 1-minq))
  qzrat <- qzn[2]/qzn[1]
  qzlu <- c(quantile(z, 0.5)/qzrat, quantile(z, 0.5) * qzrat)
  if(type =="both"){idkeep <- which(z > qzlu[1] & z < qzlu[2])}
  if(type =="lower"){idkeep <- which(z > qzlu[1])}
  if(type =="upper"){idkeep <- which(z < qzlu[2])}
  indKeep = rep(0,length(z))
  indKeep[idkeep] <- 1
  return(indKeep)
}
```

```{r examples-Gro_Rout_quan}
z = c(rnorm(100,5,1), runif(3,40,100))
Gro_Rout_quan (z, minq = 0.05)
```

```{r tests-Gro_Rout_quan}
z1 = c(rnorm(95,4,1), runif(5,100,1000))

test_that("Gro_Rout_quan error", {
  expect_error(Gro_Rout_quan("text"))
  expect_error(Gro_Rout_quan(z1, minq = 1) , regexp = "minq must be a proportion between 0 and 1")
})

test_that("Gro_Rout_quan works", {
  expect_true(sum(Gro_Rout_quan(z1, minq = 0.05)) == 95)
})
```


## Linearize individual trajectories

This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`and `anonID`
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year. Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year. Default =  2.5 (250%). This value is used only after 1 year old 
* `IQR` influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
* `remove_ext` Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers. Default =  TRUE
*  `traj_ind` Do you want to build a model at the level of the individual trajectory  Default =  TRUE. If yes, each individual trajectory must have at least 5 measures. 

The function uses build generalized additive model of the measurement value in relation to age. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. `perc_weight_min` and `perc_weight_max` limit the values that must be considered as outliers.

```{r function-Gro_lin_ind}
#' Flag outliers in individual trajectories
#' 
#' This function flag 
#' 
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric}) and *anonID*
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year. Default =  0.2 (20%)
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year. Default =  2.5 (250%). This value is used only after 1 year old 
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
#' @param remove_ext \code{logical} Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers. Default =  TRUE
#' @param traj_ind \code{logical} Do you want to build linear model at the level of the individual trajectory  Default =  TRUE. If yes, each individual trajectory must have at least 5 measures. 
#' 
#' @details
#' The function uses a log-linear model of the measurement value in relation to a quadratic effect of age for each individual trajectories. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. \code{perc_weight_min} and \code{perc_weight_max} limit the values that must be considered as outliers.
#'The \code{remove_ext} argument prevents the function from removing the 2 last and 2 first value observations in relation to age as these values may often be farther from the prediction line.
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return data frame; the data set including an additional column *Keep2* of 0 (potential outliers) and 1
#' 
#' @export
Gro_lin_ind <- function(data_weight, 
                        perc_weight_min = 0.2,
                        perc_weight_max = 2.5,
                        IQR = 1.5,
                        remove_ext = T,
                        traj_ind = T
) {
  
  assert_that(is.numeric(perc_weight_min ))
  assert_that(perc_weight_min  >0 )
  assert_that(perc_weight_min  <1)
  assert_that(is.numeric(perc_weight_max ))
  assert_that(perc_weight_max  >1 )
  assert_that(is.numeric(IQR))
  assert_that(IQR  > 1, msg = 'IQR should be higher than 1 to avoid removing real data')
  assert_that(is.logical(remove_ext))
  assert_that(is.logical(traj_ind))
  assert_that(data_weight %has_name% c("MeasurementValue","Age", "anonID"))
  
  
  data_weight<-data_weight%>%
    dplyr::mutate(pop = 1)%>%
    dplyr::group_by(pop)
  
  assert_that(nrow(data_weight)  > 4, msg = 'There should be at least 5 measures')
  assert_that(min(length(unique(data_weight$Age)))  >= 4, msg = 'Measures must have been taken at 4 different unique ages, at least')
  
  
  #only for individual trajectory 
  if(traj_ind==T){
    da_weight<-data_weight%>%
      summarize(nb= n(),
                la = length(unique(Age)))
    assert_that(min(da_weight$nb)  > 4, msg = 'Each individual trajectory must have at least 5 measures')
    assert_that(min(da_weight$la)  >= 4, msg = 'Each individual trajectory must have measures at 4 different unique ages, at least')
  }
  data_weight$pred2 = perc_weight_max
  data_weight$pred2[data_weight$Age<1] = 1000
  data_weight<-data_weight%>%
    mutate(pred = stats::predict(mgcv::gam(MeasurementValue ~ s(Age, bs = "cr", k=3), data = cur_group())),
           res = abs(MeasurementValue - pred),
           pred1 = abs(perc_weight_min*pred),
           pred2 = abs(pred*pred2),
           lwr = abs(IQR*(quantile(res,0.90)-quantile(res,0.10))),
           ager = rank(Age),
           #Prevent from removing 2 first and 2lasts obs as they will tend to be removed
           age0 = ager < min(ager)+2,
           agem = ager > max(ager)-2)%>%
    dplyr::ungroup()%>% 
    rowwise%>%
    mutate(
      Keep2 = res < min(max(lwr,pred1),pred2))
  if( !(remove_ext))   data_weight$Keep2[data_weight$age0 | data_weight$agem]=1
  data_weight<-data_weight%>%
    dplyr::select(- pred1, -lwr, -res, -age0, -agem, -pred, -ager,
                  -pop, -pred2)
  
  return(data_weight)
}
```

```{r example-Gro_lin_ind}
data(weights)

#We use only trajectories for which the number of individual datapoints is > 6
weights <- weights%>%
  dplyr::group_by(anonID)%>%
  dplyr::mutate(nb= dplyr::n())%>%
  dplyr::ungroup()%>%
  dplyr::filter(nb >6)

weights_ind <- weights%>%Gro_lin_ind(traj_ind = TRUE)
as.numeric(weights_ind$Keep2)

weights_pop <- weights%>%Gro_lin_ind(traj_ind = FALSE)
```


```{r tests-Gro_lin_ind}
data <- tibble(anonID = rep(c(1,2), c(10,15)),
               Age = c(c(1:10), c(1:15)),
               MeasurementValue = 2+3*Age)
data$MeasurementValue[1] = 0.5
data$MeasurementValue[3] = data$MeasurementValue[3]+50
data$MeasurementValue[14] = data$MeasurementValue[3]+30
data$MeasurementValue[20] = data$MeasurementValue[3]+100

test_that(
  "Gro_lin_ind error",
  {
    expect_error(
      data %>% Gro_lin_ind(IQR =0.5),
      regexp = "IQR should be higher than 1 to avoid removing real data")
    expect_error(
      data[1:4,] %>% Gro_lin_ind(),
      regexp = "There should be at least 5 measures")
  })



test_that(
  "Gro_lin_ind Tested ",
  { 
    expect_named(
      data %>% Gro_lin_ind(),
      c("anonID", "Age", "MeasurementValue", "Keep2"))
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5, remove_ext = F, traj_ind = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(remove_ext = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5)%>%pull(Keep2)),
      25-3)
  }
)
```


# Growth model

## Growth analysis
This function fit a serie of growth models to a dataset, select the best one by AIC and estimates the percentiles of the predicted distribution of values. It takes as arguments:

* data_weight including at least the numeric columns *Age* and *MeasurementValue* 
* all_mods indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
* percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.


```{r function-Gro_analysis}

#' Growth model selection
#' 
#' This function fit a serie of growth models to a dataset, select the best one by AIC and estimates the percentiles of the predicted distribution of values.
#' 
#' @param data_weight \code{data.frame} including at least the numeric columns *Age* and *MeasurementValue* 
#' @param all_mods \code{vector of character} indicatingthe growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
#' @param percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.
#' 
#' @details
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#' @importFrom bbmle coef
#'
#' @return a list including:
#' * a data frame with the percentile selected
#' * the fit of the best model
#' * the AIC table of the model
#' * GOF: 3 GOF test including the normality of residuals and the test of trend in residuals against X and in the variance of the residuals
#' 
#' @export
Gro_analysis <- function(data_weight, all_mods =c("vonBertalanffy"), percentiles = c(2.5,97.5)
) {
  assert_that(is.numeric(percentiles))
  assert_that(min(percentiles) > 0)
  assert_that(max(percentiles) < 100)
  assert_that(all(all_mods %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue","Age"))
  assert_that(all(data_weight$Age >= 0 ))
  assert_that(all(data_weight$MeasurementValue > 0 ))
  
  data_weight<-data_weight%>%
    mutate(logx = log(Age + 1),
           logz = log(MeasurementValue + 1))
  
  #Fitting the different growth models
  all_fits <- lapply( 1:length(all_mods),
                      Gro_fitlog,
                      all_mods = all_mods,
                      dat = data_weight
  )
  
  #Select the best model
  all_fits_tab=c()
  for (i in 1:length(all_mods)){
    all_fits_tab <- rbind(all_fits_tab,all_fits[[i]]$tab%>%as_tibble)
  }
  all_fits_tab <- all_fits_tab%>% arrange(AIC)
  best_std <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$fit
  growthMod <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$growthMod
  all_fits_tab <- all_fits_tab%>% 
    dplyr::select(-index)
  
  #Fitted values and residuals
  gam <- bbmle::coef(best_std)
  suppressWarnings(gam$logx <- data_weight$logx)
  
logzfit <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
  
  #GOF
  GOF = list(normal = T, X = T, var = T)
  elogz <- data_weight$logz - logzfit
  elogz2 <- elogz^2
  test  = shapiro.test(elogz)
  if(test$p.value<0.01){GOF$normal = FALSE}
  a = summary(lm(elogz2 ~ data_weight$logx)) #test variance?
  if(a$coefficients[2,4]<0.01){GOF$X = FALSE}
  b = summary(lm(elogz ~ data_weight$logx)) #test pour senescence??
  if(b$coefficients[2,4]<0.01){GOF$var = FALSE}

  # Quantile calculation:
  zQuant <- tibble(Age = seq(min(data_weight$Age), max(data_weight$Age)+0.1, 0.1))
   gam$logx =  log(zQuant$Age+1)
  lzexp <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
  sig <- sd(elogz) 
  for (al in 1:length(percentiles)) {
    zQuant[[paste(percentiles[al])]] <- qlnorm(percentiles[al] / 100, mean = lzexp, sd = sig) - 1
    zQuant[[paste(percentiles[al])]] [which( zQuant[[paste(percentiles[al])]] < 0)] = 0
  }
  
  return(list(percent = zQuant, 
              fit = best_std,
              AIC_tab =all_fits_tab,
              GOF = GOF)
  )
}
```

```{r example-Gro_analysis}
Age <- sample(c(0:10), 100, replace = T)
MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ rnorm(100,0,0.01))-1 
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue)

Gro_analysis(dat, 
             all_mods = c("logistic", "vonBertalanffy"), 
             percentiles = c(2.5, 97.5))
```


```{r tests-Gro_analysis}
data <- tibble(anonID = rep(c(1,2), c(10,15)),
               Age = c(c(1:10), c(1:15)),
               MeasurementValue = 2+3*Age)
data$MeasurementValue[1] = 0.5
data$MeasurementValue[3] = data$MeasurementValue[3]+50
data$MeasurementValue[14] = data$MeasurementValue[3]+30
data$MeasurementValue[20] = data$MeasurementValue[3]+100

test_that(
  "Gro_lin_ind error",
  {
    expect_error(
      data %>% Gro_lin_ind(IQR =0.5),
      regexp = "IQR should be higher than 1 to avoid removing real data")
    expect_error(
      data[1:4,] %>% Gro_lin_ind(),
      regexp = "There should be at least 5 measures")
  })



test_that(
  "Gro_lin_ind Tested ",
  { 
    expect_named(
      data %>% Gro_lin_ind(),
      c("anonID", "Age", "MeasurementValue", "Keep2"))
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5, remove_ext = F, traj_ind = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(remove_ext = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5)%>%pull(Keep2)),
      25-3)
  }
)
```


## Fit growth model

This function fit a given growth model to a dataset. It takes as arguments:

* num index of the model to run 
* `data`, a data frame including at least the numeric columns *logx* and *logz* 
* `model` Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial


```{r function-Gro_fitlog}

#' Fit growth model
#' 
#' Fit a growth model to data, return its fit and AIC
#' 
#' @param num \code{numeric} index of the model to run 
#' @param data \code{data.frame} including at least the numeric columns *logx* and *logz* 
#' @param all_mods \code{vector of character} indicating growth models.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial
#' 
#' @details
#' 
#' @import dplyr assertthat
#' @importFrom bbmle mle2 logLik
#'
#' @return The fit and AIC of the model
#' 
#' @export
Gro_fitlog <- function(num = 1, data, all_mods = "vonBertalanffy") {
  assert_that(all(all_mods %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c('logx', 'logz'))
  assert_that(is.numeric(data$logx))
  assert_that(is.numeric(data$logz))
  assert_that(is.numeric(num))
  assert_that(num <= length(all_mods))
  
  model = all_mods[num]
  modSett <- Gro_ModSettings(data, model)
  out = list()
  out$fit <- bbmle::mle2(modSett$growthMod, 
                         data = data, 
                         parnames = modSett$namesCoef, 
                         fixed = list(LL = T),
                         start = modSett$gamstart
                         # lower = modSett$low
  )
  out$tab = list(index = num,
                 model = all_mods[num],
                 k =modSett$np, 
                 AIC= as.numeric(2*modSett$np - 2*bbmle::logLik(out$fit))) #voir le nombre de decimal
  out$growthMod = modSett$growthMod
  return(out)
}
```

```{r example-Gro_fitlog}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)
Gro_fitlog(num = 1, data = dat, all_mods = "vonBertalanffy")
```


```{r tests-Gro_fitlog}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)

test_that(
  "Gro_fitlog error",
  {
    expect_error(
      Gro_fitlog(data = dat, all_mods = "vonBert"),
      regexp = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
    expect_error(
      Gro_fitlog(data = dat$logz), regexp = "data is not a data frame")
    expect_error(
      Gro_fitlog(num = 2, data = dat))
  })


a= Gro_fitlog(data = dat, all_mods = "vonBertalanffy")

test_that(
  "Gro_fitlog works",
  { 
    expect_named(a, c("fit", "tab"))
    expect_named(a$tab, c("index", "model", "k", "AIC"))
    expect_equal(a$tab$k, 3)
    expect_match(a$tab$model, "vonBertalanffy")
    expect_type(a$tab$AIC, "double")
    expect_equal(a$tab$index, 1)
    expect_s4_class(a$fit, "mle2")
  }
)
```

## Growth Model Setting

This function gets the parameter and equations for the growth model and takes as arguments:

* `data`, a data frame including at least the numeric columns *logx* and *logz* 
* `model` Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial


```{r function-Gro_ModSettings}

#' Growth model settings
#' 
#' This function gets the parameter and equations for the growth model
#' 
#' @param data \code{data.frame} including at least the numeric columns *logx* and *logz* 
#' @param model \code{character} Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial 
#' 
#' @details
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return a list including the function of the growth model,  the number of parameter, their names, their initial values and their lowest possible values
#' 
#' @export
# Set growth model parameters:
Gro_ModSettings <- function(data, model = "vonBertalanffy") {
  
  assert_that(model %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial"), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c('logx', 'logz'))
  assert_that(is.numeric(data$logx))
  assert_that(is.numeric(data$logz))
  logx = data$logx
  logz = data$logz
  # Range of log(x) values:
  logxDiff <- diff(range(logx))
  
  if (model == "logistic") {
    growthMod <- logisGrowth
    np <- 3
    namesCoef <- c("zinf", "gamma", "xInfl")
    lowCoef <- c(0, 0, -Inf)
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- max(logz[idInf])
    
    # X inflection:
    xInfl <- mean(range(logx))
    
    # find starting gamma:
    nGams <- 7
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inrat <- zInf / logzMeans - 1
    idk <- which(inrat > 0)
    inlog <- - log(inrat[idk]) / (logxInts[idk] - xInfl)
    gamma <- mean(inlog)
    if (is.na(gamma) | gamma == -Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, xInfl = xInfl, gamma = gamma)
    
    
    
  } else if (model == "gompertz") {
    growthMod <- gompertzGrowth
    np <- 3
    namesCoef <- c("zinf", "beta", "gamma")
    lowCoef <- c(0, 0, 0)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = -log(abs(z0/zinf))
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- log(abs(log(abs(logzMeans/zinf)) / beta))
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-inlog[idkeep] / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == -Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma)
    
  } else if (model == "chapmanRichards") {
    growthMod <- chapmanRichards
    np <- 4
    namesCoef <- c("zinf", "beta", "gamma", "m")
    lowCoef <- c(0, 0, -Inf, -Inf)
    
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = 1-(z0/zinf)
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- log(abs(logzMeans/(zinf *( 1- beta))))
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-inlog[idkeep] / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == -Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma, m = 0)
  } else if (model == "vonBertalanffy") {
    growthMod <- vbGrowth
    np <- 3
    namesCoef <- c("z0", "zinf", "gamma")
    lowCoef <- rep(0, np)
    # Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- mean(logz[idInf], na.rm = TRUE) - z0
    
    if (zInf <= 0) {
      zInf <- z0 + diff(range(logz))
    }
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:5, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- 1 - (logzMeans - z0) / zInf
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-log(inlog[idkeep]) / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == -Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, z0 = z0, gamma = gamma)
    
  } else if (model == "polynomial") {
    growthMod <- polyGrowth
    np <- 5
    namesCoef <- sprintf("gam%s", 0:np - 1)
    lowCoef <- rep(-Inf, np)
    gamStart <- list(gam0 = 0, gam1 = 0, gam2 = 0, gam3 = 0, gam4 = 0)
    
  }
  return(list(growthMod = growthMod, np = np, namesCoef = namesCoef,
              low = lowCoef, gamstart = gamStart))
}
```

```{r example-Gro_ModSettings}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)

Gro_ModSettings(data = dat, model = "vonBertalanffy")
```


```{r tests-Gro_ModSettings}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)

test_that(
  "Gro_ModSettings error",
  {
    expect_error(
      dat %>% Gro_ModSettings(model = "vonBert"),
      regexp = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
    expect_error(
      dat$logz %>% Gro_ModSettings(),
      regexp = "data is not a data frame")
  })



test_that(
  "Gro_ModSettings works",
  { 
    expect_named(
      dat %>% Gro_ModSettings(model = "vonBertalanffy"),
      c("growthMod", "np", "namesCoef", "low", "gamstart"))
    a=dat %>% Gro_ModSettings(model = "vonBertalanffy")
    expect_equal(a$np, 3)
    expect_type(a$growthMod, "closure")
    expect_type(a$low, "double")
    expect_type(a$namesCoef, "character")
    expect_named(a$gamstart, c("zinf", "z0", "gamma"))
    a=dat %>% Gro_ModSettings(model = "logistic")
    expect_named(a$gamstart, c("zinf", "xInfl", "gamma"))
    a=dat %>% Gro_ModSettings(model = "gompertz")
    expect_named(a$gamstart, c("zinf", "beta", "gamma"))
    a=dat %>% Gro_ModSettings(model = "chapmanRichards")
    expect_named(a$gamstart, c("zinf",  "beta",  "gamma", "m"))
    a=dat %>% Gro_ModSettings(model = "polynomial")
    expect_named(a$gamstart,c("gam0", "gam1", "gam2", "gam3", "gam4"))
  }
)
```




```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_growth.Rmd", vignette_name = "Growth")
```


