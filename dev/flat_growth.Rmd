---
title: "flat_growth.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
library(glue)
options(rmarkdown.html_vignette.check_title = FALSE)
```


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = F)
```



# Gro_Main


This function is the main function used to run the growth analysis for taxon profiles. It selects measures, removes outliers, selects the best growth model and produces the percentile of the best fitting growth model for the sexes and birth types selected. It takes as arguments:

* `data`: the weight or length data from ZIMS
* `coresubse`: the core data of the species from ZIMS
* `Taxa`: the name of the taxa studied
* `Species`: the name of the species studied
* `BirthType`: "Captive", "Wild", and/or "All"
* `AgeMat`: age at sexual maturity 
* `models`: indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial
* `percentiles`: indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.
* `MinInstitution` Minimum number of institutions that should hold records to run the analysis. 
* `MinNGro`: Minimum number of weight needed to fit the growth models
* `MinNIGro`: Minimum number of unique individuals needed to fit the growth models
* `type`: Either 'weight' or 'length'. Default =  'weight
* `MeasureType`: Name of the type of measurements that should be included. 
* `MinDate`: Earlier date to include data
* `PlotDir`: Directory to save the plots showing outliers and predictions from best models


The function returns a list including an analysis by sex and by birth type as included in the input. Each analysis includes: 
*  The fit of the growth models with the AIC table of the model, the fit of the best model, a data frame with the percentile selected and 3 GOF test including the normality of residuals and the test of trend in residuals against X and in the variance of the residuals.
* A summary with the number of individuals and weight used for the analysis:
- NInd_raw  and, NWeight_raw indicate the number of unique individuals and the number of weights once the sex, the birth type, the measurment type from global collection have been selected
- NWeight_val and NInd_val indicate the number of unique individuals and the number of weights once valid measurment from Husbandry have been selected
- NJuv= 0 and NAd indicate the number of weights of juveniles and adults selected
- NJuv_keep= 0 and NAd_keep indicate the number of weights of juveniles and adults selected after removing outliers
- NWeight and NInd indicate the total number of unique individuals and the number of weights used for the analysis
- a logical indicated if the growth analysis was performed
-  If the growth analysis was not performed, an error and its number (Nerr) are returned: The possibility for this functions are: 1/No raw data and 2/No valid weight measure 3/Data from 1 Institution 4/ NWeight < MinNGro 5/NInd < MinNIGro 6/Best model did not fit.

```{r function-Gro_Main}
#' Main growth analysis for Taxon Profiles
#'
#'Select measures, remove outliers, select the best growth model and produce the percentile of the best fitting growth model for the sexes and birth types selected.
#'
#' @param data \code{data.frame} including the following columns *MeasurementValue*, *MeasurementDate*, *UnitOfMeasure*, *EstimatedMeasurement*, *RecordType*, *MeasurementType*, *AnimalAnonID* and *RecordingInstitution*.
#' @param coresubse \code{data.frame} including at least the following columns *binSpecies*, *SexType*, *AnimalAnonID*, *BirthType* and *Birthdate* (\code{date})
#' @param Taxa  \code{character} the name of the taxa studied
#' @param Species \code{character} the name of the species studied
#' @param BirthType \code{vector of character} "Captive", "Wild", and/or "All"
#' @param AgeMat \code{numeric} age at sexual maturity.
#' @param models \code{vector of characters} indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.
#' @param percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.
#' @param UncertDate \code{numeric}: Maximum uncertainty accepted for measurement dates, in days
#' @param MinNGro \code{numeric} Minimum number of weight needed to fit the growth models
#' @param MinNIGro \code{numeric} Minimum number of unique individuals needed to fit the growth models
#' @param MinInstitution \code{numeric} Minimum number of institutions that should hold records to run the analysis.
#' @param type \code{character} Either 'weight' or 'length'.ht
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included.  Default: all measurement types are included.
#' @param MinDate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param PlotDir \code{character} Directory to save the plots. Default: no plot is saved.
#' @param PlotName \code{character} Name used to save the plot.
#' 
#' @return A list including an analysis by sex and by birth type as included in the input. Each analysis includes: 
#' *  The fit of the growth models with the AIC table of the model, the fit of the best model, a data frame with the percentile selected and 3 GOF test including the normality of residuals and the test of trend in residuals against X and in the variance of the residuals.
#' * A summary with the number of individuals and weight used for the analysis:
#' - NInd_raw  and, NWeight_raw indicate the number of unique individuals and the number of weights once the sex, the birth type, the measurment type from global collection have been selected
#' - NWeight_val and NInd_val indicate the number of unique individuals and the number of weights once valid  measurment from Husbandry have been selected
#' - NJuv= 0 and NAd indicate the number of weights of juveniles and adults selected
#' - NJuv_keep= 0 and NAd_keep indicate the number of weights of juveniles and adults selected after removing 
#' outliers
#' - NWeight and NInd indicate the total number of unique individuals and the number of weights used for the analysis
#' - a logical indicated if the growth analysis was performed
#' -  If the growth analysis was not performed, an error and its number (Nerr) are returned: The possibility for  this functions are: 1/No raw data and 2/No valid weight measure 3/Data from 1 Institution 4/ NWeight < MinNGro #' 5/NInd < MinNIGro 6/Best model did not fit.
#' If PlotDir is filled, 2 plots are produced: one showing the outliers removed from the data, and one showing the fit of the model on the data.
#' 
#' @import dplyr assertthat
#' @importFrom glue glue
#' @importFrom ggplot2 ggsave
#' 
#' @export
#'
#' @examples
Gro_Main <- function(data, coresubse,
                     Taxa, Species ,
                     BirthType = "All", 
                     AgeMat = NA,
                     type = "weight", MeasureType = NULL, 
                     MinInstitution = 1, UncertDate = 365,
                     MinNGro = 30, MinNIGro = 30, 
                     models = "vonBertalanffy", percentiles = c(2.5,97.5),
                     PlotDir = NULL,
                     MinDate = "1980-01-01", PlotName = '') 
{
   # Check correct format for inputs ---------------------------------------------
  MinDate = lubridate::as_date(MinDate)
  assert_that(is.data.frame(data))
  assert_that(is.data.frame(coresubse))
  assert_that(data %has_name% c("MeasurementValue", "MeasurementDate", "UnitOfMeasure", "EstimatedMeasurement", "RecordType", "MeasurementType", "AnimalAnonID", "RecordingInstitution"))
  assert_that(coresubse %has_name% c("BirthDate", "binSpecies", "SexType", "AnimalAnonID", "BirthType"))
  assert_that(is.date(MinDate))
  assert_that(is.character(Taxa))
  assert_that(Taxa %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
                          "Chondrichthyes", "Actinopterygii"),
              msg = "Taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  assert_that(is.character(Species))
    assert_that(is.character(BirthType))
    assert_that(all(BirthType %in% c("Captive", "Wild", "All")))

  assert_that(is.numeric(UncertDate))
   assert_that(is.character(PlotName))
  
  if(!is.null(MeasureType)){
    if(!all(MeasureType %in% unique(data$MeasurementType))){
      MeasureType_not = which(!(MeasureType %in% unique(data$MeasurementType)))
      warnings(paste0(MeasureType[MeasureType_not]," are not included in the data, check if they are spelled correctly"))
    }
  }
  assertthat::assert_that(type %in% c("weight",'length'))
  
  if(!is.null(PlotDir)){
    checkmate::assert_directory_exists(PlotDir)
  }
    assert_that(is.numeric( MinNIGro))
  assert_that( MinNIGro > 0)
  assert_that(is.numeric(MinNGro))
  assert_that(MinNGro > 0)
assert_that(is.character(models))
    assert_that(all(models %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy, and polynomial, in addition to GAM.")

  output = list()
  

  # ANALYSIS BY BIRTH TYPE ------------------------------------------------------------------
    for (bt in BirthType) {
      ouput <- Gro_cleanmeasures(data, coresubse = coresubse,
                                  BirthType = bt, type = type, 
                                 UncertDate = UncertDate,
                                  MeasureType = MeasureType,
                                  MinDate = MinDate,
                                  corevariable = NULL, variablekeep =NULL)
      
      wAnalysis <- NULL    
      list2 = list( AgeMat = AgeMat,
                    NJuv = 0, NJuv_keep = 0,
                    NAd = 0, NAd_keep = 0, 
                    NWeight = 0, NInd = 0, analyzed = FALSE)
      summar = append(ouput$summar,list2)
      if(nrow(ouput$data)>0){
        data_weight <- ouput$data%>%
          Gro_remoutliers (Taxa = Taxa, AgeMat = AgeMat, maxweight = NULL, 
                           variableid = "AnimalAnonID", min_Nmeasures = 7,
                           perc_weight_min=0.2, perc_weight_max=2.5,
                           IQR=2.75, minq=0.025, Ninterval_juv = 10)
        summar$NJuv = nrow(data_weight%>%filter(juv==1))
        summar$NJuv_keep  = nrow(data_weight%>%filter(juv==1, KEEP == 1))
        summar$NAd = nrow(data_weight%>%filter(juv==0))
        summar$NAd_keep = nrow(data_weight%>%filter(juv==0, KEEP == 1))
        
        if(!is.null(PlotDir)){
          p1 <-Gro_outplot(data_weight, title = glue("{PlotName}_{bt}"), ylimit = NULL, xlimit = NULL)
          ggsave(p1, filename = glue("{PlotDir}/{PlotName}_{bt}_outliers.png"), height = 6, width = 6)
        }
        
        data_weight <- data_weight %>%filter(KEEP ==1)
        
        if(length(unique(data_weight$RecordingInstitution))>= MinInstitution){
          
          #Take distinct measures are there are some duplicates within raw data
          datsub = data_weight%>%
            dplyr::select(-RecordingInstitution)%>%
            distinct()
          
          summar$NWeight <- nrow(datsub)
          summar$NInd <-  length(unique(datsub$AnimalAnonID))
          
          if (summar$NWeight >= MinNGro) {
            if (summar$NInd >= MinNIGro) {
              summar$analyzed = TRUE
              wAnalysis <- Gro_analysis(data_weight = datsub, 
                                        all_mods = models, 
                                        percentiles = percentiles)
              
              if(!is.null(PlotDir)){
                p2 <-Gro_plot(data = datsub, data_percent = wAnalysis$percent,
                              title =  glue("{PlotName}_{bt}"))
                ggsave(p2, filename = glue("{PlotDir}/{PlotName}_{bt}_growth.png"), height = 6, width = 6)
              }
              
              #condition on model fit
              if (!all(unlist(wAnalysis$GOF))){
                summar$Nerr = 6
                summar$error = "Model did not fit"
              }
            } else {
              summar$Nerr = 5  #nocov
              summar$error = "NInds < MinNIGro" #nocov
              wAnalysis<-  NULL  #nocov
            }
          } else {
            summar$Nerr = 4  #nocov
            summar$error = "NWeight < MinNGro" #nocov
            wAnalysis<-  NULL  #nocov
          }
        } else {
          summar$Nerr = 3 #nocov
          summar$error = "Data from 1 Institution" #nocov
          
        }
      }
      
      output[[bt]] <- list(wSummar = summar, weightQ = wAnalysis)
    }
  
  return(output)
}
```


```{r examples-Gro_Main}
data(weights)
data(core)
output= Gro_Main(data = weights, coresubse = core,
                 Taxa = "Reptilia", Species = "Testudo hermanni" ,
                 BirthType = c("Captive", "Wild"), AgeMat = 1,
                 type = "weight", MeasureType = "Live weight",
                 MinNGro = 30, MinNIGro = 30, 
                 models = c("vonBertalanffy", "logistic"), percentiles = c(2.5,97.5)) 
```



```{r tests-Gro_Main}
data(weights)
data(core)


test_that("Gro_Main Captive works", {
  output= Gro_Main(data = weights, coresubse = core,
                   Taxa = "Reptilia", Species = "Testudo hermanni" ,
                   BirthType = c("Captive", "Wild"), 
                   AgeMat = 1, MeasureType = "Live weight",
                   type = "weight", 
                   MinNGro = 30, MinNIGro = 30, 
                   models = c("vonBertalanffy", "logistic"), percentiles = c(2.5,97.5)) 
  
  expect_named(output,c("Captive", "Wild"))
  expect_named(output$Captive,c("wSummar", "weightQ"))
  expect_named(output$Captive$wSummar,
               c("NInd_raw", "NWeight_raw", "NWeight_val", "NInd_val", 
                 "error", "Nerr", "AgeMat", "NJuv", 
                 "NJuv_keep", "NAd", "NAd_keep", "NWeight", "NInd", "analyzed"))
  expect_equal(output$Captive$wSummar$NWeight_raw, 2393)
  expect_equal(output$Captive$wSummar$Nerr, 6)
  expect_equal(output$Captive$wSummar$NWeight, 2307)
  expect_true(output$Captive$wSummar$analyzed)
  expect_match(output$Captive$wSummar$error,"Model did not fit")
  expect_equal(output$Wild$wSummar$NJuv, 183)
  expect_equal(output$Wild$wSummar$Nerr, 6)
  expect_equal(output$Wild$wSummar$NAd, 2205)
  expect_true(output$Wild$wSummar$analyzed)
  expect_match(output$Wild$wSummar$error,"Model did not fit")
  expect_named(output$Captive$weightQ, c("percent", "fit", "AIC_tab", "GOF"))
  
})
```


# Gro_cleanmeasures


This function is used to prepare weight and length dataset. It unify the unity used, select clean measures and add individual age at each measure. This function takes as arguments:

* `data`: the weight or length data from ZIMS
* `coresubse`: the core data of the species from ZIMS
* `BirthType` Captive, Wild, or All Default =  "All"
* `MinDate` Earlier date to include data ('YYYY-MM-DD')
* `UncertDate` Maximum uncertainty accepted for measurement dates, in days
* `MeasureType` Name of the type of measurement that should be included. Default = NULL, all measurement type are included.
* `type` Either 'weight' or 'length'.

The function returns a list including:
* The data frame including selected measures, plus individual birth date and individual age at each measure
* A summary with the number of individuals and weight:
- NInd_raw  and, NWeight_raw indicate the number of unique individuals and the number of weights once the sex, the birth type, the measurment type from global collection have been selected
- NWeight_val and NInd_val indicate the number of unique individuals and the number of weights once valid measurment from Husbandry have been selected
-  If no data are selected, an error and its number (Nerr) are returned: The possibility for this functions are: 1/No raw data and 2/No valid weight measure.


```{r function-Gro_cleanmeasures}
#' Prepare weight and length Dataset
#'
#'Select clean measures, unify the unity used and add individual age at each measure
#'
#' @param data \code{data.frame} including the following columns *MeasurementValue*, *MeasurementDate*, *MeasurementDateStart*, *MeasurementDateEnd*, *UnitOfMeasure*, *EstimatedMeasurement*, *RecordType*, *MeasurementType*, *AnimalAnonID*, *RecordingInstitution*, and *Age*.
#' @param coresubse \code{data.frame} including at least the following columns *binSpecies*, *SexType*, *AnimalAnonID* and *BirthType*.
#' @param BirthType \code{character} Captive, Wild, or All.
#' @param MinDate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param UncertDate \code{numeric}: Maximum uncertainty accepted for measurement dates, in days.
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included. Default: all measurement type are included.
#' @param type \code{character} Either 'weight' or 'length'.
#' @param corevariable \code{vector character} Name of the core columns that must be added to data.
#' @param variablekeep \code{vector character} Name of the data columns that must also be returned.
#' 
#' @return A list including
#' * The data frame including selected measures, plus individual birth date and individual age at each measure
#' * A summary with the number of individuals and weight:
#'         - NInd_raw  and, NWeight_raw indicate the number of unique individuals and the number of weights once the sex, the birth type, the measurment type from global collection have been selected
#'           - NWeight_val and NInd_val indicate the number of unique individuals and the number of weights once valid measurment from Husbandry have been selected
#'          -  If no data are selected, an error and its number (Nerr) are returned: The possibility for this functions are: 1/No raw data and 2/No valid weight measure.
#' 
#' @import dplyr assertthat
#' 
#' @export
#'
#' @examples
Gro_cleanmeasures <- function(data, coresubse,
                              BirthType = "All", type = "weight", MeasureType = NULL,
                               MinDate = "1980-01-01", UncertDate = 365,
                              corevariable = NULL, variablekeep =NULL) 
{
   # Check correct format for inputs ---------------------------------------------
  MinDate = lubridate::as_date(MinDate)
  assert_that(is.data.frame(data))
  assert_that(is.data.frame(coresubse))
  assert_that(data %has_name% c("MeasurementValue", "MeasurementDate","MeasurementDateEstimateStart","MeasurementDateEstimateEnd", "UnitOfMeasure", "EstimatedMeasurement", "RecordType", "MeasurementType", "AnimalAnonID", "RecordingInstitution", "Age"))
  assert_that(coresubse %has_name% c("binSpecies", "SexType", "AnimalAnonID", "BirthType"))
   assert_that(is.character(BirthType))
  assert_that(BirthType %in% c("Captive", "Wild", "All"))
  assert_that(is.date(MinDate))
  assert_that(is.numeric(UncertDate))
  
  
  if(!is.null(corevariable)) {
    assert_that(is.character(corevariable))
    assert_that(coresubse %has_name% corevariable)}
  if(!is.null(variablekeep)) {
    assert_that(is.character(variablekeep))
    assert_that(data %has_name% variablekeep)}
  
  if(!is.null(MeasureType)){
    if(!all(MeasureType %in% unique(data$MeasurementType))){
      MeasureType_not = which(!(MeasureType %in% unique(data$MeasurementType)))
      warnings(paste0(MeasureType[MeasureType_not]," are not included in the data, check if they are spelled correctly"))
    }
  }
  assertthat::assert_that(type %in% c("weight",'length'))
  summar <- list(NInd_raw = 0, NWeight_raw = 0, 
                 NWeight_val = 0, NInd_val =0, 
                 error = "", Nerr = 0)
  

  Corevariable = c("binSpecies", "SexType", "AnimalAnonID", corevariable) 
  Variablekeep = c(Corevariable,"RecordingInstitution","MeasurementType", "UnitOfMeasure",
                   "MeasurementDate", "Age", "MeasurementValue",  variablekeep)
  
  
  
  if (BirthType != "All"){
    coresubse<- coresubse%>%
      filter(stringr::str_detect(BirthType, pattern = BirthType))
  }

  
  data <- data%>%
    filter(AnimalAnonID %in% coresubse$AnimalAnonID)%>%
    mutate(MeasurementDate = lubridate::as_date(MeasurementDate),
           MeasurementDateEstimateStart = lubridate::as_date(MeasurementDateEstimateStart),
           MeasurementDateEstimateEnd = lubridate::as_date(MeasurementDateEstimateEnd),
           Date_Uncert = MeasurementDateEstimateEnd - MeasurementDateEstimateStart)%>%
    filter((Date_Uncert <= UncertDate)%>% replace_na(TRUE))%>%
    left_join(coresubse%>%dplyr::select(all_of(Corevariable)), by = "AnimalAnonID")
  
  
  if(nrow(data)>0){
    if(!is.null(MeasureType)){
      data<- data%>%
        filter(MeasurementType %in% MeasureType)
      }
    summar$NInd_raw = length(unique(data$AnimalAnonID))
    summar$NWeight_raw = nrow(data)
  }else{
    warnings('no common ID between measured data and core data')  # nocov
  }
  
  if(nrow(data)>0){
    data<- data%>%
      filter(MeasurementDate>= MinDate,
             !is.na(MeasurementValue),
             !is.na(Age),
             EstimatedMeasurement == 0 , 
             MeasurementValue > 0,
             RecordType == "",
             Age >= 0
      )%>%
      dplyr::select(all_of(Variablekeep))
    summar$NInd_val = length(unique(data$AnimalAnonID))
    summar$NWeight_val = nrow(data)
  }else{
    summar$error = "No valid weight measure"
    summar$Nerr = 1
    data <- data.frame()}

  return(list(data = data, summar = summar))
}
```


```{r examples-Gro_cleanmeasures}
data(weights)
data(core)
data_weights= Gro_cleanmeasures(weights, core,
                                BirthType = "All",
                                MeasureType = 'Live weight',
                                MinDate = "1980-01-01")
```



```{r tests-Gro_cleanmeasures}
data(weights)
data(core)

test_that("Gro_cleanmeasures works", {
  d=Gro_cleanmeasures(weights, core)
   expect_named(
    d$data,
    c("binSpecies", "SexType", "AnimalAnonID", "RecordingInstitution", "MeasurementType", "UnitOfMeasure", "MeasurementDate", "Age", "MeasurementValue"))
  expect_named(
    d$summar,
    c("NInd_raw", "NWeight_raw", "NWeight_val", "NInd_val", "error", "Nerr"))
  expect_true(unique(d$data$UnitOfMeasure) == "kg")  
  d=Gro_cleanmeasures(weights, core[1,])
 d=Gro_cleanmeasures(weights, core,  MeasureType = 'Live weight',
                     corevariable = "FirstAcquisitionDate", 
                     variablekeep= "MeasurementType")

})
```



# gro_remoutliers

This function removes the outliers from a dataset of weights. This function takes as arguments:
`
* `data_weight` a data frame that must include at least the columns `MeasurementValue`, `MeasurementType`, and `Age`.
* `Taxa` the name of the taxa studied
* `AgeMat` the MINIMUM age at sexual maturity. The function takes as threshold 1.2*AgeMat to differentiate juveniles (still growing) from adults
* `maxweight`
* `variableid` name of the column including individual IDs. Defaut = "AnimalAnonID". It must also be a column of `data_weight`
* `minq` Sensitivity of the function to remove outliers using percentiles, between 0 and 1. Default =  0.025
* `IQR` influences the sensitivity of the function to remove outliers using generalized additive model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year . Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year . Default =  2.5 (250%)

This function follow 4 different steps to highlight outliers:
1/ It removes the measures higher than the argument `maxweight` (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).  In the default case, default values are in kilograms and are set at 7000kg for Mammalia, 200kg for Aves, 1500kg for Reptilia, 100kg for Amphibia, 1000kg for Chondrichthyes and 500kg for Osteichthyes.
2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles. You can choose the number of intervals used for the sliding windows using the argument `Ninterval_juv`.
3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least `min_Nmeasures` measures and remove outliers based on the residuals of the models.
4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.

The function returns the data frame including the column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3, and the column juv indicates which individuals have been classified as juveniles.



```{r function-Gro_remoutliers}

#' Remove outliers from weigth or length data
#'
#'Takes a data frame including weight measures and Age and look for possible outliers
#'
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *MeasurementType*,  *Age*  (\code{numeric}).
#' @param Taxa  \code{character} Name of the taxa.
#' @param AgeMat \code{numeric} Age at sexual maturity to differentiate juveniles (still growing) from adults.
#' @param maxweight \code{numeric} the maximum weight allowed for the dataset
#' @param variableid \code{character} name of the variable including individual ids. It must also be a column of data_weight.
#' @param min_Nmeasures \code{integer} Minimum number of measures for an individual to check outliers along its growth trajectory. It must be at least 5.
#' @param minq \code{numeric} Sensitivity of the function to remove outliers using percentiles, between 0 and 1.
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers using log-linear model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year. Default: 20%.
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year. Default: 250%.
#' @param Ninterval_juv \code{integer} Number of intervals used for the sliding windows for juveniles.
#' 
#' @return The data frame including the additional column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3 and the column juv indicates which individuals have been classified as juveniles.
#' 
#' @details
#'This function follow 4 different steps to highlight outliers:
#'1/ It removes the measures higher than \code{maxweight} (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).
#'2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles.
#'3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least 7 measures and remove outliers based on the residuals of the models.
#'4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.
#' 
#' @import dplyr assertthat
#' @importFrom stats lm predict.lm
#' 
#' @export
#'
#' @examples
Gro_remoutliers <- function(data_weight, Taxa, AgeMat = NA, maxweight = NULL, 
                            variableid = "AnimalAnonID", min_Nmeasures = 7,
                            perc_weight_min=0.2, perc_weight_max=2.5,
                            IQR=2.75, minq=0.025, Ninterval_juv = 10) {
  
   # Check correct format for inputs ---------------------------------------------
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue","MeasurementType", "Age"))
  if(length(unique(data_weight$MeasurementType))==1){warnings( glue::glue("Multiple measurment types found in the data: {stringr::str_flatten_comma(unique(data_weight$MeasurementType))}, Data should often include only one Measurement Type"))}
  assert_that(Taxa %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
                          "Chondrichthyes", "Osteichthyes"),
              msg = "Taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Osteichthyes'")
  if(is.null(maxweight)){
    maxweight = 10000000
    if(Taxa == "Mammalia")       maxweight = 7000 #nocov
    if(Taxa == "Aves")           maxweight = 200 #nocov
    if(Taxa == "Reptilia")       maxweight = 1500 #nocov
    if(Taxa == "Amphibia")       maxweight = 100 #nocov
    if(Taxa == "Chondrichthyes") maxweight = 1000 #nocov
    if(Taxa == "Osteichthyes") maxweight = 500 #nocov
  }
  assert_that(is.numeric(maxweight))
  assert_that(min_Nmeasures%%1==0, msg = "min_Nmeasures should be an integer")
  assert_that(min_Nmeasures>=5)
  assert_that(Ninterval_juv%%1==0, msg = "Ninterval_juv should be an integer")
  assert_that(all(data_weight$MeasurementValue>0))
  assert_that(all(data_weight$Age>=0))
  
  if(variableid != "AnimalAnonID"){
    data_weight <- data_weight%>%               #nocov
      rename(AnimalAnonID = !!sym(variableid))  #nocov
  }
  
  if(is.na(AgeMat)){AgeMat=1.5}
  assert_that(is.numeric(AgeMat))
  
  #1) Removes very large weights using maxweight ----
  data_weight <- data_weight%>%
    mutate(keep1 = ifelse(MeasurementValue< maxweight, 1, 0))
  
  #2) Separate Juveniles and adults 
  ### JUVENILES ----
  juv <- data_weight%>%
    mutate(juv = 1)%>%
    filter(Age >= 0, Age < AgeMat*1.2)
  if (nrow(juv) > 0) {
    
    ##a/Uses sliding windows to check outliers based on percentile of the distribution 
    #Make Ninterval_juv for sliding windows
    nInts = Ninterval_juv
    windInts <- seq(0, AgeMat, length = nInts+1)
    numInt <- table(findInterval(juv$Age[juv$keep1==1], windInts))
    nWindInts <- 0
    ii <- 1
    while (ii < nInts) {
      cumInt <- cumsum(numInt[ii:nInts])
      idnum <- which(cumInt > 30) + ii
      if (length(idnum) > 0) {
        nWindInts <- c(nWindInts, windInts[idnum[1]])
        ii <- idnum[1]
      } else {
        nWindInts <- c(nWindInts, windInts[nInts+1])
        ii <- nInts
      }
    }
    if (!AgeMat %in% nWindInts)  nWindInts <- c(nWindInts, AgeMat)
    nInts <- length(nWindInts) - 1
    juv$keep2 = juv$keep1
    for (iints in 1:nInts) {
      idwind <- which(juv$Age >= nWindInts[iints] & 
                        juv$Age <= nWindInts[iints + 1] & 
                        juv$keep1 == 1)
      juv$keep2[idwind] = Gro_Rout_quan(z = juv$MeasurementValue[idwind], x =  juv$Age[idwind],
                                        minq = minq, type = "both")
    }
    
    
    ##b/Uses individual trajectories to find outliers for juveniles with at least 7 measures
    juv <-juv %>%
      group_by(AnimalAnonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    juv$keep3 = juv$keep2
    if(any(juv$nb >= min_Nmeasures & juv$la>=4)){
      juv_temp  <- Gro_lin_ind(juv%>%filter(keep2 == 1, nb >= min_Nmeasures, la >= 4), 
                               perc_weight_min = perc_weight_min,
                               perc_weight_max = perc_weight_max,
                               IQR = IQR,
                               remove_ext = F, traj_ind = T
      )
      
      juv$keep3[juv$keep2==1 & juv$nb >= min_Nmeasures & juv$la >=4] = juv_temp$Keep2 
    }
  }
  
  ### ADULTS ----
  ad <- data_weight%>%
    mutate(juv = 0)%>%
    filter(Age >=  AgeMat*1.2)
  if (nrow(ad) > 0) {
    
    ##a/Check outliers based on percentile of the distribution 
    ad$keep2=ad$keep1
    ad$keep2[ad$keep1 == 1] = Gro_Rout_quan(z = ad$MeasurementValue[ad$keep1 == 1], x =  ad$Age[ad$keep1 == 1],  
                                            minq = minq, type = "both")
    
    ##b/Uses individual trajectories to find outliers for adults with at least 7 measures
    ad <-ad %>%
      group_by(AnimalAnonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    ad$keep3 = ad$keep2
    if(any(ad$nb >= min_Nmeasures & ad$la>=4)){
      
      ad_temp <- Gro_lin_ind(ad%>%filter(keep2==1, nb >= min_Nmeasures, la >= 4), 
                             perc_weight_min = perc_weight_min,
                             perc_weight_max = perc_weight_max,
                             IQR = IQR,
                             remove_ext = F, traj_ind = T
      )
      ad$keep3[ad$keep2==1 & ad$nb >= min_Nmeasures & ad$la >=4] = ad_temp$Keep2 
    }
  }
  
  data_weight1 =rbind(juv,ad)%>%dplyr::select(-nb,-la)
  #3) Uses global GAM model to detect remaining outliers ----
  data_weight1$KEEP= data_weight1$keep3
  if(sum(data_weight1$KEEP)>4){
    if(length(unique(data_weight1$Age[data_weight1$KEEP==1]))>=4){
      data_weight1_temp <- Gro_lin_ind(data_weight1%>%filter(keep3==1), 
                                       perc_weight_min = perc_weight_min,
                                       perc_weight_max = perc_weight_max,
                                       IQR = IQR,
                                       remove_ext = F, traj_ind = F
      )
      data_weight1$KEEP [data_weight1$keep3 == 1] = data_weight1_temp$Keep2
    }
  }
  return(data_weight1)
  
}
```


```{r examples-Gro_remoutliers}
data(weights)
weights = Gro_remoutliers(weights[weights$MeasurementType == "Live weight",], 
                          Taxa = "Mammalia", AgeMat = 10)
```


```{r development-Gro_remoutliers}
plot(MeasurementValue ~Age, data = weights, ylim = c(0,400), xlim = c(0,50))
#Show the four steps used to remove outliers
#1/ using maximum value
points(MeasurementValue ~Age, data = weights%>%filter(keep1==0),
       col = "red", pch = 16) 
#2/ using Inter quartile range
points(MeasurementValue ~Age, data = weights%>%filter(keep2==0, keep1==1 ),
       col = "green", pch = 16) 
#3a/ using individual trajectories
points(MeasurementValue ~Age, data = weights%>%filter(keep3==0, keep2==1), 
       col = "cyan", pch = 16) 
#3b/ using global log-linear model
points(MeasurementValue ~Age, data = weights%>%filter(KEEP==0, keep3==1), 
       col = "blue", pch = 16) 

1#Individual trajectories
i=0
anon = unique(weights$AnimalAnonID[weights$keep3==0 & weights$keep2==1 ])
i=i+1
plot(MeasurementValue ~Age, data = weights%>%
       filter(keep2==1, AnimalAnonID == anon[i]))
points(MeasurementValue ~Age, data = weights%>%
         filter(keep3==0, AnimalAnonID == anon[i], keep2==1),
       col = "cyan", pch = 16)

#Other tests
# data(weights_lion)
# weights = Gro_remoutliers(weights_lion, Taxa = "Mammalia", AgeMat =2, IQR = 2.75, minq=0.025)
# data(weights_bison)
# weights = Gro_remoutliers(weights_bison, Taxa = "Mammalia", AgeMat =10, IQR = 2.75, minq=0.025)
# data(weights_meerkat)
# weights = Gro_remoutliers(weights_meerkat, Taxa = "Mammalia", AgeMat =1, IQR = 2.75, minq=0.025)
# data(weights_gorilla)
# weights = Gro_remoutliers(weights_gorilla, Taxa = "Mammalia", AgeMat =12, IQR = 2.75, minq=0.025)
# data(weights_chev)
# weights = Gro_remoutliers(weights_chev, Taxa = "Mammalia", AgeMat =1, IQR = 2.75, minq=0.025,variableid ="AnimalAnonID")
```



```{r tests-Gro_remoutliers}

test_that("Gro_remoutliers errors", {
  expect_error(Gro_remoutliers(tibble(age = 2,MeasurementValue=5, MeasurementType ="Weight"), Taxa = "Mammalia", AgeMat = 10),
               msg = "data_weight does not have all of these name(s): 'MeasurementValue', 'Age'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), Taxa = "mammalia", AgeMat = 10),
               msg = "Taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5, MeasurementType ="Weight"), Taxa = "Mammalia", AgeMat = 10, min_Nmeasures = 3.3),
               msg = "min_Nmeasures should be an integer")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5, MeasurementType ="Weight"), Taxa = "Mammalia", AgeMat = 10, min_Nmeasures = 3),
               msg = "min_Nmeasures not greater than or equal to 5")
})


test_that("Gro_remoutliers works", {
  data = tibble(Age = c(rep(c(1:5),2),4),
                MeasurementValue= c(5,10000,3,6,5,4,100,2,5,3,4),
                MeasurementType = "Weight",
                AnimalAnonID = c(rep(1:2, each = 5),3))
  
  a= Gro_remoutliers(data, Taxa = "Mammalia", AgeMat = 10,
                     min_Nmeasures = 5, minq = 0.1, IQR = 1.2)
  expect_true(sum(a$keep1) == 10)
  expect_true(sum(a$keep2) == 9)
  expect_true(sum(a$keep3) == 9)
  expect_true(sum(a$KEEP) == 9)
})
```


## Remove outliers from percentiles

This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.
This function does not remove the 2 youngest and 2 oldest individuals.

The measurement values must be positive

```{r function-Gro_Rout_quan}
#' Remove outliers from percentiles
#'
#' @param z  \code{numeric vector} Measurement values
#' @param x  \code{numeric vector} Age
#' @param minq \code{numeric} Sensitivity of the function to remove outliers, between 0 and 1.
#' @param type \code{character} "both", "lower", or "upper" to choose if the lower or upper part of the distribution should be screened.
#'
#' @return
#' Vector of 0 and 1 indicating the measurement values to keep (=1) vs. the outliers (=0).
#' 
#' @importFrom stats quantile
#' 
#' @export
#' 
#' @details
#' This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.
#'
#' @examples
Gro_Rout_quan <- function (z, x, minq = 0.05, type = "both") 
{
   # Check correct format for inputs ---------------------------------------------
  assert_that(is.numeric(z))
  assert_that(is.numeric(x))
  assert_that(length(z) == length(x))
  assert_that(is.numeric(minq))
  assert_that(is.character(type))
  assert_that(minq < 1, msg = "minq must be a proportion between 0 and 1")
  assert_that(minq > 0, msg = "minq must be a proportion between 0 and 1")
  assert_that(type %in% c("upper", "lower", "both"))
  qzn <- quantile(z, c(minq, 1-minq))
  qzrat <- qzn[2]/qzn[1]
  qzlu <- c(quantile(z, 0.5)/qzrat, quantile(z, 0.5) * qzrat)
  if(type =="both"){idkeep <- which(z > qzlu[1] & z < qzlu[2])}
  if(type =="lower"){idkeep <- which(z > qzlu[1])}
  if(type =="upper"){idkeep <- which(z < qzlu[2])}
  
  indKeep = rep(0,length(z))
  indKeep[idkeep] <- 1
  
  #Avoid removing youngest and oldest individuals that might be the lightest and heaviest 
  b = rank(x)
  indKeep[x < 0.1] <- 1
  indKeep[b < 3] <- 1
  indKeep[b > max(b-2, na.rm = T)] <- 1
  
  return(indKeep)
}
```

```{r examples-Gro_Rout_quan}
z = c(rnorm(100,5,1), runif(3,40,100))
x = rnorm(103,3,2)
Gro_Rout_quan (z,x, minq = 0.05)
```

```{r tests-Gro_Rout_quan}
z1 = c(rnorm(95,4,1), runif(5,100,1000))
x1 = c(rnorm(100,4,2))

test_that("Gro_Rout_quan error", {
  expect_error(Gro_Rout_quan("text", x1))
  expect_error(Gro_Rout_quan(z1, x1, minq = 1) , regexp = "minq must be a proportion between 0 and 1")
})

test_that("Gro_Rout_quan works", {
  expect_true(sum(Gro_Rout_quan(z1, x1, minq = 0.05)) >= 95)
 expect_true(sum(Gro_Rout_quan(z1, x1, minq = 0.05, type = "lower")) >= 95)
 expect_true(sum(Gro_Rout_quan(z1, x1, minq = 0.05, type = "upper")) >= 95)
})
```


## Linearize individual trajectories

This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`and `AnimalAnonID`
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year. Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year. Default =  2.5 (250%). This value is used only after 1 year old 
* `IQR` influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
* `remove_ext` Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers. Default =  TRUE
*  `traj_ind` Do you want to build a model at the level of the individual trajectory  Default =  TRUE. If yes, each individual trajectory must have at least 5 measures. 

The function uses build generalized additive model of the measurement value in relation to age. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. `perc_weight_min` and `perc_weight_max` limit the values that must be considered as outliers.

```{r function-Gro_lin_ind}
#' Flag outliers in individual trajectories
#' 
#' This function flag 
#' 
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric}) and *AnimalAnonID*.
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year. Default : 20%.
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year. Default: 250%. This value is used only after 1 year old.
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
#' @param remove_ext \code{logical} Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers.
#' @param traj_ind \code{logical} Do you want to build linear model at the level of the individual trajectory. If TRUE, each individual trajectory must have at least 5 measures. 
#' 
#' @details
#' The function uses a log-linear model of the measurement value in relation to a quadratic effect of age for each individual trajectories. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. \code{perc_weight_min} and \code{perc_weight_max} limit the values that must be considered as outliers.
#'The \code{remove_ext} argument prevents the function from removing the 2 last and 2 first value observations in relation to age as these values may often be farther from the prediction line.
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return data frame; the data set including an additional column *Keep2* of 0 (potential outliers) and 1
#' 
#' @export
Gro_lin_ind <- function(data_weight, 
                        perc_weight_min = 0.2,
                        perc_weight_max = 2.5,
                        IQR = 1.5,
                        remove_ext = T,
                        traj_ind = T
) {
   # Check correct format for inputs ---------------------------------------------
  assert_that(is.numeric(perc_weight_min ))
  assert_that(perc_weight_min  >0 )
  assert_that(perc_weight_min  <1)
  assert_that(is.numeric(perc_weight_max ))
  assert_that(perc_weight_max  >1 )
  assert_that(is.numeric(IQR))
  assert_that(IQR  > 1, msg = 'IQR should be higher than 1 to avoid removing real data')
  assert_that(is.logical(remove_ext))
  assert_that(is.logical(traj_ind))
  assert_that(data_weight %has_name% c("MeasurementValue","Age", "AnimalAnonID"))
  
  
  data_weight<-data_weight%>%
    dplyr::mutate(pop = 1)%>%
    dplyr::group_by(pop)
  
  assert_that(nrow(data_weight)  > 4, msg = 'There should be at least 5 measures')
  assert_that(min(length(unique(data_weight$Age)))  >= 4, msg = 'Measures must have been taken at 4 different unique ages, at least')
  
  
  #only for individual trajectory 
  if(traj_ind==T){
    da_weight<-data_weight%>%
      summarize(nb= n(),
                la = length(unique(Age)))
    assert_that(min(da_weight$nb)  > 4, msg = 'Each individual trajectory must have at least 5 measures')
    assert_that(min(da_weight$la)  >= 4, msg = 'Each individual trajectory must have measures at 4 different unique ages, at least')
  }
  data_weight$pred2 = perc_weight_max
  data_weight$pred2[data_weight$Age<1] = 1000
  data_weight<-data_weight%>%
    mutate(pred = stats::predict(mgcv::gam(MeasurementValue ~ s(Age, bs = "cr", k=3), data = cur_group())),
           res = abs(MeasurementValue - pred),
           pred1 = abs(perc_weight_min*pred),
           pred2 = abs(pred*pred2),
           lwr = abs(IQR*(quantile(res,0.90)-quantile(res,0.10))),
           ager = rank(Age),
           #Prevent from removing 2 first and 2lasts obs as they will tend to be removed
           age0 = ager < min(ager)+2,
           agem = ager > max(ager)-2)%>%
    dplyr::ungroup()%>% 
    rowwise%>%
    mutate(
      Keep2 = res < min(max(lwr,pred1),pred2))
  if( !(remove_ext))   data_weight$Keep2[data_weight$age0 | data_weight$agem]=1
  data_weight<-data_weight%>%
    dplyr::select(- pred1, -lwr, -res, -age0, -agem, -pred, -ager,
                  -pop, -pred2)
  
  return(data_weight)
}
```

```{r example-Gro_lin_ind}
data(weights)

#We use only trajectories for which the number of individual datapoints is > 6
weights <- weights%>%
  dplyr::group_by(AnimalAnonID)%>%
  dplyr::mutate(nb= dplyr::n())%>%
  dplyr::ungroup()%>%
  dplyr::filter(nb >6)

weights_ind <- weights%>%Gro_lin_ind(traj_ind = TRUE)
as.numeric(weights_ind$Keep2)

weights_pop <- weights%>%Gro_lin_ind(traj_ind = FALSE)
```


```{r tests-Gro_lin_ind}
data <- tibble(AnimalAnonID = rep(c(1,2), c(10,15)),
               Age = c(c(1:10), c(1:15)),
               MeasurementValue = 2+3*Age)
data$MeasurementValue[1] = 0.5
data$MeasurementValue[3] = data$MeasurementValue[3]+50
data$MeasurementValue[14] = data$MeasurementValue[3]+30
data$MeasurementValue[20] = data$MeasurementValue[3]+100

test_that(
  "Gro_lin_ind error",
  {
    expect_error(
      data %>% Gro_lin_ind(IQR =0.5),
      regexp = "IQR should be higher than 1 to avoid removing real data")
    expect_error(
      data[1:4,] %>% Gro_lin_ind(),
      regexp = "There should be at least 5 measures")
  })



test_that(
  "Gro_lin_ind Tested ",
  { 
    expect_named(
      data %>% Gro_lin_ind(),
      c("AnimalAnonID", "Age", "MeasurementValue", "Keep2"))
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5, remove_ext = F, traj_ind = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(remove_ext = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5)%>%pull(Keep2)),
      25-3)
  }
)
```



## Plot outliers

This function makes a plot higlighting the outliers found by Gro_remoutliers()). It takes as arguments:

* data output from Gro_remoutliers() including at least the numeric columns *Age*, *MeasurementValue*, *keep1*, *keep2*, *keep3*, and *KEEP*
* title of the plot
* xlimit: min and max for the x axis
* ylimit: min and max for the y axis


The plot of the data points showed the outliers :
* in red if detected using the maximum possible value
* in green if detected using the inter quartile range
* in cyan if detected using individual trajectories
* in blue if detected from the global log-linear model

```{r function-Gro_outplot}

#' Plot outliers
#' 
#'Plot higlighting the outliers found by \code{Gro_remoutliers()}
#' 
#' @param data \code{data.frame} including at least the numeric columns *Age*, *MeasurementValue*, *keep1*, *keep2*, *keep3*, and *KEEP*.
#' @param title \code{character} Title of the plot.
#' @param xlimit \code{vector of 2 numeric} x limit for the plot.
#' @param ylimit \code{vector of 2 numeric} y limit for the plot.
#' 
#' @import dplyr assertthat 
#' @importFrom ggplot2 ggplot geom_point ggtitle aes xlim ylim
#'
#' @return Plot of the data points with outliers showed:
#'  - in red if detected using the maximum possible value
#'  - in green if detected using the inter quartile range
#'  - in cyan if detected using individual trajectories
#'  - in blue if detected from the global log-linear model
#' 
#' @export
Gro_outplot <- function(data, title = "", ylimit = NULL, xlimit = NULL) {
  # Check correct format for inputs ---------------------------------------------
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c("MeasurementValue","Age", 'keep1', 'keep2', 'keep3', "KEEP"))
  assert_that(is.numeric(data$MeasurementValue))
  assert_that(is.numeric(data$Age))
  
  if (is.null(xlimit)){
    xlimit = c(min(data$Age, na.rm = T), max(data$Age, na.rm = T))
  }
  if (is.null(ylimit)){
    ylimit = c(min(data$MeasurementValue, na.rm = T), max(data$MeasurementValue, na.rm = T))
  }
  assert_that(is.numeric(xlimit))
  assert_that(is.numeric(ylimit))
  
  p <- ggplot(data, aes(x = Age, y = MeasurementValue))+
    xlim(xlimit)+ ylim (ylimit)+
    geom_point()+
    ggtitle(title)+
    #Show the four steps used to remove outliers
    #1/ using maximum value
    geom_point(data = data%>%dplyr::filter(keep1==0), color = "red")+
    #2/ using Inter quartile range
    geom_point(data = data%>%dplyr::filter(keep2==0, keep1==1 ), color = "green")+
    #3a/ using individual trajectories
    geom_point(data = data%>%dplyr::filter(keep3==0, keep2==1 ), color = "cyan")+
    #3b/ using global log-linear model
    geom_point(data = data%>%dplyr::filter(KEEP==0, keep3==1 ), color = "blue")
  return(p)
}
```

```{r example-Gro_outplot}
data(weights)
weights = Gro_remoutliers(weights[weights$MeasurementType == "Live weight",], 
                          Taxa = "Reptilia", AgeMat = 10)

p <- Gro_outplot(data = weights, 
                 title = "Species A", ylimit = c(0,2000))
p
```


```{r tests-Gro_outplot}
data = tibble(Age = c(rep(c(1:5),2),4),
              MeasurementValue= c(5,10000,3,6,5,4,100,2,5,3,4),
              AnimalAnonID = c(rep(1:2, each = 5),3),
              MeasurementType = "Live weight")

out= Gro_remoutliers(data, Taxa = "Reptilia", AgeMat = 10,
                     min_Nmeasures = 5, minq = 0.1, IQR = 1.2)

test_that(
  "Gro_outplot",
  {
    expect_error(out$MeasurementValue %>% Gro_outplot(),
                 regexp = "data is not a data frame")
  })

test_that(
  "Gro_outplot",
  { 
    p<- out %>% Gro_outplot()
    expect_named(p$labels,c("title", "x", "y"))
    expect_length(p$layers,5)
  })

```





# Growth model

## Growth analysis
This function fit a serie of growth models to a dataset, select the best one by AIC and estimates the percentiles of the predicted distribution of values. It takes as arguments:

* data_weight including at least the numeric columns *Age*, *MeasurementValue* and *AnimalAnonID* 
* all_mods indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
* percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default = c(2.5,97.5) corresponding to the 95% predicted interval.


```{r function-Gro_analysis}

#' Growth model selection
#' 
#' This function fits a series of growth models to a dataset, select the best one by AIC and estimates the percentiles of the predicted distribution of values.
#' 
#' @param data_weight \code{data.frame} including at least the numeric columns *Age*, *MeasurementValue* and *AnimalAnonID*.
#' @param all_mods \code{vector of character} indicatingthe growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.
#' @param percentiles \code{vector of numeric} indicating the percentiles that need to be estimated. default: 95% predicted interval.
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile qlnorm sd shapiro.test
#' @importFrom bbmle coef
#' @importFrom mgcv gam summary.gam predict.gam
#' @importFrom methods slot
#'
#' @return a list including:
#' * a data frame with the percentile selected
#' * the fit of the best model
#' * the AIC table of the model
#' * GOF: 3 GOF test including the normality of residuals and the test of trend in residuals against X and in the variance of the residuals
#' 
#' @export
Gro_analysis <- function(data_weight, all_mods =c("vonBertalanffy"), percentiles = c(2.5,97.5)
) {
   # Check correct format for inputs ---------------------------------------------
  assert_that(is.numeric(percentiles))
  assert_that(min(percentiles) > 0)
  assert_that(max(percentiles) < 100)
  assert_that(all(all_mods %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy, and polynomial, in addition to GAM.")
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue","Age", 'AnimalAnonID'))
  assert_that(all(data_weight$Age >= 0 ))
  assert_that(all(data_weight$MeasurementValue > 0 ))
  
  data_weight<-data_weight%>%
    mutate(logx = log(Age + 1),
           logz = log(MeasurementValue + 1))
  
  
  #Fitting the different growth models
  all_fits_tab=c()
  all_fits <- list()
  all_mods_g = stringr::str_subset(all_mods, 
                                   pattern = 'gam', 
                                   negate = T)
  
  if(length(all_mods_g)>0){
    all_fits <- lapply( 1:length(all_mods_g),
                        Gro_fitlog,
                        all_mods = all_mods_g,
                        dat = data_weight
    )
    
    for (i in 1:length(all_mods_g)){
      all_fits_tab <- rbind(all_fits_tab,all_fits[[i]]$tab%>%as_tibble)
    }
  }
  
  if('gam' %in% all_mods){
    fit_gam <-   mgcv::gam(logz~s(logx, bs = 'cr', k = 6) + s(AnimalAnonID, bs = 're'),
                           data = data_weight,
                           method = "ML",
                           drop.unused.levels = FALSE # do not drop empty level for prediction
    )
    b = mgcv::summary.gam(fit_gam)
    all_fits_tab <- rbind(all_fits_tab,tibble(index = length(all_mods_g) +1,
                                              model = "gam", 
                                              k =  sum(b$s.table[,2])+1,
                                              LSQ = sum(fit_gam$residuals^2))
    )
    all_fits[[length(all_mods_g) +1]] <- list(fit = fit_gam)
  }
  
  all_fits_tab <- all_fits_tab%>%
    mutate(QAIC = LSQ + 2 * k)%>% arrange(QAIC)
  best_std <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$fit
  
  #Vector for predictions
  zQuant <- tibble(Age = seq(min(data_weight$Age), max(data_weight$Age)+0.1, 0.1))
  
  #Fitted values and residuals
  if( all_fits_tab$model[1] == 'gam'){
    conv = fit_gam$converged
    elogz <- fit_gam$residuals
    lzexp <- predict.gam(fit_gam, newdata = tibble(logx = log(zQuant$Age+1),
                                                   AnimalAnonID = 1), exclude = c("s(AnimalAnonID)"))
  }else{
    growthMod <- all_fits[[as.numeric(all_fits_tab[1, "index"]) ]]$growthMod
    gam <- bbmle::coef(best_std)
    suppressWarnings(gam$logx <- data_weight$logx)
    logzfit <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
    conv = slot(best_std, "details")$convergence == 2
    elogz <- data_weight$logz - logzfit
    gam$logx =  log(zQuant$Age+1)
    lzexp <- do.call(growthMod, as.list(gam[c(1:(length(gam)-2),length(gam))]))
  }
  
  #GOF
  GOF = list(normal = T, X = T, var = T, conv = conv)
  elogz2 <- elogz^2
  if(length(elogz)<5000 & length(elogz)> 2){
  test  = shapiro.test(elogz)
  if(test$p.value<0.01){GOF$normal = FALSE}}
  a = summary(lm(elogz2 ~ data_weight$logx)) #test variance?
  if(a$coefficients[2,4]<0.01) GOF$X = FALSE
  b = summary(lm(elogz ~ data_weight$logx)) #test pour senescence??
  if(b$coefficients[2,4]<0.01) GOF$var = FALSE

  # Quantile calculation:
  sig <- sd(elogz) 
  for (al in 1:length(percentiles)) {
    zQuant[[paste0("percent",percentiles[al])]] <- qlnorm(percentiles[al] / 100, meanlog = lzexp, sdlog = sig) - 1
    zQuant[[paste0("percent",percentiles[al])]] [which( zQuant[[paste0("percent",percentiles[al])]] < 0)] = 0
  }
  if (!(50 %in% percentiles)){
    zQuant[["percent50"]] <- qlnorm(0.5, meanlog = lzexp, sdlog = sig) - 1
    zQuant[["percent50"]] [which( zQuant[["percent50"]] < 0)] = 0
    
  }
  
  all_fits_tab <- all_fits_tab%>% 
    dplyr::select(-index)
  
  return(list(percent = zQuant, 
              fit = best_std,
              AIC_tab =all_fits_tab,
              GOF = GOF)
  )
}
```

```{r example-Gro_analysis}
Age <- sample(c(0:10), 100, replace = TRUE)
AnimalAnonID <- sample(c(0:20), 100, replace = TRUE)
MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ 
                          rnorm(100,0,0.01) + AnimalAnonID*0.1)-1 
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
                 AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")

out = Gro_analysis(dat, 
                   all_mods = c("logistic", "vonBertalanffy", "gam"), 
                   percentiles = c(2.5, 97.5))
```


```{r dev-Gro_analysis}
Age <- sample(c(0:10), 10000, replace = TRUE)
AnimalAnonID <- sample(c(0:20), 10000, replace = TRUE)

id =  rnorm(21,0, 0.1)
MeasurementValue <- exp(0.2 + id[AnimalAnonID+1]+ 15 * (1 - exp(-(0.1) * log(Age+1))))-1 
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
                 AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")


 data<-dat%>%
    mutate(logx = log(Age + 1),
           logz = log(MeasurementValue + 1),
           IND = factor(AnimalAnonID, labels = c(1:length(unique(AnimalAnonID)))))
  
  model = "vonBertalanffy_re"
  modSett <- Gro_ModSettings(data, model)
  out = list()
  suppressWarnings(out$fit <- bbmle::mle2(modSett$growthMod, 
                                          data = data, 
                                          parnames = modSett$namesCoef, 
                                          fixed = list(LL = T),
                                          start = modSett$gamstart,
                                           lower = modSett$low
  ))
out$fit

out = Gro_analysis(dat, 
                   all_mods = c("logistic", "vonBertalanffy", "gam"), 
                   percentiles = c(2.5, 97.5))
```

```{r tests-Gro_analysis}
Age <- sample(c(0:10), 1000, replace = T)
MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ rnorm(1000,0,0.01))-1 
AnimalAnonID <- sample(c(0:20), 100, replace = TRUE)
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
                 AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")

test_that(
  "Gro_analysis error",
  {
    expect_error(dat$MeasurementValue %>% Gro_analysis(),
                 regexp = "data_weight is not a data frame")
    expect_error(dat%>% Gro_analysis(percentiles = c(-0.2)))
  })

test_that(
  "Gro_analysis works",
  { 
    out = dat %>% Gro_analysis()
    expect_named(out,c("percent", "fit", "AIC_tab", "GOF"))
    expect_named(out$GOF,c("normal", "X", "var", "conv"))
    expect_type(as.logical(out$GOF), "logical")
    expect_named(out$percent,c("Age",  "percent2.5",  "percent97.5",  "percent50"))
    expect_type(out$percent$Age, "double")
    expect_type(out$percent$`percent2.5`, "double")
    expect_named(out$AIC_tab,c("model",  "k", "LSQ", "QAIC"))
    expect_type(out$AIC_tab$model, "character")
    expect_type(out$AIC_tab$QAIC, "double")
    expect_type(out$AIC_tab$k, "double")
    expect_s4_class(out$fit, "mle2")
    out = dat %>% Gro_analysis(all_mods = c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam"))
    out = dat %>% Gro_analysis(all_mods = c("gam"))
  })
```


## Fit growth model

This function fits a given growth model to a dataset. It takes as arguments:

* num index of the model to run 
* `data`, a data frame including at least the numeric columns *logx* and *logz* 
* `model` Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial


```{r function-Gro_fitlog}

#' Fit growth model
#' 
#' Fits a growth model to data, return its fit and AIC
#' 
#' @param num \code{numeric} index of the model to run .
#' @param data \code{data.frame} including at least the numeric columns *logx* and *logz* .
#' @param all_mods \code{vector of character} indicating growth models.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.
#' 
#' @import dplyr assertthat
#' @importFrom bbmle mle2 logLik
#'
#' @return The fit and AIC of the model
#' 
#' @export
Gro_fitlog <- function(num = 1, data, all_mods = "vonBertalanffy") {
 # Check correct format for inputs ---------------------------------------------
  assert_that(all(all_mods %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c('logx', 'logz', 'AnimalAnonID'))
  assert_that(is.numeric(data$logx))
  assert_that(is.numeric(data$logz))
  assert_that(is.numeric(num))
  assert_that(num <= length(all_mods))
  
  data <- data %>%
    mutate(IND = factor(AnimalAnonID, labels = c(1:length(unique(AnimalAnonID)))))
  
  model = all_mods[num]
  modSett <- Gro_ModSettings(data, model)
  out = list()
  suppressWarnings(out$fit <- bbmle::mle2(modSett$growthMod, 
                                          data = data, 
                                          parnames = modSett$namesCoef, 
                                          fixed = list(LL = T),
                                          start = modSett$gamstart
                                          # lower = modSett$low
  ))
  out$tab = list(index = num,
                 model = all_mods[num],
                 k =modSett$np, 
                 LSQ= - bbmle::logLik(out$fit)) #voir le nombre de decimal
  out$growthMod = modSett$growthMod
  return(out)
}
```

```{r example-Gro_fitlog}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz,AnimalAnonID = sample(c(0:20), 100, replace = TRUE)
)
out <- Gro_fitlog(num = 1, data = dat, all_mods = "vonBertalanffy")
```


```{r tests-Gro_fitlog}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz,AnimalAnonID = sample(c(0:20), 100, replace = TRUE)
)

test_that(
  "Gro_fitlog error",
  {
    expect_error(
      Gro_fitlog(data = dat, all_mods = "vonBert"),
      regexp = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
    expect_error(
      Gro_fitlog(data = dat$logz), regexp = "data is not a data frame")
    expect_error(
      Gro_fitlog(num = 2, data = dat))
  })


a= Gro_fitlog(data = dat, all_mods = "vonBertalanffy")

test_that(
  "Gro_fitlog works",
  { 
    expect_named(a, c("fit", "tab", 'growthMod'))
    expect_named(a$tab, c("index", "model", "k", "LSQ"))
    expect_equal(a$tab$k, 3)
    expect_match(a$tab$model, "vonBertalanffy")
    expect_type(a$tab$LSQ, "double")
    expect_equal(a$tab$index, 1)
    expect_s4_class(a$fit, "mle2")
  }
)
```

## Growth Model Setting

This function gets the parameter and equations for the growth model and takes as arguments:

* `data`, a data frame including at least the numeric columns *logx* and *logz* 
* `model` Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial


```{r function-Gro_ModSettings}

#' Growth model settings
#' 
#' This function gets the parameter and equations for the growth model
#' 
#' @param data \code{data.frame} including at least the numeric columns *logx* and *logz* .
#' @param model \code{character} Name of the model to fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial .
#' 
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return a list including the function of the growth model,  the number of parameter, their names, their initial values and their lowest possible values
#' 
#' @export
# Set growth model parameters:
Gro_ModSettings <- function(data, model = "vonBertalanffy") {
 # Check correct format for inputs ---------------------------------------------
  assert_that(model %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial"), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
  assert_that(is.data.frame(data))
  assert_that(data %has_name% c('logx', 'logz'))
  assert_that(is.numeric(data$logx))
  assert_that(is.numeric(data$logz))
  logx = data$logx
  logz = data$logz
  # Range of log(x) values:
  logxDiff <- diff(range(logx))
  
  if (model == "logistic") {
    growthMod <- logisGrowth
    np <- 3
    namesCoef <- c("zinf", "gamma", "xInfl")
    lowCoef <- c(0, 0, -Inf)
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- max(logz[idInf])
    
    # X inflection:
    xInfl <- mean(range(logx))
    
    # find starting gamma:
    nGams <- 7
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inrat <- zInf / logzMeans - 1
    idk <- which(inrat > 0)
    inlog <- - log(inrat[idk]) / (logxInts[idk] - xInfl)
    gamma <- mean(inlog)
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, xInfl = xInfl, gamma = gamma)
    
    
    
  } else if (model == "gompertz") {
    growthMod <- gompertzGrowth
    np <- 3
    namesCoef <- c("zinf", "beta", "gamma")
    lowCoef <- c(0, 0, 0)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = -log(abs(z0/zinf))
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- log(abs(log(abs(logzMeans/zinf)) / beta))
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-inlog[idkeep] / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma)
    
  } else if (model == "chapmanRichards") {
    growthMod <- chapmanRichards
    np <- 4
    namesCoef <- c("zinf", "beta", "gamma", "m")
    lowCoef <- c(0, 0, -Inf, -Inf)
    
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zinf <- mean(logz[idInf], na.rm = TRUE) 
    
    #Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    beta = 1-(z0/zinf)
    
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:nGams, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- (logzMeans/zinf - 1)/(-beta)
    idkeep <- which(inlog > 0)
    gamma <- mean(-log(inlog[idkeep]) / (logxInts[idkeep] + dxInts))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zinf, beta = beta, gamma = gamma, m = 0)
    
  } else if (model == "vonBertalanffy") {
    growthMod <- vbGrowth
    np <- 3
    namesCoef <- c("z0", "zinf", "gamma")
    lowCoef <- rep(0, np)
    # Find starting z0 parameter:
    logxLow <- min(logx) + c(0, logxDiff * 0.01)
    id0 <- which(logx >= logxLow[1] & logx < logxLow[2])
    z0 <- mean(logz[id0], na.rm = TRUE)
    
    # Find starting zInf parameter:
    logxUpp <- max(logx) + c(-logxDiff * 0.01, 0)
    idInf <- which(logx >= logxUpp[1] & logx <= logxUpp[2])
    zInf <- mean(logz[idInf], na.rm = TRUE) - z0
    
    if (zInf <= 0) {
      zInf <- z0 + diff(range(logz))
    }
    # find starting gamma:
    nGams <- 5
    logxInts <- seq(min(logx), max(logx), length = nGams + 1)
    dxInts <- logxInts[2] - logxInts[1]
    logzMeans <- sapply(1:5, function(ii) {
      idint <- which(logx >= logxInts[ii] & logx <= logxInts[ii + 1])
      logzmean <- mean(logz[idint])
      return(logzmean)
    })
    inlog <- 1 - (logzMeans - z0) / zInf
    idkeep <- which(inlog > 0)
    gamma <- abs(mean(-log(inlog[idkeep]) / (logxInts[idkeep] + dxInts)))
    if (is.na(gamma) | gamma == Inf | gamma == -Inf) {
      gamma <- 0.5
    }
    # Fill-up gamStart:
    gamStart <- list(zinf = zInf, z0 = z0, gamma = gamma)
    
  
    } else if (model == "polynomial") {
    growthMod <- polyGrowth
    np <- 5
    namesCoef <- sprintf("gam%s", 0:np - 1)
    lowCoef <- rep(-Inf, np)
    gamStart <- list(gam0 = 0, gam1 = 0, gam2 = 0, gam3 = 0, gam4 = 0)
    
  }
  return(list(growthMod = growthMod, np = np, namesCoef = namesCoef,
              low = lowCoef, gamstart = gamStart))
}
```

```{r example-Gro_ModSettings}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)

Gro_ModSettings(data = dat, model = "vonBertalanffy")
```


```{r tests-Gro_ModSettings}
logx <- rnorm(100, 0, 1)
logz <- 0.2+ 15 * (1 - exp(-(1) * logx)) +rnorm(100, 0, 0.01)
dat = data.frame(logx = logx, logz = logz)

test_that(
  "Gro_ModSettings error",
  {
    expect_error(
      dat %>% Gro_ModSettings(model = "vonBert"),
      regexp = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy , and polynomial")
    expect_error(
      dat$logz %>% Gro_ModSettings(),
      regexp = "data is not a data frame")
  })



test_that(
  "Gro_ModSettings works",
  { 
    expect_named(
      dat %>% Gro_ModSettings(model = "vonBertalanffy"),
      c("growthMod", "np", "namesCoef", "low", "gamstart"))
    a=dat %>% Gro_ModSettings(model = "vonBertalanffy")
    expect_equal(a$np, 3)
    expect_type(a$growthMod, "closure")
    expect_type(a$low, "double")
    expect_type(a$namesCoef, "character")
    expect_named(a$gamstart, c("zinf", "z0", "gamma"))
    a=dat %>% Gro_ModSettings(model = "logistic")
    expect_named(a$gamstart, c("zinf", "xInfl", "gamma"))
    a=dat %>% Gro_ModSettings(model = "gompertz")
    expect_named(a$gamstart, c("zinf", "beta", "gamma"))
    a=dat %>% Gro_ModSettings(model = "chapmanRichards")
    expect_named(a$gamstart, c("zinf",  "beta",  "gamma", "m"))
    a=dat %>% Gro_ModSettings(model = "polynomial")
    expect_named(a$gamstart,c("gam0", "gam1", "gam2", "gam3", "gam4"))
  }
)
```


## Plot model prediction

This function makes a plot of the predicted percentiles from a growth model with data points. It takes as arguments:

* data including at least the numeric columns *Age*, *MeasurementValue* and *AnimalAnonID* 
* data_percent including the predicted percentile from the growth model and  the numeric columns *Age*, *percentiles50* and other percentiles to plot.
* title of the plot



```{r function-Gro_plot}

#' Plot predicted growth curve
#' 
#'Plot predicted percentiles from a growth model with data points
#' 
#' @param data \code{data.frame} including at least the numeric columns *Age*, *MeasurementValue* and *AnimalAnonID*.
#' @param data_percent \code{data.frame} including the predicted percentile from the growth model and  the numeric columns *Age*, *percentiles50* and other percentiles to plot.
#' @param title \code{character} Title of the plot.
#' 
#' @import dplyr assertthat 
#' @importFrom ggplot2 ggplot geom_point geom_line ggtitle geom_ribbon aes
#' @importFrom stringr str_subset str_remove
#'
#' @return Plot
#' 
#' @export
Gro_plot <- function(data, data_percent, title = "") {
  assert_that(is.data.frame(data))
  assert_that(is.data.frame(data_percent))
  assert_that(data %has_name% c("MeasurementValue","Age", 'AnimalAnonID'))
  assert_that(data_percent %has_name% c("percent50","Age"))
  
  assert_that(is.numeric(data$MeasurementValue))
  assert_that(is.numeric(data$Age))
  assert_that(is.numeric(data_percent$percent50))
  assert_that(is.numeric(data_percent$Age))
  
  percentiles = str_subset(names(data_percent), "percent")
  percentiles = str_subset(percentiles, "50", negate = T)
  percentiles = as.numeric(str_remove(percentiles, "percent"))
  
  
  p <- ggplot(data, aes (x = Age))+
    ggtitle(title)+
    geom_point(aes(y = MeasurementValue))
  
  if (length(percentiles)/2 == 1){
    colorrib ="grey80"
  }else{
    colorrib = paste0("grey", seq(10,90, length.out = length(percentiles)/2))}
  for (i in 1:(length(percentiles)/2) ){
    per = paste0("percent",abs(c(percentiles[i], 100-percentiles[i])))
    p <- p +
      geom_ribbon(data = data_percent,aes ( ymin = !!sym(per[1]), ymax = !!sym(per[2])),
                  fill = colorrib[i], alpha = 0.25)
  }
  p <- p +
    geom_line(data = data_percent,aes ( y = percent50 ))   
  return(p)
}
```

```{r example-Gro_plot}
Age <- sample(c(0:10), 100, replace = TRUE)
AnimalAnonID <- sample(c(0:20), 100, replace = TRUE)
MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ 
                          rnorm(100,0,0.01) + AnimalAnonID*0.1)-1 
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
                 AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")

out = Gro_analysis(dat, 
                   all_mods = c("logistic", "vonBertalanffy", "gam"), 
                   percentiles = c(2.5, 97.5))

p <- Gro_plot(data = dat, 
              data_percent = out$percent, 
              title =out$AIC_tab$model[1])
p
```


```{r tests-Gro_plot}
Age <- sample(c(0:10), 1000, replace = T)
MeasurementValue <- exp(0.2+15 * (1 - exp(-(0.1) * log(Age+1)))+ rnorm(1000,0,0.01))-1 
AnimalAnonID <- sample(c(0:20), 100, replace = TRUE)
dat = data.frame(Age = Age, MeasurementValue = MeasurementValue, 
                 AnimalAnonID = AnimalAnonID, MeasurementType = "Live Weight")
out = dat %>% Gro_analysis()

test_that(
  "Gro_plot",
  {
    expect_error(dat$MeasurementValue %>% Gro_plot(out$percent),
                 regexp = "data is not a data frame")
    expect_error(dat %>% Gro_plot(out$percent$Age),
                 regexp = "data_percent is not a data frame")
  })

test_that(
  "Gro_plot",
  { 
    p<- dat %>% Gro_plot(out$percent)
    expect_named(p$labels,c("title", "x", "y", "ymin", "ymax"))
    expect_length(p$layers,3)
    out = dat %>% Gro_analysis(percentiles = c(2.5,20,80, 97.5))
    p<- dat %>% Gro_plot(out$percent)
   
  })

```



```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_growth.Rmd", vignette_name = "Growth")
```


