---
title: "flat_growth.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
```


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = F)
```

# Gro_cleanmeasures


This function is used to prepare weight and length dataset. It unify the unity used, select clean measures and add individual age at each measure. This function takes as arguments:

* `data`: the weight or length data from ZIMS
* `coresubse`: the core data of the species from ZIMS
* `CaptiveBirths` Should captive born individuals be included, only? Default =  TRUE
* `InclUnkSex`Should undetermined sexes be included Default =  FALSE
* `mindate` Earlier date to include data ('YYYY-MM-DD')
* `MeasureType` Name of the type of measurements that should be included. Default = NULL, all measurement type are included.
* `type` Either 'weight' or 'length'.

The function returns the data frame including selected measures, plus individual birth date and individual age at each measure


```{r function-Gro_cleanmeasures}
#' Prepare weight and length Dataset
#'
#'Select clean measures, unify the unity used and add individual age at each measure
#'
#' @param data \code{data.frame} including the following columns *MeasurementValue*, *MeasurementDate*, *CollectionScopeType*, *UnitOfMeasure*, *ExcludedFromNorms*, *EstimatedMeasurement*, *RecordType*, *MeasurementType*, *anonID* and *AnonInstitutionID*.
#' @param coresubse \code{data.frame} including at least the following columns *binSpecies*, *Sex*, *anonID* and *Birthdate* (\code{date})
#' @param CaptiveBirths \code{logical} Should captive born individuals be included, only? Default =  TRUE
#' @param InclUnkSex \code{logical} Should undetermined sexes be included Default =  FALSE
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included. Default = NULL, all measurement type are included.
#' @param type \code{character} Either 'weight' or 'length'. Default =  'weight
#' @param corevariable \code{vector character} Name of the core columns that must be added to data
#' @param variablekeep \code{vector character} Name of the data columns that must also be returned
#' 
#' @return The data frame including selected measures, plus individual birth date and individual age at each measure
#' 
#' @import dplyr assertthat
#' 
#' @export
#'
#' @examples
Gro_cleanmeasures <- function(data, coresubse,
                              CaptiveBirths = TRUE, type = "weight", MeasureType = NULL,
                              InclUnkSex = FALSE, mindate = "1980-01-01",
                              corevariable = NULL, variablekeep =NULL) 
{
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(data))
  assert_that(is.data.frame(coresubse))
  assert_that(data %has_name% c("MeasurementValue", "MeasurementValue", "MeasurementDate", "CollectionScopeType", "UnitOfMeasure", "ExcludedFromNorms", "EstimatedMeasurement", "RecordType", "MeasurementType", "anonID", "AnonInstitutionID"))
  assert_that(coresubse %has_name% c("BirthDate", "binSpecies", "Sex", "anonID"))
  assert_that(is.logical(CaptiveBirths))
  assert_that(is.logical(InclUnkSex))
  assert_that(is.date(mindate))
  
 
  if(!is.null(corevariable)) {
    assert_that(is.character(corevariable))
    assert_that(coresubse %has_name% corevariable)}
  if(!is.null(variablekeep)) {
     assert_that(is.character(variablekeep))
    assert_that(data %has_name% variablekeep)}
  
  if(!is.null(MeasureType)){
    if(!all(MeasureType %in% unique(data$MeasurementType))){
      MeasureType_not = which(!(MeasureType %in% unique(data$MeasurementType)))
      warnings(paste0(MeasureType[MeasureType_not]," are not included in the data, check if they are spelled correctly"))
    }
  }
  assertthat::assert_that(type %in% c("weight",'length'))
  
  if(type =="weight"){
    Units <- data.frame(unit = c("kilogram", "gram", 
                                 "micrograms", "milligram", "ounce", 
                                 "pound", "stone", "tonne"), 
                        toKg = c(1,1/1000, 
                                 10^{
                                   -9
                                 }, 10^{
                                   -6
                                 }, 0.0283495, 0.453592, 6.35029, 1000),
                        stringsAsFactors = FALSE)
    
  }
  if(type =="length"){
    Units <- data.frame(unit = c("meter","m", "dm", "cm", "mm", 
                                 "foot", "inch", 
                                 "metre", "centimetre", "millimetre",  "kilometre"), 
                        toKg = c(1,1, 10^{-1}, 10^{-2},10^{-3},
                                 0.3048, 0.0254,
                                 1, 10^{-2},10^{-3},10^{3}),
                        stringsAsFactors = FALSE)
    
  }
  Corevariable = c("binSpecies", "BirthDate", "Sex", "anonID", corevariable) 
  Variablekeep = c(Corevariable,"AnonInstitutionID","MeasurementType", 
                        "MeasurementDate", "Age", "MeasurementValue", "Unit", variablekeep)
 
  coresubse<- coresubse%>%
    rowwise()%>%
    mutate(cond_captivebirth = ifelse(CaptiveBirths,stringr::str_detect(birthType, pattern = "Captive"),1 ),
           cond_sex = ifelse(InclUnkSex, 1, stringr::str_detect(Sex, pattern = "Undet", negate = T) ))%>%
    filter(cond_captivebirth == 1,
           cond_sex == 1)%>%
    dplyr::select(-c(cond_captivebirth, cond_sex))
  
  data <- data%>%
    filter(anonID %in% coresubse$anonID)%>%
    mutate(MeasurementDate = lubridate::as_date(MeasurementDate))%>%
    left_join(coresubse%>%dplyr::select(all_of(Corevariable)), by = "anonID")
  
  if(!is.null(MeasureType)){
    data<- data%>%
      filter(MeasurementType %in% MeasureType)}
  
  if(nrow(data)>0){
    
    datasub<- data%>%
      filter(Sex %in% unique(coresubse$Sex),
             MeasurementDate>= mindate,
             CollectionScopeType == "Global",
             !is.na(MeasurementValue),
             as.character(UnitOfMeasure) %in% Units$unit,
             ExcludedFromNorms == 0 , 
             EstimatedMeasurement == 0 , 
             MeasurementValue > 0,
             RecordType == "Husbandry"
      )
    
    
    
    if (nrow(datasub) > 0) {
      datasub <- datasub%>%
        mutate(Age = as.numeric((MeasurementDate - BirthDate)/365.25))%>%
        filter(Age >= 0)%>%
        left_join(Units, by =c("UnitOfMeasure"= "unit"))%>%
        mutate(MeasurementValue = MeasurementValue * toKg,
               Unit = Units$unit[1])%>%
        dplyr::select(all_of(Variablekeep))
      output <-datasub
    }else{output <- "There is no data selected"}
    
  }else{output <- "There is no data selected"}
  return(output)
}
```


```{r examples-Gro_cleanmeasures}
data(raw_weights)
data(core)

data_weights= Gro_cleanmeasures(raw_weights, core,
                                CaptiveBirths = TRUE,
                                MeasureType = 'Live weight',
                                InclUnkSex = FALSE, 
                                mindate = "1980-01-01")
```



```{r tests-Gro_cleanmeasures}
data(raw_weights)
data(core)

test_that("Gro_cleanmeasures works", {
  d=Gro_cleanmeasures(raw_weights, core)
  expect_named(
    d,
    c("binSpecies", "BirthDate", "Sex", "anonID", "AnonInstitutionID", "MeasurementType", "MeasurementDate", "Age", "MeasurementValue", "Unit"))
  expect_true(unique(d$Unit) == "kilogram")
})
```



# gro_remoutliers

This function removes the outliers from a dataset of weights. This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`.
* `taxa` the name of the taxa studied
* `ageMat` the MINIMUM age at sexual maturity. The function takes as threshold 1.2*ageMat to differentiate juveniles (still growing) from adults
* `maxweight`
* `variableid` name of the column including individual IDs. Defaut = "anonID". It must also be a column of `data_weight`
* `minq` Sensitivity of the function to remove outliers using percentiles, between 0 and 1. Default =  0.025
* `IQR` influences the sensitivity of the function to remove outliers using generalized additive model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year . Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year . Default =  2.5 (250%)

This function follow 4 different steps to highlight outliers:
1/ It removes the measures higher than the argument `maxweight` (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).  In the default case, default values are in kilograms and are set at 7000kg for Mammalia, 200kg for Aves, 1500kg for Reptilia, 100kg for Amphibia, 1000kg for Chondrichthyes and 500kg for Actinopterygii.
2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles. You can choose the number of individuals included in each interval of the sliding window using the argument `Ninterval_juv`.
3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least `min_Nmeasures` measures and remove outliers based on the residuals of the models.
4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.

The function returns:

* The data frame including the column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3.



```{r function-Gro_remoutliers}

#' Remove outliers from weigth or length data
#'
#'Takes a data frame including weight measures and Age and look for possible outliers
#'
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric})
#' @param taxa  \code{character} the name of the taxa studied
#' @param ageMat \code{numeric} the age at sexual maturity to differentiate juveniles (still growing) from adults
#' @param maxweight \code{numeric} the maximum weight allowed for the dataset
#' @param variableid \code{character} name of the variable including individual ids. Defaut = "anonID". It must also be a column of data_weight.Default = 6. It must be at least 5
#' @param min_Nmeasures \code{integer} Minimum number of measures for an individual to check outliers along its growth trajectory. Default = 7. It must be at least 5
#' @param minq \code{numeric} Sensitivity of the function to remove outliers using percentiles, between 0 and 1. Default =  0.025
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers using log-linear model of growth. It should be above 1 Default =  2.75. A higher number makes the function less sensitive to find outliers.
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year . Default =  0.2 (20%)
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year . Default =  2.5 (250%)
#' @param Ninterval_juv \code{integer} Minimum number of juveniles used to make one interval of the sliding windows. Default = 500
#' 
#' @return The data frame including the additional column `KEEP` a numeric vector of 1 and 0 indicating the measures to keep. The 0 signal outliers. Other additional columns keep1, keep2, keep3 indicates the individuals highlighted as outliers (0) in steps 1 to 3.
#' 
#' @details
#'This function follow 4 different steps to highlight outliers:
#'1/ It removes the measures higher than \code{maxweight} (Instead of using the OrdMag Fernando that was removing only very extreme values, a maximum value was set for each taxa).
#'2/ Independently on adults and juveniles, it uses the function Gro_Rout_quan() to removes outliers based on percentiles on adults and juveniles. It uses sliding windows of age for juveniles.
#'3/  Independently on adults and juveniles, it uses the function Gro_lin_ind() to build generalized additive models for each individual trajectories with at least 7 measures and remove outliers based on the residuals of the models.
#'4/  It uses the function Gro_lin_ind() to build a common generalized additive model for all growth trajectories and remove outliers based on the residuals of the models.
#' 
#' @import dplyr assertthat
#' @importFrom stats lm predict.lm
#' 
#' @export
#'
#' @examples
Gro_remoutliers <- function(data_weight, taxa, ageMat = 0, maxweight = NULL, 
                            variableid = "anonID", min_Nmeasures = 7,
                            perc_weight_min=0.2, perc_weight_max=2.5,
                            IQR=2.75, minq=0.025, Ninterval_juv = 500) {
  
  assert_that(is.data.frame(data_weight))
  assert_that(data_weight %has_name% c("MeasurementValue", "Age"))
  assert_that(taxa %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
                          "Chondrichthyes", "Actinopterygii"),
              msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  assert_that(is.numeric(ageMat))
  if(is.null(maxweight)){
    if(taxa == "Mammalia")       maxweight = 7000
    if(taxa == "Aves")           maxweight = 200
    if(taxa == "Reptilia")       maxweight = 1500
    if(taxa == "Amphibia")       maxweight = 100
    if(taxa == "Chondrichthyes") maxweight = 1000
    if(taxa == "Actinopterygii") maxweight = 500
  }
  assert_that(is.numeric(maxweight))
  assert_that(min_Nmeasures%%1==0, msg = "min_Nmeasures should be an integer")
  assert_that(min_Nmeasures>=5)
  assert_that(Ninterval_juv%%1==0, msg = "Ninterval_juv should be an integer")
  assert_that(Ninterval_juv>=5)
  assert_that(all(data_weight$MeasurementValue>0))
  assert_that(all(data_weight$Age>=0))
  
  
  #1) Removes very large weights using maxweight ----
  data_weight <- data_weight%>%
    mutate(keep1 = ifelse(MeasurementValue< maxweight, 1, 0))
  
  #2) Separate Juveniles and adults 
  ### JUVENILES ----
  juv <- data_weight%>%
    filter(Age >= 0, Age < ageMat*1.2)
  if (nrow(juv) > 0) {
    
    ##a/Uses sliding windows to check outliers based on percentile of the distribution 
    #Make maximum intervals of at least Ninterval_juv individuals for sliding windows
    nInts = round(nrow(juv[juv$keep1==1,])/ Ninterval_juv)
    windInts <- seq(0, ageMat, length = nInts+1)
    numInt <- table(findInterval(juv$Age[juv$keep1==1], windInts))
    nWindInts <- 0
    ii <- 1
    while (ii < nInts) {
      cumInt <- cumsum(numInt[ii:nInts])
      idnum <- which(cumInt >= Ninterval_juv) + ii
      if (length(idnum) > 0) {
        nWindInts <- c(nWindInts, windInts[idnum[1]])
        ii <- idnum[1]
      } else {
        nWindInts <- c(nWindInts, windInts[nInts+1])
        ii <- nInts
      }
    }
    if (!ageMat %in% nWindInts)  nWindInts <- c(nWindInts, ageMat)
    nInts <- length(nWindInts) - 1
    juv$keep2 = juv$keep1
    for (iints in 1:nInts) {
      idwind <- which(juv$Age >= nWindInts[iints] & 
                        juv$Age <= nWindInts[iints + 1] & 
                        juv$keep1 == 1)
      juv$keep2[idwind] = Gro_Rout_quan(z = juv$MeasurementValue[idwind],  
                                        minq = minq)
    }
    
    ##b/Uses individual trajectories to find outliers for juveniles with at least 7 measures
    juv <-juv %>%
      group_by(anonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    juv$keep3 = juv$keep2
    if(any(juv$nb >= min_Nmeasures & juv$la>=4)){
      juv_temp  <- Gro_lin_ind(juv%>%filter(keep2 == 1, nb >= min_Nmeasures, la >= 4), 
                               perc_weight_min = perc_weight_min,
                               perc_weight_max = perc_weight_max,
                               IQR = IQR,
                               remove_ext = F, traj_ind = T
      )
      
      juv$keep3[juv$keep2==1 & juv$nb >= min_Nmeasures & juv$la >=4] = juv_temp$Keep2 
    }
  }
  
  ### ADULTS ----
  ad <- data_weight%>%
    filter(Age >=  ageMat*1.2)
  if (nrow(ad) > 0) {
    
    ##a/Check outliers based on percentile of the distribution 
    ad$keep2=ad$keep1
    ad$keep2[ad$keep1 == 1] = Gro_Rout_quan(z = ad$MeasurementValue[ad$keep1 == 1],  
                                            minq = minq)
    
    ##b/Uses individual trajectories to find outliers for adults with at least 7 measures
    ad <-ad %>%
      group_by(anonID,keep2)%>%
      mutate(nb =  sum(keep2),
             la = length(unique(Age)))%>%
      dplyr::ungroup()
    ad$keep3 = ad$keep2
    if(any(ad$nb >= min_Nmeasures & ad$la>=4)){
      
      ad_temp <- Gro_lin_ind(ad%>%filter(keep2==1, nb >= min_Nmeasures, la >= 4), 
                             perc_weight_min = perc_weight_min,
                             perc_weight_max = perc_weight_max,
                             IQR = IQR,
                             remove_ext = F, traj_ind = T
      )
      ad$keep3[ad$keep2==1 & ad$nb >= min_Nmeasures & ad$la >=4] = ad_temp$Keep2 
    }
  }
  
  data_weight1 =rbind(juv,ad)%>%dplyr::select(-nb,-la)
  #3) Uses global GAM model to detect remaining outliers ----
  data_weight1$KEEP= data_weight1$keep3
  if(sum(data_weight1$KEEP)>4){
    if(length(unique(data_weight1$Age[data_weight1$KEEP==1]))>=4){
      data_weight1_temp <- Gro_lin_ind(data_weight1%>%filter(keep3==1), 
                                       perc_weight_min = perc_weight_min,
                                       perc_weight_max = perc_weight_max,
                                       IQR = IQR,
                                       remove_ext = F, traj_ind = F
      )
      data_weight1$KEEP [data_weight1$keep3 == 1] = data_weight1_temp$Keep2
    }
  }
  return(data_weight1)
  
}
```


```{r examples-Gro_remoutliers}
data(weights)
weights = Gro_remoutliers(weights, taxa = "Mammalia", ageMat = 10)

plot(MeasurementValue ~Age, data = weights)
#Show the four steps used to remove outliers
#1/ using maximum value
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep1==0),
       col = "red", pch = 16) 
#2/ using Inter quartile range
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep2==0, keep1==1 ),
       col = "green", pch = 16) 
#3a/ using individual trajectories
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(keep3==0, keep2==1),
       col = "cyan", pch = 16) 
#3b/ using global log-linear model
points(MeasurementValue ~Age, data = weights%>%dplyr::filter(KEEP==0, keep3==1),
       col = "blue", pch = 16) 

#Checking outliers highlighted in Individual trajectories
anon = unique(weights$anonID[weights$keep3==0 & weights$keep2==1 ])
plot(MeasurementValue ~Age, data = weights%>%
       dplyr::filter(keep2==1, anonID == anon))
points(MeasurementValue ~Age, data = weights%>%
         dplyr::filter(keep3==0, anonID == anon, keep2==1),
       col = "cyan", pch = 16)
```


```{r development_examples-Gro_remoutliers}
plot(MeasurementValue ~Age, data = weights, ylim = c(0,400), xlim = c(0,50))
#Show the four steps used to remove outliers
#1/ using maximum value
points(MeasurementValue ~Age, data = weights%>%filter(keep1==0),
       col = "red", pch = 16) 
#2/ using Inter quartile range
points(MeasurementValue ~Age, data = weights%>%filter(keep2==0, keep1==1 ),
       col = "green", pch = 16) 
#3a/ using individual trajectories
points(MeasurementValue ~Age, data = weights%>%filter(keep3==0, keep2==1), 
       col = "cyan", pch = 16) 
#3b/ using global log-linear model
points(MeasurementValue ~Age, data = weights%>%filter(KEEP==0, keep3==1), 
       col = "blue", pch = 16) 

#Individual trajectories
i=0
anon = unique(weights$anonID[weights$keep3==0 & weights$keep2==1 ])
i=i+1
plot(MeasurementValue ~Age, data = weights%>%
       filter(keep2==1, anonID == anon[i]))
points(MeasurementValue ~Age, data = weights%>%
         filter(keep3==0, anonID == anon[i], keep2==1),
       col = "cyan", pch = 16)

#Other tests
data(weights_lion)
weights = Gro_remoutliers(weights_lion, taxa = "Mammalia", ageMat =2, IQR = 2.75, minq=0.025)
data(weights_bison)
weights = Gro_remoutliers(weights_bison, taxa = "Mammalia", ageMat =10, IQR = 2.75, minq=0.025)
data(weights_meerkat)
weights = Gro_remoutliers(weights_meerkat, taxa = "Mammalia", ageMat =1, IQR = 2.75, minq=0.025)
data(weights_gorilla)
weights = Gro_remoutliers(weights_gorilla, taxa = "Mammalia", ageMat =12, IQR = 2.75, minq=0.025)
```



```{r tests-Gro_remoutliers}

test_that("Gro_remoutliers errors", {
  expect_error(Gro_remoutliers(tibble(age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10),
               msg = "data_weight does not have all of these name(s): 'MeasurementValue', 'Age'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "mammalia", ageMat = 10),
               msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
                          'Chondrichthyes', or 'Actinopterygii'")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10, min_Nmeasures = 3.3),
               msg = "min_Nmeasures should be an integer")
  expect_error(Gro_remoutliers(tibble(Age = 2,MeasurementValue=5), taxa = "Mammalia", ageMat = 10, min_Nmeasures = 3),
               msg = "min_Nmeasures not greater than or equal to 5")
})


test_that("Gro_remoutliers works", {
  data = tibble(Age = c(rep(c(1:5),2),4),
                MeasurementValue= c(5,10000,3,6,5,4,100,2,5,3,4),
                anonID = c(rep(1:2, each = 5),3))
  
  a= Gro_remoutliers(data, taxa = "Mammalia", ageMat = 10,
                     min_Nmeasures = 5, minq = 0.1, IQR = 1.2)
  expect_true(sum(a$keep1) == 10)
  expect_true(sum(a$keep2) == 9)
  expect_true(sum(a$keep3) == 9)
  expect_true(sum(a$KEEP) == 9)
})
```


## Remove outliers from percentiles

This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.

The measurement values must be positive

```{r function-Gro_Rout_quan}
#' Remove outliers from percentiles
#'
#' @param z  \code{numeric vector} Measurement values
#' @param minq \code{numeric} Sensitivity of the function to remove outliers, between 0 and 1. Default =  0.05
#'
#' @return
#' Vector of 0 and 1 indicating the measurement values to keep (=1) vs. the outliers (=0).
#' 
#' @importFrom stats quantile
#' 
#' @export
#' 
#' @details
#' This functions removes all values lower and higher than the median value multiplied by how many times the (100-q)th percentile is higher than the qth percentile of the distribution of weights.
#'
#' @examples
Gro_Rout_quan <- function (z, minq = 0.05) 
{
  
  assert_that(is.numeric(z))
  assert_that(is.numeric(minq))
  assert_that(minq < 1, msg = "minq must be a proportion between 0 and 1")
  assert_that(minq > 0, msg = "minq must be a proportion between 0 and 1")
  
  qzn <- quantile(z, c(minq, 1-minq))
  qzrat <- qzn[2]/qzn[1]
  qzlu <- c(quantile(z, 0.5)/qzrat, quantile(z, 0.5) * qzrat)
  idkeep <- which(z > qzlu[1] & z < qzlu[2])
  indKeep = rep(0,length(z))
  indKeep[idkeep] <- 1
  return(indKeep)
}
```

```{r examples-Gro_Rout_quan}
z = c(rnorm(100,5,1), runif(3,40,100))
Gro_Rout_quan (z, minq = 0.05)
```

```{r tests-Gro_Rout_quan}
z1 = c(rnorm(95,4,1), runif(5,100,1000))

test_that("Gro_Rout_quan error", {
  expect_error(Gro_Rout_quan("text"))
  expect_error(Gro_Rout_quan(z1, minq = 1) , regexp = "minq must be a proportion between 0 and 1")
})

test_that("Gro_Rout_quan works", {
  expect_true(sum(Gro_Rout_quan(z1, minq = 0.05)) == 95)
})
```


## Linearize individual trajectories

This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`and `anonID`
* `perc_weight_min`  Minimum percentage of weight that an individual can naturally lose or gain during a year. Default =  0.2 (20%)
* `perc_weight_max`  Maximum percentage of weight that an individual can naturally lose or gain during a year. Default =  2.5 (250%). This value is used only after 1 year old 
* `IQR` influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
* `remove_ext` Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers. Default =  TRUE
*  `traj_ind` Do you want to build a model at the level of the individual trajectory  Default =  TRUE. If yes, each individual trajectory must have at least 5 measures. 

The function uses build generalized additive model of the measurement value in relation to age. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. `perc_weight_min` and `perc_weight_max` limit the values that must be considered as outliers.

```{r function-Gro_lin_ind}
#' Flag outliers in individual trajectories
#' 
#' This function flag 
#' 
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric}) and *anonID*
#' @param perc_weight_min  \code{numeric} Minimum percentage of weight that an individual can naturally lose or gain during a year. Default =  0.2 (20%)
#' @param perc_weight_max  \code{numeric} Maximum percentage of weight that an individual can naturally lose or gain during a year. Default =  2.5 (250%). This value is used only after 1 year old 
#' @param IQR \code{numeric} influences the sensitivity of the function to remove outliers. It should be above 1 Default =  1.5. A higher number makes the function less sensitive to find outliers.
#' @param remove_ext \code{logical} Do you want to keep the two first and two last observations of individual trajectories? These points may often be highlighted as false outliers. Default =  TRUE
#' @param traj_ind \code{logical} Do you want to build linear model at the level of the individual trajectory  Default =  TRUE. If yes, each individual trajectory must have at least 5 measures. 
#' 
#' @details
#' The function uses a log-linear model of the measurement value in relation to a quadratic effect of age for each individual trajectories. It flags as outliers all measures for which the residuals from the linear model are above  IQR * the inter quantile interval (quantile(0.9) - quantile(0.1)) of the residuals. \code{perc_weight_min} and \code{perc_weight_max} limit the values that must be considered as outliers.
#'The \code{remove_ext} argument prevents the function from removing the 2 last and 2 first value observations in relation to age as these values may often be farther from the prediction line.
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return data frame; the data set including an additional column *Keep2* of 0 (potential outliers) and 1
#' 
#' @export
Gro_lin_ind <- function(data_weight, 
                        perc_weight_min = 0.2,
                        perc_weight_max = 2.5,
                        IQR = 1.5,
                        remove_ext = T,
                        traj_ind = T
) {
  
  assert_that(is.numeric(perc_weight_min ))
  assert_that(perc_weight_min  >0 )
  assert_that(perc_weight_min  <1)
  assert_that(is.numeric(perc_weight_max ))
  assert_that(perc_weight_max  >1 )
  assert_that(is.numeric(IQR))
  assert_that(IQR  > 1, msg = 'IQR should be higher than 1 to avoid removing real data')
  assert_that(is.logical(remove_ext))
  assert_that(is.logical(traj_ind))
  assert_that(data_weight %has_name% c("MeasurementValue","Age", "anonID"))
  
  
  data_weight<-data_weight%>%
    dplyr::mutate(pop = 1)%>%
    dplyr::group_by(pop)
  
  assert_that(nrow(data_weight)  > 4, msg = 'There should be at least 5 measures')
  assert_that(min(length(unique(data_weight$Age)))  >= 4, msg = 'Measures must have been taken at 4 different unique ages, at least')
  
  
  #only for individual trajectory 
  if(traj_ind==T){
     da_weight<-data_weight%>%
      summarize(nb= n(),
                la = length(unique(Age)))
    assert_that(min(da_weight$nb)  > 4, msg = 'Each individual trajectory must have at least 5 measures')
    assert_that(min(da_weight$la)  >= 4, msg = 'Each individual trajectory must have measures at 4 different unique ages, at least')
  }
  data_weight$pred2 = perc_weight_max
  data_weight$pred2[data_weight$Age<1] = 1000
  data_weight<-data_weight%>%
    mutate(pred = stats::predict(mgcv::gam(MeasurementValue ~ s(Age, bs = "cr", k=3), data = cur_group())),
           res = abs(MeasurementValue - pred),
           pred1 = abs(perc_weight_min*pred),
           pred2 = abs(pred*pred2),
           lwr = abs(IQR*(quantile(res,0.90)-quantile(res,0.10))),
           ager = rank(Age),
           #Prevent from removing 2 first and 2lasts obs as they will tend to be removed
           age0 = ager < min(ager)+2,
           agem = ager > max(ager)-2)%>%
    dplyr::ungroup()%>% 
    rowwise%>%
    mutate(
      Keep2 = res < min(max(lwr,pred1),pred2))
  if( !(remove_ext))   data_weight$Keep2[data_weight$age0 | data_weight$agem]=1
  data_weight<-data_weight%>%
    dplyr::select(- pred1, -lwr, -res, -age0, -agem, -pred, -ager,
                  -pop, -pred2)
  
  return(data_weight)
}
```

```{r example-Gro_lin_ind}
data(weights)

#We use only trajectories for which the number of individual datapoints is > 6
weights <- weights%>%
  dplyr::group_by(anonID)%>%
  dplyr::mutate(nb= dplyr::n())%>%
  dplyr::ungroup()%>%
  dplyr::filter(nb >6)

weights_ind <- weights%>%Gro_lin_ind(traj_ind = TRUE)
as.numeric(weights_ind$Keep2)

weights_pop <- weights%>%Gro_lin_ind(traj_ind = FALSE)
```


```{r tests-Gro_lin_ind}
data <- tibble(anonID = rep(c(1,2), c(10,15)),
               Age = c(c(1:10), c(1:15)),
               MeasurementValue = 2+3*Age)
data$MeasurementValue[1] = 0.5
data$MeasurementValue[3] = data$MeasurementValue[3]+50
data$MeasurementValue[14] = data$MeasurementValue[3]+30
data$MeasurementValue[20] = data$MeasurementValue[3]+100

test_that(
  "Gro_lin_ind error",
  {
     expect_error(
      data %>% Gro_lin_ind(IQR =0.5),
      regexp = "IQR should be higher than 1 to avoid removing real data")
    expect_error(
      data[1:4,] %>% Gro_lin_ind(),
      regexp = "There should be at least 5 measures")
  })



test_that(
  "Gro_lin_ind Tested ",
  { 
    expect_named(
      data %>% Gro_lin_ind(),
      c("anonID", "Age", "MeasurementValue", "Keep2"))
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5, remove_ext = F, traj_ind = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(remove_ext = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5)%>%pull(Keep2)),
      25-3)
  }
)
```

# Growth model

This function takes as arguments:

* `data_weight` a data frame that must include at least the columns `MeasurementValue` and `Age`.
* `variable_id` name of the variable including individual ids. Defaut = "anonID". It must also be a column of  `data_weight`


```{r function-Gro_analysis}

#' Flag outliers in individual trajectories
#' 
#' This function flag 
#' 
#' @param data_weight \code{data.frame} including at least the following columns : *MeasurementValue* (\code{numeric}), *Age*  (\code{numeric})
#' @param variable_id \code{character} name of the variable including individual ids. Defaut = "anonID". It must also be a column of data_weight

#' 
#' @details
#' 
#' @import dplyr assertthat
#' @importFrom stats quantile
#'
#' @return data frame; the data set including an additional column *Keep2* of 0 (potential outliers) and 1
#' 
#' @export
Gro_analysis <- function(data_weight, 
                         variable_id = "anonID"
                         
) {
  
  assert_that(is.numeric(perc_weight_min ))
  assert_that(perc_weight_min  >0 )
  assert_that(perc_weight_min  <1)
  assert_that(is.numeric(perc_weight_max ))
  assert_that(perc_weight_max  >1 )
  assert_that(is.numeric(IQR))
  assert_that(IQR  > 1, msg = 'IQR should be higher than 1 to avoid removing real data')
  assert_that(is.logical(remove_ext))
  assert_that(is.logical(traj_ind))
  assert_that(data_weight %has_name% c("MeasurementValue","Age"))
  
  
  return(data_weight)
}
```

```{r example-Gro_analysis}
data(weights)

```


```{r tests-Gro_analysis}
data <- tibble(anonID = rep(c(1,2), c(10,15)),
               Age = c(c(1:10), c(1:15)),
               MeasurementValue = 2+3*Age)
data$MeasurementValue[1] = 0.5
data$MeasurementValue[3] = data$MeasurementValue[3]+50
data$MeasurementValue[14] = data$MeasurementValue[3]+30
data$MeasurementValue[20] = data$MeasurementValue[3]+100

test_that(
  "Gro_lin_ind error",
  {
    expect_error(
      data %>% Gro_lin_ind(IQR =0.5),
      regexp = "IQR should be higher than 1 to avoid removing real data")
    expect_error(
      data[1:4,] %>% Gro_lin_ind(),
      regexp = "There should be at least 5 measures")
  })



test_that(
  "Gro_lin_ind Tested ",
  { 
    expect_named(
      data %>% Gro_lin_ind(),
      c("anonID", "Age", "MeasurementValue", "Keep2"))
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5, remove_ext = F, traj_ind = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(remove_ext = F)%>%pull(Keep2)),
      25-3)
    expect_equal(
      sum(data %>% Gro_lin_ind(IQR= 1.5)%>%pull(Keep2)),
      25-3)
  }
)
```





```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_growth.Rmd", vignette_name = "Growth")
```


