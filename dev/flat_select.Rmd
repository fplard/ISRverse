---
title: "Data Selection"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```



# Create the Species profile report

`tx_report()` runs the survival, reproduction and growth analyses for the selected species. It uses the following main arguments:

* `Taxa` Name of the taxa studied
* `Species` Name of the species studied
*  Data for each analysis: at least `Animal` and `Collection`, in addition to `Weights`, `Parents`, `Contraceptions` if needed.   
* `PlotDir`: Directory to save the plots of the selected models
* `repout` Previous result of the report for this Species if it needs to be updated
* `SexCats` Sex categories: Male, Female or All 
* `MinN` Minimum number of individuals needed to run the analyses
* `MinDate` Earliest date to include data records
* `BirthType` Captive, Wild, or All
* `ModelsSur`  Names of the survival basta models to run: "G0", "EX", "LO" and/or "WE"
* `Shape` Shape of the survival basta model to run: "simple", "Makeham", "bathtub"
* `ModelsGro` Names of the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.
* `RepSect` Names of the reproductive analyses to run: "agemat", "litter" and/or ...


```{r function-tx_report}
#' Taxon profile report
#' 
#' Run the survival, reproduction and growth analysis for the selected species
#'
#' @param Taxa  \code{character} name of the taxa studied
#' @param Species \code{character} name of the species studied
#' @param Animal \code{data.frame} core data
#' @param Collection  \code{data.frame} Collection data
#' @param PlotDir \code{character} Directory to save the plots. Default: no plot is saved
#' @param DeathInformation \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param Weights \code{data.frame} Weights data if the growth analysis is run
#' @param Parents \code{data.frame} Parents data if the reproduction analysis is run
#' @param Contraceptions \code{data.frame} Contraception data if the reproduction analysis is run
#' @param Move \code{data frame} Move data including at least the following columns: *AnimalAnonID*, *To*, *Date*
#' @param repout \code{list} Previous result of the taxon profile for this species if it needs to be updated only
#' @param Sections \code{vector of character} names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro".
#' @param SexCats \code{character} Male, Female or All.
#' @param MinN \code{numeric} Minimum number of individuals needed to run the analyses.
#' @param MinDate \code{character 'YYYY-MM-DD'} Earliest date to include data
#' @param ExtractDate \code{character 'YYYY-MM-DD'} Date of data extraction
#' @param MinBirthDate  \code{character}: Earliest possible date: date used when minimum birth date unknown
#' @param BirthType \code{character} Captive, Wild, or All.
#' @param Global \code{logical} Whether only individuals belonging to global Collections should be used.
#' @param MinInstitution  \code{numeric} Minimum number of institutions that should hold records to run the analyses.
#' @param MinAge \code{numeric} Ages at which the survival analysis should start, in years.  see ?basta for more information.
#' @param MaxAge \code{numeric} Maximum possible age in years. Only used for model predictions. This argument is not used to select data.
#' @param UncertBirth \code{numeric}: Maximum uncertainty accepted for birth dates, in days
#' @param UncertDeath \code{numeric}: Maximum uncertainty accepted for death dates, in days.
#' @param UncertDate \code{numeric}: Maximum uncertainty accepted for measurement dates: weight, in days.
#' @param MinNSur \code{numeric} Minimum number of individual records needed to run the survival analysis.
#' @param MaxNSur \code{numeric} Maximum number of individual records to run the survival analysis.
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data to run the survival analysis.
#' @param MinLx  \code{numeric} Value used for longevity threshold and for checks. between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis. This number avoids running survival analysis if there are too few dead individuals in the data. Lower is better.
#' @param MinMLE \code{numeric} Value used for checks. Minimum survivorship allowed at mean life expectancy. Between 0 and 1.
#' @param MaxLE \code{numeric} Value used for checks. Maximum remaining life expectancy at last observed age. In years.
#' @param MaxOutl \code{numeric} Start threshold to select individuals based on the longevity distribution: 100%, 99.9, 99 or 95%. This number must decrease when many errors are expected in longevity data.
#' @param ModelsSur \code{vector of characters} Names of the survival basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information.
#' @param Shape \code{character} Shape of the survival basta model to run: "simple", "Makeham", "bathtub".  see ?basta for more information.
#' @param LastDead  \code{logical} Whether the longest lived individuals should be considered dead.
#' @param niter  \code{numeric}. number of MCMC iterations to run the survival model. see ?basta for more information.
#' @param burnin  \code{numeric} Number of iterations removed so that the survival model has time to converge. see ?basta for more information.
#' @param thinning  \code{numeric} Number of iterations to run the survival model before saving a set of parameters. see ?basta for more information.
#' @param nchain  \code{numeric} Number of chains to run the survival model.
#' @param ncpus  \code{numeric} Number of computer cores to use.
#' @param RepSect \code{character} Names of the reproductive analyses to run: "agemat", "litter" and/or ...
#' @param NDay \code{numeric} Number of consecutive days over which the birth dates of a litter/clutch can be spread.
#' @param ParentPercDam \code{numeric} Minimum percentage of parentage probability to include Dam.
#' @param ParentPercSire \code{numeric} Minimum percentage of parentage probability to include Sire.
#' @param MinNLitter \code{numeric} Minimum number of litters to run the analysis. The data frame for litter size will be produced in all cases.
#' @param MinNRepro \code{numeric} Minimum number of birth records needed to run reproductive analyses.
#' @param MinNPaRepro \code{numeric} Minimum number of unique parent records needed to run reproductive analyses.
#' @param MinNSeas \code{numeric} XXXXXXXXXXX
#' @param MinNGro \code{numeric} Minimum number of weights needed to fit the growth models.
#' @param MinNIGro \code{numeric} Minimum number of unique individuals needed to fit the growth models.
#' @param MeasureType \code{vector of characters} Name of the types of measurement that should be included.  Default =  all measurement type are included.
#' @param ModelsGro \code{vector of characters} Names of the growth models that need to be fit. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.
#' 
#' @return a list including the results and summary of each analysis. See each function ?Sur_main, ?Rep_main and ?Gro_main for more details about survival, reproduction and growth analyses, respectively.
#' @export
#' 
#' @importFrom grDevices rgb
#' @importFrom graphics polygon
#'
#' @examples
tx_report <- function(Species, Taxa,  Animal, Collection, PlotDir = NULL,
                      Weights = NULL,Parents = NULL, Move= NULL, 
                      Contraceptions = NULL, DeathInformation = NULL,
                      repout = list(), Sections = c('sur', 'rep', 'gro'),
                      SexCats = c("Male", "Female"), MinN = 50, MinDate= "1980-01-01",
                      Global = TRUE, MinBirthDate = "1900-01-01",
                      ExtractDate = NULL, UncertBirth = 365,  UncertDeath = 365,  UncertDate = 365, 
                      MinNSur = 50, MaxNSur = NULL, MinInstitution  = 2, 
                      MinLx = 0.1, MinBirthKnown = 0.3, MaxOutl = 100, MaxAge =120,
                      MinMLE = 0.1, MaxLE = 2, 
                      ModelsSur = "GO", Shape = "bathtub",
                      niter = 25000, burnin = 5001, thinning = 20, nchain = 3, 
                      ncpus = 2, MinAge = 0, LastDead = FALSE,
                      RepSect = c('agemat', 'litter'),
                      BirthType = "Captive", 
                      ParentPercDam = 80,  ParentPercSire = 80, MinNLitter = 20,NDay = 7,
                      MinNRepro = 100, MinNPaRepro = 30, MinNSeas = 50, 
                      MinNGro =100, MinNIGro = 50, MeasureType = "Live weight",
                      ModelsGro = "vonBertalanffy"
) {
  
  # Check correct format for inputs -----------------------------------------------------------------------
  assert_that(is.character(Taxa))
  assert_that(is.character(Sections))
  assert_that(all(Sections %in% c("sur", "gro", "rep")))
  assert_that(is.character(Species))
  assert_that(is.logical(Global))
  assert_that(BirthType %in% c("Captive", "Wild", "All"))
  assert_that(is.character(SexCats))
  assert_that(all(SexCats %in% c("Male", "Female", "All")))
  
  assert_that(is.data.frame(Animal))
  assert_that(is.data.frame(Collection))
  assert_that(Animal  %has_name% c("AnimalAnonID", "binSpecies", "BirthDate", "DepartDate",
                                   "EntryDate", "MaxBirthDate", "MinBirthDate",
                                   "MaxDeathDate", "MinDeathDate", "EntryType", "DepartType",
                                   "LastTXDate", "DeathDate", "FirstHoldingInstitution", 
                                   "LastHoldingInstitution","GlobalStatus",
                                   "LastCollectionScopeType","FirstCollectionScopeType"))
  assert_that(Collection  %has_name% c("RecordingInstitution", "ChangeDate", 
                                       "ScopeType", "AnimalAnonID"))
  if(!is.null(ExtractDate)){
    ExtractDate = lubridate::as_date(ExtractDate)
  } else{
    ExtractDate = max(lubridate::as_date(Animal$LastTXDate), na.rm = T)
  }   
  assert_that(is.numeric( MaxOutl))
  assert_that(MaxOutl <= 100)
  assert_that(is.numeric(UncertBirth))
  assert_that(is.numeric(UncertDeath))
  assert_that(is.numeric(UncertDate))
  assert_that(is.double(MinInstitution))
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  checkmate::assert_directory_exists(PlotDir)
  
  if("sur" %in% Sections){
    assert_that(is.data.frame(DeathInformation))
    assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
    if(!is.null(MaxNSur)) assert_that(is.numeric(MaxNSur))
    assert_that(is.numeric(MinNSur))
    assert_that(MinNSur > 0)
    assert_that(is.numeric(MinLx))
    assert_that(MinLx >= 0 & MinLx <= 1)
    assert_that(is.numeric(MinMLE))
    assert_that(MinMLE >= 0 & MinMLE <= 1)
    assert_that(is.numeric(MaxLE))
    assert_that(is.numeric(MinBirthKnown))
    assert_that(MinBirthKnown <= 1, msg ='MinBirthKnown must be a proportion, so between 0 and 1')
    assert_that(is.logical(LastDead))
    assert_that(is.numeric(niter))
    assert_that(niter > 0)
    assert_that(is.numeric(burnin))
    assert_that(burnin > 0)
    assert_that(burnin < niter)
    assert_that(is.numeric(thinning))
    assert_that(thinning > 0)
    assert_that(thinning < niter)
    assert_that(is.numeric(nchain))
    assert_that(nchain > 0)
    assert_that(is.character(ModelsSur))
    assert_that(all(ModelsSur %in% c("GO", "EX", "LO", "WE")))
    assert_that(is.character(Shape))
    assert_that(all(Shape %in% c("simple", "bathtub", "Makeham")))
  }
  
  if("gro" %in% Sections){
    assert_that(is.data.frame(Weights))
    assert_that(Weights %has_name% c("MeasurementValue", "MeasurementDate", "CollectionScopeType", "UnitOfMeasure", "EstimatedMeasurement", "RecordType", "MeasurementType", "AnimalAnonID", "RecordingInstitution"))
    assert_that(is.numeric( MinNIGro))
    assert_that( MinNIGro > 0)
    assert_that(is.numeric(MinNGro))
    assert_that(MinNGro > 0)
    assert_that(is.character(ModelsGro))
    assert_that(all(ModelsGro %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy, and polynomial, in addition to GAM.")}
  
  if("rep" %in% Sections){
    assert_that(is.data.frame(Parents))
    assert_that(is.data.frame(Move))
    assert_that(is.data.frame(Contraceptions))
    assert_that(Move %has_name% c("AnimalAnonID", "To", "Date"))
    assert_that(Collection %has_name% c("AnimalAnonID", "ScopeType", "ChangeDate"))
    assert_that(parent %has_name% c("ParentAnonID", "ParentCollectionScopeType", 
                                    "OffspringCollectionScopeType", "AnimalAnonID",
                                    "ParentOriginType", "Probability"))
    assert_that(all(RepSect %in% c("agemat", "litter")))
    assert_that(is.numeric(ParentPercDam))
    assert_that(ParentPercDam > 0)
    assert_that(is.numeric(ParentPercSire))
    assert_that(ParentPercSire > 0)
    assert_that(is.numeric(MinNRepro))
    assert_that(MinNRepro > 0)
    assert_that(is.numeric(MinNPaRepro))
    assert_that(MinNPaRepro > 0)
    assert_that(is.numeric(MinNLitter))
    assert_that(MinNLitter > 0)
    assert_that(is.numeric( MinNSeas))
    assert_that( MinNSeas > 0)
    assert_that(is.numeric( NDay))
    assert_that( NDay >= 0)
  }
  

# Prepare data -----------------------------------------------------------------
  # Extract Species Data
  Dat <- select_species(Species, Animal, Collection,  
                        UncertBirth = UncertBirth, BirthType = BirthType,
                        MinDate = MinDate , ExtractDate = ExtractDate, 
                        Global = Global) 
  repout$general = Dat$summary
  SpeciesName = stringr::str_replace(Species, " ", "_")
  
# Run Analysis for each sex category -------------------------------------------
  if(nrow(Dat$data)>0){
    for (sx in SexCats){
      cat(paste0(" ****************************  ",sx,"  ****************************\n"))
      dir.create(file.path(PlotDir, "Long_dist"), showWarnings = FALSE)
       # -------------------------- #
       # -Check for longevity gaps- #
       # -------------------------- #
      sexDat <- select_Longthreshold( Dat$data,  SexCats = sx, 
                                      PlotDir= glue::glue("{PlotDir}/Long_dist/"),
                                      MinN = MinN,
                                      PlotName = glue::glue("{Taxa}_{SpeciesName}_{sx}") )
      
      repout$summary[[sx]] = sexDat$summar
      if(nrow(sexDat$data)>0){
        outlLev1 = min(sexDat$summar$GapThresh,MaxOutl, na.rm = T)
        if (outlLev1 ==100){
          data_sel <-  sexDat$data
        }else{
          data_sel <-  sexDat$data%>%
            filter(!!sym(paste0("above", outlLev1))==0)
        }
        if(nrow(data_sel)>0){
          # ------------------------------ #
          # ---- Reproduction module: ----
          # ------------------------------ #
          # Reproduction module list:
          if ("rep" %in% Sections) {
            cat("Reproduction Running ----------------------------------------\n")
            # Reproduction module list:
            Repse = RepSect
            if(sx == "Male"){Repse = RepSect%>%stringr::str_subset("litter", negate = T)}
            repout$repr[[sx]] <- Rep_main(coresubset= data_sel, Collection, Parents, Move,  
                                          RepSect = Repse,
                                          BirthType_parent = BirthType, BirthType_offspring = BirthType, 
                                          Global = Global, MinInstitution  = MinInstitution , 
                                          MinNRepro = MinNRepro, MinNPaRepro =  MinNPaRepro,
                                          ParentPercDam = ParentPercDam, 
                                          ParentPercSire = ParentPercSire,
                                          MinNLitter = MinNLitter, NDay = NDay,
                                          MinNSeas =  MinNSeas)
          }
           #Save age at maturity
            agemat = NA
            if(length(repout$repr[[sx]])>0){
              if(repout$repr[[sx]]$summary$amat_analyzed){
                agemat = repout$repr[[sx]]$agemat$ageMat
              }
            }
          
          # -------------------------- #
          # ---- Survival Module: ----
          # -------------------------- #
          # Run survival analyses:
          if ("sur" %in% Sections) {
            dir.create(file.path(PlotDir, "Survival"), showWarnings = FALSE)
            cat("Survival Running ------------------------------------------------\n")
            repout$surv[[sx]] <- Sur_main(Data = sexDat$data,  
                                          DeathInformation = DeathInformation,
                                          BirthType = BirthType,
                                          PlotDir = glue::glue("{PlotDir}/Survival/"),
                                          MaxAge = MaxAge,
                                          Models = ModelsSur, Shape= Shape, 
                                          MinAge =MinAge, 
                                          AgeMat = agemat,
                                          OutlLev1 =outlLev1, 
                                          MinMLE = MinMLE, MaxLE =  MaxLE,
                                          LastDead = LastDead,
                                          MinDate = MinDate, MinNSur = MinNSur, 
                                          MaxNSur = MaxNSur, 
                                          MinInstitution = MinInstitution,
                                          UncertDeath = UncertDeath,
                                          MinLx = MinLx, MinBirthKnown = MinBirthKnown, 
                                          niter = niter, burnin = burnin, thinning = thinning, 
                                          nchain = nchain, ncpus = ncpus,
                                          PlotName = glue("{Taxa}_{SpeciesName}_{sx}") )
            #Plot survivorship for both sexes if available
            if(sx == "Female" && length(repout$surv$Male$from0$summary$analyzed)==1){
              if(!is.null(PlotDir) & repout$surv$Male$from0$summary$analyzed& repout$surv$Female$from0$summary$analyzed ){
                pdf(file = paste0(PlotDir,"/Survival/",Taxa,"_", SpeciesName,"_surMF.pdf", sep=""), width = 6, height = 6)
                plot(NULL, main = glue("{Taxa}_{SpeciesName}"), 
                     ylim = c(min(repout$surv$Male$from0$bastaRes$surv$nocov, repout$surv$Female$from0$bastaRes$surv$nocov),
                              max(repout$surv$Male$from0$bastaRes$surv$nocov, repout$surv$Female$from0$bastaRes$surv$nocov)) , 
                     xlim = c(min(repout$surv$Male$from0$bastaRes$x, repout$surv$Female$from0$bastaRes$x),
                              max(repout$surv$Male$from0$relex_from0$Age, repout$surv$Female$from0$relex_from0$Age)),
                     xlab = 'Age', ylab = "Survivorship")
                polygon(y = c(repout$surv$Female$from0$bastaRes$surv$nocov[2,], 
                              rev(repout$surv$Female$from0$bastaRes$surv$nocov[3,])), 
                        x =c(repout$surv$Female$from0$bastaRes$x, 
                             rev(repout$surv$Female$from0$bastaRes$x)), 
                        col=rgb(1, 0, 0,0.5))
                polygon(y = c(repout$surv$Male$from0$bastaRes$surv$nocov[2,],
                              rev(repout$surv$Male$from0$bastaRes$surv$nocov[3,])),
                        x = c(repout$surv$Male$from0$bastaRes$x, 
                              rev(repout$surv$Male$from0$bastaRes$x)),
                        col=rgb(0, 0, 1,0.25))
                dev.off()
              }
            }
          }
          
          
          # ----------------------------- #
          # ---- Body weight module: ----
          # ----------------------------- #
          # Growth module list:
          if ("gro" %in% Sections) {
            dir.create(file.path(PlotDir, "Growth"), showWarnings = FALSE)
            cat("Growth Running ----------------------------------------------\n")
            repout$weig[[sx]] <- Gro_Main(data = Weights, coresubse = data_sel,
                                          Taxa = Taxa, Species = Species,
                                          BirthType = BirthType, 
                                          AgeMat = agemat, percentiles = c(2.5,97.5),
                                          PlotDir = glue::glue("{PlotDir}/Growth/"), type = "weight",
                                          UncertDate = UncertDate,
                                          MeasureType = MeasureType,
                                          MinInstitution  = MinInstitution ,
                                          MinNGro = MinNGro, MinNIGro = MinNIGro, 
                                          models = ModelsGro,
                                          MinDate = MinDate, PlotName = glue("{Taxa}_{SpeciesName}_{sx}") )
            print(repout$weig[[sx]]$Captive$wSummar$error)
          }
        }
      }
    }
  }else{
    warnings(glue::glue("No data for {Species}"))
  }
  
  return(repout)
}

```

```{r examples-tx_report}
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSDirtest = dirname(file)
data <- Load_Zimsdata	(Taxa = "Reptilia",
                       Species = list(Reptilia = "All"),
                       ZIMSDir = ZIMSDirtest,
                       Animal = TRUE, tables = c("Collection","DeathInformation"))

Animal<- Prep_Animal(data[["Reptilia"]]$Animal, ExtractDate="2024/08/29"  )
PlotDir = paste0(tempdir(check = TRUE),'/temp')
dir.create(PlotDir)

out <- tx_report(Species = "Testudo hermanni", Taxa = "Reptilia",
                 Animal, data$Reptilia$Collection, 
                 BirthType = "All", UncertBirth = 3500,UncertDeath = 3500, 
                 DeathInformation =data$Reptilia$DeathInformation,
                 PlotDir = PlotDir,Sections = c('sur'),
                 SexCats = c("Male", "Female"),
                 ModelsSur = "GO", Shape = "simple",
                 ModelsGro = "vonBertalanffy",
                 niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3
)

list.files(PlotDir)
unlink(PlotDir, recursive = TRUE)

```


```{r tests-tx_report}
test_that("tx_report works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSDirtest = dirname(file)
  data <- Load_Zimsdata	(Taxa = "Reptilia",
                         Species = list(Reptilia = "All"), ZIMSDir = ZIMSDirtest,
                         Animal = TRUE, tables = c("Collection","DeathInformation", 
                                                   "Weight", "Parent", "Move", 
                                                   "Contraception"))
  Animal<- Prep_Animal(data[["Reptilia"]]$Animal, ExtractDate= "2024/08/29" )
  PlotDir = paste0(tempdir(check = TRUE),'/temp')
  dir.create(PlotDir)
  
  out <- tx_report(Species = "Testudo hermanni", Taxa = "Reptilia",
                   Animal, data$Reptilia$Collection,
                   Move = data$Reptilia$Move, Parents =data$Reptilia$Parent,
                   Contraceptions = data$Reptilia$Contraception,
                   MinBirthKnown = 0,
                   MinLx =0.5,MinNIGro=40,
                   BirthType = "All", UncertBirth = 3500, UncertDeath = 3500, 
                   DeathInformation =data$Reptilia$DeathInformation,
                   Weights =data$Reptilia$Weight,
                   niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3,
                   PlotDir = PlotDir, Sections = c('sur','gro', 'rep'),
                   SexCats = c("Male", "Female"),
                   ModelsSur = "GO", Shape = "simple",
                   ModelsGro = "vonBertalanffy"
  )
  expect_named(out, c('general', "summary", 'repr', 'surv', 'weig'))
  expect_named(out$general, c('NRaw', 'NDate', 'NGlobal', 'NBirthType', 'NUncertBirth', 'NAlive', 'FirstDate', 'MaxAgeRaw', 'ExtractDate'))
  expect_named(out$sur, c('Male', "Female"))
  expect_named(out$sur$Male, c("from0"))
  expect_named(out$sur$Male$from0, c('summary', 'metrics', 'bastaRes', 'DICmods', 'KM_estimator', 'relex', 'Sur1', 'Sur5', 'L90', 'L50', 'check', 'relex_from0', 'Sur1m'))
  expect_named(out$weig, c('Male', "Female"))
  expect_named(out$weig$Male$All, c('wSummar', "weightQ"))
  expect_named(out$weig$Female$All, c('wSummar', "weightQ"))
  expect_true(file.exists(paste(PlotDir, "Long_dist/Reptilia_Testudo_hermanni_Male_LongThres.pdf", sep = '/')))
  expect_true(file.exists(paste(PlotDir, "Survival/10_Reptilia_Testudo_hermanni_Male_0_surcheck.pdf", sep = '/')))
  expect_true(file.exists(paste(PlotDir, "Survival/10_Reptilia_Testudo_hermanni_Male_0_surplot.pdf", sep = '/')))
  expect_true(file.exists(paste(PlotDir, "Growth/Reptilia_Testudo_hermanni_Male_All_outliers.png", sep = '/')))
  expect_true(file.exists(paste(PlotDir, "Growth/Reptilia_Testudo_hermanni_Male_All_growth.png", sep = '/')))
  unlink(PlotDir, recursive = TRUE)
})
```




# Prepare Animal Data

This function checks dates and add the following columns to animal data: MinBirthDate, MaxBirthDate, MinDeathDate, MaxDeathDate, EntryDate, EntryType, DepartDate, DepartType, BirthUncertainty, and DeathUncertainty. It includes the following argument:

* `Animal`data frame including at least the following columns *AnimalAnonID*,  *BirthDate*, *BirthDateEstimateType*, *BirthDateEstimateStart*, *BirthDateEstimateEnd*, *BirthType*, *FirstAcquisitionDate*, *DeathDate*, *DeathDateEstimateType*, *DeathDateEstimateStart*, *DeathDateEstimateEnd*, *LastCommentEntryDate*, *BirthObserved*, *GlobalStatus*, and  *LastTXDate*
* `ExtractDate`  Latest possible date in the data: date used when individuals are still alive

```{r function-Prep_Animal}
#' Prepare Animal data
#' 
#' Check dates and add needed columns to animal data
#'
#' @param Animal  \code{data.frame} including at least the following columns *AnimalAnonID*,  *BirthDate*, *BirthDateEstimateType*, *BirthDateEstimateStart*, *BirthDateEstimateEnd*, *BirthType*, *FirstAcquisitionDate*, *DeathDate*, *DeathDateEstimateType*, *DeathDateEstimateStart*, *DeathDateEstimateEnd*, *LastCommentEntryDate*, *BirthObserved*, *GlobalStatus*, and  *LastTXDate*
#' @param MinBirthDate  \code{character}: Earliest possible date: date used when minimum birth or death date unknown
#' @param ExtractDate  \code{character}: Latest possible date in the data: date used as DepartDate when individuals are still alive
#'
#' @return the checked and prepared dataset
#' 
#' @details
#' This function adds the columns: MinBirthDate, MaxBirthDate, MinDeathDate, MaxDeathDate, EntryDate, EntryType, DepartDate, DepartType, BirthUncertainty, and DeathUncertainty. It removes individuals for which dates are not chronologically meaningful (i.e. birth date after death date) and for which birth uncertainty is higher than \code{UncertBirth}.
#' 
#' @importFrom lubridate as_date
#' @importFrom tidyr replace_na
#' @export
#'
#' @examples
Prep_Animal <- function(Animal, 
                        MinBirthDate = "1900-01-01",
                        ExtractDate) {
   # Check correct format for inputs -----------------------------------------------------------------------
  MinBirthDate = as.character(MinBirthDate)
  ExtractDate = as.character(ExtractDate)
  assert_that(is.data.frame(Animal))
  assert_that(Animal  %has_name% c("AnimalAnonID",  "BirthDate", "BirthDateEstimateType",
                                   "BirthDateEstimateStart", "BirthDateEstimateEnd",
                                   "BirthObserved", "GlobalStatus",
                                   "BirthType", "FirstAcquisitionDate", "DeathDate", 
                                   "DeathDateEstimateType", "DeathDateEstimateStart",
                                   "DeathDateEstimateEnd", 
                                   "LastCommentEntryDate", "LastTXDate"))
  
  
  # Determine Minimum and Maximum birth and death dates ------------------------------
  Animal <- Animal%>%
    mutate(
      MinBirthDate = case_when(
        BirthDateEstimateType == "ApproxBefore" ~ MinBirthDate,
        BirthDateEstimateType == "ApproxAfter" ~ BirthDate,
        BirthDateEstimateType == "Undetermined" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "Indeterminate" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "Range" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "ApproxVariance" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "" ~ BirthDateEstimateStart),
      MaxBirthDate = case_when(
        BirthDateEstimateType == "ApproxBefore" ~ BirthDate,
        BirthDateEstimateType == "ApproxAfter" ~ ExtractDate,
        BirthDateEstimateType == "Undetermined" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "Indeterminate" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "Range" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "ApproxVariance" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "" ~ BirthDateEstimateEnd
      ),
      MinDeathDate = case_when(
        DeathDateEstimateType == "ApproxBefore" ~ MinBirthDate,
        DeathDateEstimateType == "ApproxAfter" ~ DeathDate,
        DeathDateEstimateType == "Undetermined" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "Indeterminate" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "Range" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "ApproxVariance" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "" ~ DeathDateEstimateStart),
      MaxDeathDate = case_when(
        DeathDateEstimateType == "ApproxBefore" ~ DeathDate,
        DeathDateEstimateType == "ApproxAfter" ~ ExtractDate,
        DeathDateEstimateType == "Undetermined" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "Indeterminate" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "Range" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "ApproxVariance" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "" ~ DeathDateEstimateEnd),
      MinBirthDate = lubridate::as_date(MinBirthDate),
      MaxBirthDate = lubridate::as_date(MaxBirthDate),
      BirthDate = lubridate::as_date(BirthDate),
      MinDeathDate = lubridate::as_date(MinDeathDate),
      MaxDeathDate = lubridate::as_date(MaxDeathDate),
      DeathDate = lubridate::as_date(DeathDate),
      FirstAcquisitionDate = lubridate::as_date(FirstAcquisitionDate),
      LastTXDate  = lubridate::as_date(LastTXDate),
      MinBirthDate = coalesce(MinBirthDate, BirthDate),
      MaxBirthDate = coalesce(MaxBirthDate, BirthDate),
      MinDeathDate = coalesce(MinDeathDate, DeathDate),
      MaxDeathDate = coalesce(MaxDeathDate, DeathDate))
  
  
  
  # Select individuals with meaningful min and max  birth and death dates---------
  Animal <- Animal%>%
    filter ((BirthDate >= MinBirthDate)%>% replace_na(TRUE),
            (BirthDate <= MaxBirthDate)%>% replace_na(TRUE),
            (DeathDate >= MinDeathDate)%>% replace_na(TRUE),
            (DeathDate <= MaxDeathDate)%>% replace_na(TRUE)
    )
  
   # Determine Entry and Depart dates and types ------------------------------
  Animal <- Animal%>%
    mutate(EntryDate = FirstAcquisitionDate,
           EntryType = ifelse(BirthObserved == "NO", "T", "B"),
           DepartDate = ifelse(is.na(DeathDate), LastTXDate, DeathDate),
           DepartDate = ifelse(GlobalStatus == "Alive", lubridate::as_date(ExtractDate), DepartDate),
           DepartType = ifelse(GlobalStatus == "Dead" | !is.na(DeathDate), "D", "C"),
           EntryDate = lubridate::as_date(EntryDate),
           DepartDate = lubridate::as_date( DepartDate))
  #Correct Entry Dates
  ID = which (Animal$EntryDate < Animal$MaxBirthDate)
  Animal$MaxBirthDate[ID]= Animal$EntryDate[ID] 
  ID = which (Animal$EntryType == "B" & Animal$EntryDate != Animal$BirthDate)
  Animal$EntryDate[ID] = Animal$MaxBirthDate[ID]
  ID = which (Animal$EntryType == "B" & is.na(Animal$EntryDate))
  Animal$EntryDate[ID] = Animal$MaxBirthDate[ID]
   #Correct Depart Dates
  Animal$DepartDate[Animal$DepartType == "D" & is.na(Animal$DeathDate)] = Animal$LastTXDate[Animal$DepartType == "D" & is.na(Animal$DeathDate)]
  Animal$DepartType[Animal$DepartType == "D" & is.na(Animal$DeathDate)] = "C"
  ID = which(is.na(Animal$DepartDate))
  Animal$DepartDate[ID] = Animal$LastCommentEntryDate[ID]
  Animal$DepartType[ID] = "C"
  
  # Check Chronology in dates ------------------------------------------------------
  Animal <- Animal%>%
    filter ((BirthDate <= FirstAcquisitionDate)%>% replace_na(TRUE),
            (EntryDate <= DepartDate)%>% replace_na(TRUE),
            (DepartDate <= DeathDate)%>% replace_na(TRUE),
            (DeathDate >= LastTXDate)%>% replace_na(TRUE),
            (BirthDate <= DeathDate)%>% replace_na(TRUE),
            (DeathDate >= FirstAcquisitionDate)%>% replace_na(TRUE),
            (BirthDate <= LastTXDate)%>% replace_na(TRUE),
            (FirstAcquisitionDate <= LastTXDate)%>% replace_na(TRUE))%>%
    dplyr::select (-c(DeathDateEstimateStart, DeathDateEstimateEnd, BirthDateEstimateEnd, BirthDateEstimateStart)) %>%
    mutate(BirthUncertainty =  MaxBirthDate-MinBirthDate,
           DeathUncertainty =  MaxDeathDate-MinDeathDate)
  
  return(Animal)
}
```

```{r examples-Prep_Animal}
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSDirtest = dirname(file)

data <- Load_Zimsdata	(Taxa = "Reptilia", 
                       Species = list(Reptilia = "All"),
                       ZIMSDir = ZIMSDirtest,
                       Animal = TRUE)

Animal <- Prep_Animal(data$Reptilia$Animal, ExtractDate = lubridate::as_date("2023/12/23"))

unlink(ZIMSDirtest, recursive = FALSE)
```

```{r tests-Prep_Animal}
test_that("Prep_Animal works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSDirtest = dirname(file)
  
  data <- Load_Zimsdata	(Taxa = "Reptilia",
                         Species = list(Reptilia = "All"),
                         ZIMSDir = ZIMSDirtest,
                         Animal = TRUE)
  
  Animal <- Prep_Animal(data$Reptilia$Animal, ExtractDate = "2023/12/23")
  expect_named(Animal, c("AnimalAnonID", "Class", "Order", "Family", 'SpeciesName', "CommonName", "IUCNRedList", "CITES", "CITESE", "FirstHoldingInstitution", "FirstCollectionScopeType", "LastHoldingInstitution", "LastCollectionScopeType", "AnyLocalCollectionFlag", "LatitudeZone", "BirthDate", "BirthDateEstimateType", "BirthType", "BirthObserved", "FirstAcquisitionDate", "SexType", "PhysicalMoveCount", "DeathDate", "DeathDateEstimateType", "GlobalStatus", "AnimalType", "LastCommentEntryDate", "LastTXDate", 'binSpecies', "MinBirthDate", "MaxBirthDate", "MinDeathDate", "MaxDeathDate",  "EntryDate", "EntryType", "DepartDate", "DepartType", "BirthUncertainty", "DeathUncertainty"))
  
})
```


# Extract Data

This function extracts the data of the specified Species that fill the condition on minimum date and global collections. It includes the following argument:

* `SpeciesName` latin name of the selected species
* `coresubset`data frame including at least the following columns *AnimalAnonID*, *binSpecies*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *MaxDeathDate*, *MinDeathDate*, *EntryType*, *DepartType*,  *LastTXDate*, *DeathDate*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *GlobalStatus*, *LastCollectionScopeType*, and *FirstCollectionScopeType*
* `Collection` data.frame including at least the following columns*RecordingInstitution*, *ChangeDate*, *ScopeType*, and *AnimalAnonID*.
* `UncertBirth` Maximum uncertainty accepted for birth date, in days
* `BirthType` Captive, Wild, or All
* `MinDate`: Earliest date to include data
* `ExtractDate`: Date of data extraction
* `Global` Whether only individuals belonging to global Collections should be used.
* `na_birthdate` Whether lines with unknown birth date should be kept.


The output is a list including:
* The subseted dataset
* a summary of the data used:
    * NRaw : Raw number of individuals
    * NDate : Number of individuals with an entry date posterior to the minimum date
    * NGlobal: Number of individuals selected from global Collections
    * NBirthType: Number of individuals selected from birth type
    * NUncertBirth: Number of individuals selected from uncertainty in birth
    * NAlive: Number of individuals still alive
    * FirstDate: Date of first record
    * MaxAgeRaw: Maximum observed age

```{r function-select_species}
#' Extract data
#' 
#' Extract data of the specified Species that fill the condition on minimum date and global Collections
#'
#' @param SpeciesName \code{character} latin name of the Species selected
#' @param coresubset  \code{data.frame} including at least the following columns *AnimalAnonID*, *binSpecies*, *BirthDate* (\code{date}), *DepartDate* (\code{date}), *EntryDate* (\code{date}), *MaxBirthDate* (\code{date}), *MinBirthDate* (\code{date}), *MaxDeathDate* (\code{date}), *MinDeathDate* (\code{date}), *EntryType*, *DepartType*,  *LastTXDate*, *DeathDate*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *GlobalStatus*, *LastCollectionScopeType*, and *FirstCollectionScopeType*
#' @param Collection \code{data.frame} including at least the following columns *RecordingInstitution*, *ChangeDate*, *ScopeType*, and *AnimalAnonID*.
#' @param MinDate \code{character 'YYYY-MM-DD'} Earliest date to include data
#' @param UncertBirth \code{numeric}: Maximum uncertainty accepted for birth dates, in days
#' @param BirthType \code{character} Captive, Wild, or All.
#' @param ExtractDate \code{character 'YYYY-MM-DD'} Date of data extraction
#' @param Global \code{logical} Whether only individuals belonging to global Collections should be used.
#' @param na_birthdate \code{logical} Whether lines with unknown birth date should be kept.
#'
#' @return A list including:
#' * a summary of the data used:
#'    * NRaw : Raw number of individuals
#'    * NDate : Number of individuals with an entry date posterior to the minimum date
#'    * NGlobal: Number of individuals selected from global Collections
#'    * NBirthType: Number of individuals selected from birth type
#'    * NUncertBirth: Number of individuals selected from uncertainty in birth
#'    * NAlive: Number of individuals still alive
#'    * FirstDate: Date of first record
#'    * MaxAgeRaw: Maximum observed age
#'* The subseted dataset
#' @export
#'
#' @examples
select_species <- function(SpeciesName, coresubset, Collection, UncertBirth = 365,                                     
                           BirthType = "Captive",
                           MinDate, ExtractDate, Global = TRUE, na_birthdate = FALSE) {
   
  # Check correct format for inputs -----------------------------------------------------------------------
  MinDate = lubridate::as_date(MinDate)
  ExtractDate = lubridate::as_date(ExtractDate)
  assert_that(BirthType %in% c("Captive", "Wild", "All"))
  assert_that(is.numeric(UncertBirth))
  assert_that(is.data.frame(coresubset))
  assert_that(is.data.frame(Collection))
  assert_that(coresubset  %has_name% c("AnimalAnonID", "binSpecies", "BirthDate", "DepartDate",
                                       "EntryDate", "MaxBirthDate", "MinBirthDate",
                                       "MaxDeathDate", "MinDeathDate", "EntryType", "DepartType",
                                       "LastTXDate", "DeathDate", "FirstHoldingInstitution", 
                                       "LastHoldingInstitution","GlobalStatus",
                                       "LastCollectionScopeType","FirstCollectionScopeType"))
  assert_that(Collection  %has_name% c("RecordingInstitution", "ChangeDate", 
                                       "ScopeType", "AnimalAnonID"))
  assert_that(is.logical(Global))
  assert_that(is.logical(na_birthdate))
  
  
  # Select Data -------------------------------------------------------------------------
  coresubset0 <- coresubset%>%
    filter(binSpecies == SpeciesName)
  
  # Subset by min date
  coresubset1 <- coresubset0%>%
    filter(DepartDate >= MinDate)
  
   summar = list(NRaw = nrow(coresubset0),
                NDate = nrow(coresubset1),
                NGlobal = 0,
                NBirthType = 0,
                NUncertBirth = 0,
                NAlive = 0,
                FirstDate = NULL,
                MaxAgeRaw = NULL,
                ExtractDate = ExtractDate)
  
  if(summar$NDate>0){
        # --- Keep only Global individuals ---
    # (Not useful with science extracts but we keep it if other datasets are used) ---
if(Global){
        indglobloc = coresubset1%>%
        filter(LastCollectionScopeType == "Local",
               FirstCollectionScopeType == "Global"
        )
      if(nrow(indglobloc)>0){
        indglobloc = indglobloc%>%
          left_join(Collection%>%
                      select(RecordingInstitution, ChangeDate, ScopeType, AnimalAnonID),
                    by = c("AnimalAnonID"))%>%
          group_by(AnimalAnonID, ScopeType)%>%
          mutate(maxtime = max(ChangeDate)) %>%
          ungroup()%>%
          filter(maxtime  == ChangeDate)
        #Warnings: there are sometimes 2 institutions for 1 individual for same date  ###!!! THIS SHOULD NOT HAPPEN
        indloc<-indglobloc%>%
          filter(ScopeType=="Local")%>%
          select(-RecordingInstitution)%>%
          left_join(indglobloc%>%
                      filter(ScopeType=="Global")%>%
                      select(AnimalAnonID, RecordingInstitution)%>%
                      group_by(AnimalAnonID )%>%
                      summarise(RecordingInstitution = min(RecordingInstitution)),  ###!!! TO BE CHANGED
                    by = "AnimalAnonID")%>%
          mutate(globStat ="Undetermined (Lost to follow up)",
                 lastInst = as.character(RecordingInstitution),
                 LastCollectionScopeType = "now Global",
                 DepartType = "C",
                 DepartFrom = "Collections",
                 DeathDate = lubridate::as_date(NA),
                 LastTXDate = lubridate::as_date(ChangeDate),
                 DepartDate = lubridate::as_date(ChangeDate))%>%
          select(-ChangeDate, -ScopeType,-maxtime, -RecordingInstitution )%>%
          distinct()
      }else{indloc<-indglobloc}
  
      data_sel <- coresubset1%>%
        rows_update(indloc, by="AnimalAnonID")%>%
        mutate()%>%
        filter(FirstCollectionScopeType == "Global")
      summar$NGlobal = nrow(data_sel)
    }else {data_sel <- coresubset1}
    
    
    if (summar$NGlobal > 0) {  
      # --- Subset by birth type --- 
      if (BirthType != "All"){
        Birth_Type = BirthType 
        data_sel <- data_sel  %>%
          filter(stringr::str_detect(BirthType, pattern = Birth_Type))
      }
      summar$NBirthType = nrow( data_sel)
      
      if(!na_birthdate){
        # --- Subset by uncertainty in birth ---
        data_sel <- data_sel %>%
          tidyr::drop_na(BirthDate)}
       if(nrow(data_sel)>0){
        data_sel1 <- data_sel %>%
          filter((BirthUncertainty <= UncertBirth)%>% replace_na(TRUE))
        summar$NUncertBirth = nrow( data_sel1)
        
        if(nrow(data_sel1)>0){
          # Number alive by extraction date:
          summar$NAlive <- nrow(data_sel1%>%
                                  filter(DepartDate == ExtractDate , 
                                         DepartType == "C"))
          
          # First record:
          summar$FirstDate <- min(data_sel1$EntryDate)
          # Max Ages:
          data_age <- data_sel1%>%
            mutate(tempAges = as.numeric(DepartDate - BirthDate) / 365.25,
                   tempAlive = as.numeric(DepartDate - EntryDate) / 365.25)
          
          
          summar$MaxAgeRaw <- max(c(data_age$tempAges,data_age$tempAlive))
        } 
      }else{data_sel1 = tibble()}
    }else{data_sel1 = tibble()}
   }else{data_sel1 = tibble()}
  
   sexDat <- list(summary = summar, data = data_sel1)
  return(sexDat)
}
```

```{r examples-select_species}
data(core)
data(collection)
out<- select_species(SpeciesName = "Testudo hermanni", coresubset = core, collection,
                     MinDate = "1980-01-01", ExtractDate = "2023-01-01")
out$summary
out$data
```

```{r tests-select_species}
test_that("select_species works", {
  data(core)
  data(collection)
  out<- select_species (SpeciesName = "Testudo hermanni",
                        coresubset = core, collection,
                        MinDate = "1980-01-01", ExtractDate = "2023-01-01")
  expect_named(out, c("summary",  "data"))
  expect_named(out$summary, c('NRaw', 'NDate', 'NGlobal', 'NBirthType', 'NUncertBirth', 'NAlive', 'FirstDate', 'MaxAgeRaw', 'ExtractDate'))
  expect_equal(out$summary$NRaw,1000)
  expect_equal(out$summary$NDate,1000)
  expect_equal(out$summary$NAlive,0)
  expect_named(out$data, names(core))
  expect_equal(nrow(out$data),out$summary$NUncertBirth)
  expect_true(is.numeric(out$summary$MaxAgeRaw))
  expect_true(is.date(out$summary$FirstDate))
  })
```



# Gap analysis in longevity

`select_Longthreshold()` runs a gap analysis on the distribution of longevity and gives the threshold value to use to avoid having gaps in longevity. It can focus on a given sex using the following arguments:

* `Data` including at least the following columns *Birth.Date*, *Depart.Date*, *Entry.Date*, and *SexType*
* `SexCats` Male, Female or All
* `MinN` Minimum number of individuals to run the gap analysis
* `PlotDir` Directory to save the plots
* `PlotName` name of the graph to be saved

It returns the data with the selected sex and additional columns showing which individuals are above the percentiles 95%, 99% and 99.9%
and a summary list including the threshold value selected for the distribution of longevity. It plots the distribution of longevity with gaps if `PlotDir` is given. 

```{r function-select_Longthreshold}
#' Gap analysis in longevity
#' 
#' Run a gap analysis on the distribution of longevity and give the threshold value to use to avoid having gaps in longevity.
#' 
#' @param Data \code{data.frame} including at least the following columns *BirthDate* (\code{date}), *DepartDate* (\code{date}), *EntryDate* (\code{date}), and *SexType*
#' @param SexCats \code{character} Male, Female or All.
#' @param MinN \code{numeric} Minimum number of individuals to run the gap analysis.
#' @param PlotDir \code{character} Directory to save the plots.
#' @param PlotName \code{character} name of the graph to be saved.
#'
#' @return A list including
#' * the data with the selected sex and additional columns showing which individuals are above the percentiles 95%, 99% and 99.9%
#' * A summary list with:
#'     * Sex = the sex selected
#'     * Nselect: the number of individuals of this sex
#'     * Nlifespan : the number of individuals with estimated lifespan (i.e. estimated birth dates, censored individuals are also included)
#'     * GapThresh : The threshold value selected for the distribution of longevity
#'     * NThres : the number of individuals selected using this threshold
#' * Plot and save the longevity distribution with gaps if PlotDir is given.
#'  
#' @export
#'
#' @examples
select_Longthreshold <- function(Data,  SexCats = "All", MinN = 50,
                                 PlotDir = NULL, PlotName = ''
                                 ) {
  # Check correct format for inputs -----------------------------------------------------------------------
  assert_that(is.data.frame(Data))
  assert_that(Data  %has_name% c("BirthDate", "DepartDate",
                                 "EntryDate", "SexType"))
  assert_that(is.character(SexCats))
  assert_that(length(SexCats)==1, 
              msg = "You can chose only one sex category")
  assert_that(all(SexCats %in% c("Female", "Male", "All")))
  assert_that(is.numeric(MinN))
  if(!is.null(PlotDir)){
    assert_that(is.character(PlotDir))
    checkmate::assert_directory_exists(PlotDir)}
  
    # Initialize Output list_______________________________________________________
  outTab <- tibble( 
    Sex = SexCats,
    Nselect = 0,
    Nlifespan = 0,
    GapThresh = NA, 
    NThres = 0
  ) 
  
  #Calculate longevity and time alive ------------------------------------------
  coresubset <- Data%>%
    mutate(
      #longevities:
      lifespans = as.numeric(DepartDate - BirthDate) / 365.25,
      # Calculate time alive:
      alive = as.numeric(DepartDate - EntryDate) / 365.25)
  

  # Select Sex -----------------------------------------------------------------
  if(SexCats %in% c('Male', 'Female')){
    coresex <- coresubset%>%filter(SexType ==SexCats)
  }else{coresex = coresubset}
  outTab$Nselect = nrow(coresex)
  
  # Run Gap analysis -----------------------------------------------------------
  if(nrow(coresex)>0){
     quant = quantile (coresubset$lifespans,c(0.95,0.99,0.999))
    coresex <-  coresex%>%
      mutate(`above95`= if_else(lifespans> quant[1], 1, 0),
             `above99`= if_else(lifespans> quant[2], 1, 0),
             `above99.9`= if_else(lifespans> quant[3], 1, 0)
      )
    # Find gaps in longevities:
    corelong <- coresex%>%tidyr::drop_na(lifespans)
    outTab$Nlifespan <- nrow(corelong)
     if (nrow(corelong) > MinN) {
      gapsAlive <- find_gaps(corelong$alive, 
                             MaxAlive = quantile(corelong$alive, 0.5, na.rm = TRUE), 
                             plot = F)
      if (nrow(gapsAlive) > 0) {
        MaxAlive <-  gapsAlive$iniAge[1]
      } else {
        MaxAlive <- max(corelong$alive, na.rm = TRUE)
      }
      if (MaxAlive < 5) {
        MaxAlive <- 5
      } else if (MaxAlive > 50) {
        MaxAlive <- 50
      }
      
      # Plot the longevity gaps
      pdf(file = glue::glue("{PlotDir}/{PlotName}_LongThres.pdf"), width = 5, height = 5)
      par(mar = c(4, 4, 1, 1))
      gaps <- find_gaps(corelong$lifespans, MaxAlive = MaxAlive, plot = T,
                        main = PlotName, 
                        xlab = "")
      ngap = nrow( gaps)
      if (nrow(gaps) > 0) {
        allev <- 0
        while(allev < 3 & ngap>0) {
          allev <- allev + 1
          qlev <- c("99.9", "99", "95")[allev]
          abcol <- sprintf("above%s", qlev)
          gaps <- find_gaps(corelong$lifespans[corelong[[abcol]] == 0], 
                            MaxAlive = MaxAlive, plot = T,
                            main = paste(qlev, "%"), 
                            xlab = "")
          ngap = nrow(gaps)
        }
        outTab$GapThresh <-as.numeric(qlev)
          if (allev < 3) {
          for (ll in (allev + 1):3) {
            qlev <- c("99.9", "99", "95")[ll]
            abcol <- sprintf("above%s", qlev)
            plot(c(0, 1), c(0, 1), col = NA, axes = FALSE, xlab = "", 
                 ylab = "", main = paste(qlev, "%"))
            text(0.5, 0.5, "No gaps", cex = 2)
            box()
          }
        }
      } else {
        outTab$GapThresh <-100
      }
      outTab$NThres <- nrow(coresex)
      dev.off()
    } 
  }
  return(list(summar = outTab, data = coresex) )
}
```

```{r examples-select_Longthreshold}
TempDir <- paste0(tempdir(check = TRUE),'/temp')
dir.create(TempDir)
data(core) #### CHANGE DATASET WITH ONE EXCLUDING ABOVE95 99 99.9
out <- select_Longthreshold (Data = core,  SexCats = "All", 
                             PlotDir = TempDir, PlotName = "Testudo_hermanni")
list.files(TempDir)
#reMove temporary folder
unlink(TempDir, recursive = TRUE)
```

```{r tests-select_Longthreshold}
test_that("select_Longthreshold works", {
  TempDir <- paste0(tempdir(check = TRUE),'/temp')
  dir.create(TempDir)
  data(core) #### CHANGE DATASET WITH ONE EXCLUDING ABOVE95 99 99.9
  out <- select_Longthreshold (Data = core,  SexCats = "All", 
                               PlotDir = TempDir, PlotName = "Testudo_hermanni")
  expect_true(file.exists(paste(TempDir, 'Testudo_hermanni_LongThres.pdf', sep = '/')))
  #reMove temporary folder
  unlink(TempDir, recursive = TRUE)
  expect_named(out, c("summar",  "data"))
  expect_true("above95" %in% names(out$data))
  expect_named(out$summar, c("Sex", 'Nselect', "Nlifespan", "GapThresh", "NThres"))
  expect_true(out$summar$Sex == "All" )
  expect_equal(out$summar$Nselect, nrow(core))
  unlink(TempDir, recursive = TRUE)
})
```


## Find gaps in a continuous variable

`find_gaps` Looks for gaps within a continuous variable.Values of the variable are rounded and gaps are found if one integer is not represented. Gaps are returned only if the length of the gaps is 20% higher than the starting age of this gap. It uses the following arguments:

* `x` variable to analyze
* `MaxAlive` Return gaps higher than this maximum, only. Default = NA

It returns a data frame where each line is a gap described by its initial/starting age, its final/ending age and its length

```{r function-find_gaps}
#' Find gaps in an integer variable
#' 
#' Looks for gaps within a continuous variable. Values of the variable are rounded and gaps are found if one integer is not represented. Gaps are returned only if the length of the gaps is 20% higher than the starting age of this gap.
#'
#' @param x \code{vector of numeric} variable to analyze
#' @param MaxAlive \code{numeric} Return gaps higher than this maximum, only.
#' @param plot \code{logical} whether to actually plot the histogram
#' @param ... arguments pass to hist()
#'
#' @return
#' A data frame where each line is a gap described by its initial/starting age, its final/ending age and its length
#' 
#' @export
#'
#' @importFrom graphics abline box hist par text
#'
#' @examples
find_gaps <- function(x,MaxAlive = NA, plot = FALSE,...) {
   # Check correct format for inputs -----------------------------------------------------------------------
 assert_that(is.numeric(x))
  if(is.na(MaxAlive)){
    MaxAlive = max(x)
  }else{
    assert_that(is.numeric(MaxAlive))}
  assert_that(is.logical(plot))
  
  #Round each value of the continuous variable-----------------------------------
  breaks <- floor(min(x, na.rm = TRUE)):ceiling(max(x, na.rm = TRUE))
  hs <- hist(x, breaks = breaks, plot = plot, ...)
  xc <- hs$counts
  xc[hs$counts > 0] <- 1
  
  # Look for gaps ---------------------------------------------------------------
  fin <- FALSE
  i <- 1
  n <- length(xc)
  gaps <- tibble(iniAge= numeric(1), finAge= numeric(1), Gap= numeric(1))
  while(!fin & i < n) {
    id0st <- which(xc[i:n] == 0)[1]
    if (!is.na(id0st)) {
      id0fin <- which(xc[(i + id0st - 1):n] == 1)[1] - 1
      gaps <- rbind(gaps, c(hs$breaks[i + id0st - 1], 
                            hs$breaks[i + id0st + id0fin - 2], id0fin))
      i <- i + id0st + id0fin - 1
    } else {
      fin <- TRUE
    }
  }
  if(is.na(MaxAlive))(MaxAlive = max(x))
  
  #Return gaps only if the gaps is 20% higher than the starting age of this gap-----
  idgap <- gaps%>%
    filter(Gap/iniAge > 0.2 ,
           finAge  >= MaxAlive)
   if (nrow(idgap) > 0 & plot) {abline(v = idgap$iniAge, col = 2)}
  return(idgap)
}
```

```{r examples-find_gaps}
x = runif(10,0,40)
out<-find_gaps(x,MaxAlive = 5, plot = FALSE)
```

```{r tests-find_gaps}
test_that("find_gaps works", {
  x = runif(10,0,40)
  out<-find_gaps(x,MaxAlive = 5, plot = FALSE)
  expect_named(out,c('iniAge', 'finAge', 'Gap'))
  expect_equal(out$finAge-out$iniAge+1, out$Gap)
})
```



```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_select.Rmd", vignette_name = "Data Selection")
```

