---
title: "Data Selection"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```



# Create the species profile report

`tx_report()` runs the survival, reproduction and growth analyses for the selected species. It uses the following main arguments:

* `taxa` the name of the taxa studied
* `species` the name of the species studied
*  Data for each analysis: at least `Animal` and `collection`, in addition to `weights`, `parents`, `contraceptions` if needed.   
* `PlotDir`: Directory to save the plots of the best models
* `repout` Previous result of the taxon profile for this species if it needs to be updated
* `sexCats` Sex categories: Male, Female or All 
* `minN` Minimum number of individuals needed to run the analyses
* `minDate` Earlier date to include data records
* `Birth_Type` Captive, Wild, or All
* `models_sur`  names of the survival basta models to run: "G0", "EX", "LO" and/or "WE"
* `shape` shape of the survival basta model to run: "simple", "Makeham", "bathtub"
* `models_gro` indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
* `Repsect` names of the reproductive analyses to run: "agemat", "litter" and/or ...


```{r function-tx_report}
#' Taxon profile report
#' 
#' Run the survival, reproduction and growth analysis for the selected species
#'
#' @param taxa  \code{character} the name of the taxa studied
#' @param species \code{character} the name of the species studied
#' @param Animal \code{data.frame} core data
#' @param collection  \code{data.frame} collection data
#' @param PlotDir \code{character} Directory to save the plots. Default = NULL, no plot is saved
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param weights \code{data.frame} weights data if the growth analysis is run
#' @param parents \code{data.frame} parents data if the reproduction analysis is run
#' @param contraceptions \code{data.frame} contraception data if the reproduction analysis is run
#' @param move \code{data frame} Moves data including at least the following columns: *AnimalAnonID*, *To*, *Date*
#' @param repout \code{list} Previous result of the taxon profile for this species if it needs to be updated only
#' @param Sections \code{vector of character} names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro". Default = c("sur", "rep", "gro")
#' @param sexCats \code{character} Male, Female or All Default =  "All"
#' @param minN \code{numeric} Minimum number of individuals. Default = 50
#' @param minDate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param extractDate \code{character 'YYYY-MM-DD'} Date of data extraction
#' @param minBirthDate  \code{character}: Earlier possible date: date used when minimum birth or death date unknown
#' @param Birth_Type \code{character} Captive, Wild, or All. Default =  "Captive"
#' @param Global \code{logical} Whether only individuals belonging to global collections should be used.
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the analyses. Default = 2
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#' @param firstyear \code{logical} Whether to do the analysis only on first year. Default = FALSE
#' @param uncert_birth \code{numeric}: Maximum uncertainty accepted for birth dates, in days
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death dates, in days. Default = 365
#' @param uncert_date \code{numeric}: Maximum uncertainty accepted for measurement dates: weight, in days. Default = 365
#' @param minNsur \code{numeric} Minimum number of individual records needed to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minlx  \code{numeric} between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis. Default = 0.1
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data. Default = 0.3
#' @param maxOutl \code{numeric} Maximum threshold for the longevity distribution. Default = 100
#' @param XMAX \code{numeric} Maximum possible age. Default = 120
#' @param Min_MLE \code{numeric} Goodness of fit: Minimum survivorship at Mean life expectancy
#' @param MaxLE \code{numeric} Goodness of fit: Maximum remaining life expectancy at max age
#' @param models_sur \code{vector of characters} names of the survival basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the survival basta model to run: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param lastdead  \code{logical} Whether the longest lived individuals should be considered dead. Default = FALSE
#' @param niter  \code{numeric}. number of MCMC iterations to run the survival model. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the survival model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run the survival model before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run the survival model. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#' @param Repsect \code{character} names of the reproductive analyses to run: "agemat", "litter" and/or ...
#' @param Nday \code{numeric} Number of consecutive days over which the birth dates of a litter/clutch can be spread. Default = 7
#' @param parentProb_Dam \code{numeric} Minimum percentage of parentage probability to include for Dam. Default = 80
#' @param parentProb_Sire \code{numeric} Minimum percentage of parentage probability to include for Sire. Default = 80
#' @param minNlitter \code{numeric} Minimum number of litters to run the analysis. The data frame for litter size will be produced in all cases. Default = 30
#' @param minNrepro \code{numeric} Minimum number of birth records needed to run reproductive analyses. Default = 50
#' @param minNparepro \code{numeric} Minimum number of unique parent records needed to run reproductive analyses. Default = 30
#' @param minNseas \code{numeric} XXXXXXXXXXX
#' @param minNgro \code{numeric} Minimum number of weight needed to fit the growth models
#' @param minNIgro \code{numeric} Minimum number of unique individuals needed to fit the growth models
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included.  Default = NULL, all measurement type are included.
#' @param models_gro \code{vector of characters} indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
#' 
#' @return a list including the results and summary of each analysis
#' @export
#' 
#' @importFrom grDevices rgb
#' @importFrom graphics polygon
#'
#' @examples
tx_report <- function(species, taxa,  Animal, collection, PlotDir = NULL,
                      weights = NULL,parents = NULL, move= NULL, 
                      contraceptions = NULL, DeathInformation = NULL,
                      repout = list(), Sections = c('sur', 'rep', 'gro'),
                      sexCats = c("Male", "Female"), minN= 50, minDate= "1980-01-01",
                      Global = TRUE,minBirthDate = "1900-01-01",
                      extractDate = NULL, uncert_birth = 365,  uncert_death = 365,  uncert_date = 365, 
                      minNsur = 50,maxNsur = NULL, minInstitution = 2, 
                      minlx = 0.1, MinBirthKnown = 0.3, maxOutl = 100,XMAX =120,
                      Min_MLE = 0.1, MaxLE = 2, firstyear =FALSE,
                      models_sur = "GO", shape = "bathtub",
                      niter = 25000, burnin = 5001, thinning = 20, nchain = 3, 
                      ncpus = 2, minAge = 0,lastdead = FALSE,
                      Repsect = c('agemat', 'litter'),
                      Birth_Type = "Captive", 
                      parentProb_Dam = 80,  parentProb_Sire = 80, minNlitter = 20,Nday = 7,
                      minNrepro = 100, minNparepro = 30, minNseas = 50, 
                      minNgro =100,minNIgro = 50, MeasureType = "Live weight",
                      models_gro = "vonBertalanffy"
) {
  assert_that(is.character(taxa))
  assert_that(is.character(Sections))
  assert_that(all(Sections %in% c("sur", "gro", "rep")))
  assert_that(is.character(species))
  assert_that(is.logical(Global))
  
  
  
  assert_that(is.data.frame(Animal))
  assert_that(is.data.frame(collection))
  assert_that(Animal  %has_name% c("AnimalAnonID", "binSpecies", "BirthDate", "DepartDate",
                                   "EntryDate", "MaxBirthDate", "MinBirthDate",
                                   "MaxDeathDate", "MinDeathDate", "EntryType", "DepartType",
                                   "LastTXDate", "DeathDate", "FirstHoldingInstitution", 
                                   "LastHoldingInstitution","GlobalStatus",
                                   "LastCollectionScopeType","FirstCollectionScopeType"))
  assert_that(collection  %has_name% c("RecordingInstitution", "ChangeDate", 
                                       "ScopeType", "AnimalAnonID"))
  
  if(!is.null(extractDate)){
    extractDate = lubridate::as_date(extractDate)
  } else{
    extractDate = max(lubridate::as_date(Animal$LastTXDate), na.rm = T)
  }
  if("sur" %in% Sections){
    assert_that(is.data.frame(DeathInformation))
    assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  }
  if("gro" %in% Sections){
    assert_that(is.data.frame(weights))
    assert_that(weights %has_name% c("MeasurementValue", "MeasurementDate", "CollectionScopeType", "UnitOfMeasure", "EstimatedMeasurement", "RecordType", "MeasurementType", "AnimalAnonID", "RecordingInstitution"))
  }
  if("rep" %in% Sections){
    assert_that(is.data.frame(parents))
    assert_that(is.data.frame(move))
    assert_that(is.data.frame(contraceptions))
    assert_that(moves %has_name% c("AnimalAnonID", "To", "Date"))
    assert_that(collection %has_name% c("AnimalAnonID", "ScopeType", "ChangeDate"))
    assert_that(parent %has_name% c("ParentAnonID", "ParentCollectionScopeType", 
                                    "OffspringCollectionScopeType", "AnimalAnonID",
                                    "ParentOriginType", "Probability"))
  }
  assert_that(Birth_Type %in% c("Captive", "Wild", "All"))
  
  assert_that(is.character( sexCats))
  assert_that(all(sexCats %in% c("Male", "Female", "All")))
  assert_that(is.numeric( maxOutl))
  assert_that( maxOutl <= 100)
  assert_that(is.numeric(uncert_birth))
  assert_that(is.numeric(uncert_death))
  assert_that(is.numeric(uncert_date))
  assert_that(is.numeric(minNsur))
  if(!is.null(maxNsur)) assert_that(is.numeric(maxNsur))
  assert_that(minNsur > 0)
  assert_that(is.numeric(minlx))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(Min_MLE))
  assert_that(is.numeric(MaxLE))  
  assert_that(minlx > 0)
  assert_that(minlx < 1)
  assert_that(is.numeric(MinBirthKnown))
  assert_that(MinBirthKnown >= 0)
  assert_that(MinBirthKnown <1)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models_sur))
  assert_that(all(models_sur %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  checkmate::assert_directory_exists(PlotDir)
  
  assert_that(all(Repsect %in% c("agemat", "litter")))
  assert_that(is.numeric(parentProb_Dam))
  assert_that(parentProb_Dam > 0)
  assert_that(is.numeric(parentProb_Sire))
  assert_that(parentProb_Sire > 0)
  assert_that(is.numeric(minNrepro))
  assert_that(minNrepro > 0)
  assert_that(is.numeric(minNparepro))
  assert_that(minNparepro > 0)
  assert_that(is.numeric(minNlitter))
  assert_that(minNlitter > 0)
  assert_that(is.numeric( minNseas))
  assert_that( minNseas > 0)
  assert_that(is.numeric( Nday))
  assert_that( Nday >= 0)
  assert_that(is.numeric( minNIgro))
  assert_that( minNIgro > 0)
  assert_that(is.numeric(minNgro))
  assert_that(minNgro > 0)
  assert_that(is.character(models_gro ))
  assert_that(all(models_gro %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy, and polynomial, in addition to GAM.")
  
  # --------------------- #
  # ---- Prep. data: ----
  # --------------------- #
  ## Extract Data
  Dat <- select_species(species, Animal, collection,  uncert_birth = uncert_birth, Birth_Type = Birth_Type,
                        minDate = minDate , extractDate = extractDate, Global = Global) 
  repout$general = Dat$summary
  speciesname = stringr::str_replace(species, " ", "_")
  
  if(nrow(Dat$data)>0){
    for (sx in sexCats){
      cat(paste0(" ****************************  ",sx,"  ****************************\n"))
      dir.create(file.path(PlotDir, "Long_dist"), showWarnings = FALSE)
      sexDat <- select_Longthreshold( Dat$data,  sexCats = sx, 
                                      PlotDir= glue::glue("{PlotDir}/Long_dist/"), minN = minN ,
                                      maintitle = glue::glue("{taxa}_{speciesname}_{sx}") )
      
      repout$summary[[sx]] = sexDat$summar
      if(nrow(sexDat$data)>0){
        outlLev1 = min(sexDat$summar$GapThresh,maxOutl, na.rm = T)
        if (outlLev1 ==100){
          data_sel <-  sexDat$data
        }else{
          data_sel <-  sexDat$data%>%
            filter(!!sym(paste0("above", outlLev1))==0)
        }
        if(nrow(data_sel)>0){
          # -------------------------- #
          # ---- Survival Module: ----
          # -------------------------- #
          # Run survival analyses:
          if ("sur" %in% Sections) {
            dir.create(file.path(PlotDir, "Survival"), showWarnings = FALSE)
            cat("Survival Running ------------------------------------------------\n")
            repout$surv[[sx]] <- Sur_main(data.core = sexDat$data,  DeathInformation = DeathInformation,
                                          Birth_Type = Birth_Type,
                                          PlotDir = glue::glue("{PlotDir}/Survival/"),XMAX = XMAX,
                                          models = models_sur, shape= shape, 
                                          minAge =minAge,firstyear = firstyear,
                                          outlLev1 =outlLev1, 
                                          Min_MLE = Min_MLE, MaxLE =  MaxLE,lastdead = lastdead,
                                          mindate = minDate, minNsur = minNsur, maxNsur = maxNsur, 
                                          minInstitution = minInstitution,uncert_death= uncert_death,
                                          minlx = minlx , MinBirthKnown = MinBirthKnown, 
                                          niter = niter, burnin = burnin, thinning = thinning, 
                                          nchain = nchain, ncpus = ncpus,
                                          plotname = glue("{taxa}_{speciesname}_{sx}") )
            if(sx == "Female" && length(repout$surv$Male$from0$summary$analyzed)==1){
              if(!is.null(PlotDir) & repout$surv$Male$from0$summary$analyzed& repout$surv$Female$from0$summary$analyzed ){
                pdf(file = paste0(PlotDir,"/Survival/",taxa,"_", speciesname,"_surMF.pdf", sep=""), width = 6, height = 6)
                plot(NULL, main = glue("{taxa}_{speciesname}"), 
                     ylim = c(min(repout$surv$Male$from0$bastaRes$surv$nocov, repout$surv$Female$from0$bastaRes$surv$nocov),
                              max(repout$surv$Male$from0$bastaRes$surv$nocov, repout$surv$Female$from0$bastaRes$surv$nocov)) , 
                     xlim = c(min(repout$surv$Male$from0$bastaRes$x, repout$surv$Female$from0$bastaRes$x),
                              max(repout$surv$Male$from0$relex$Age, repout$surv$Female$from0$relex$Age)),
                     xlab = 'Age', ylab = "Survivorship")
                polygon(y = c(repout$surv$Female$from0$bastaRes$surv$nocov[2,], rev(repout$surv$Female$from0$bastaRes$surv$nocov[3,])), x =c(repout$surv$Female$from0$bastaRes$x, rev(repout$surv$Female$from0$bastaRes$x)), col=rgb(1, 0, 0,0.5))
                polygon(y = c(repout$surv$Male$from0$bastaRes$surv$nocov[2,], rev(repout$surv$Male$from0$bastaRes$surv$nocov[3,])), x = c(repout$surv$Male$from0$bastaRes$x, rev(repout$surv$Male$from0$bastaRes$x)), col=rgb(0, 0, 1,0.25))
                dev.off()
              }
            }
            # print(repout$surv[[sx]]$summary$error)
            
          }
          # ------------------------------ #
          # ---- Reproduction module: ----
          # ------------------------------ #
          # Reproduction module list:
          if ("rep" %in% Sections) {
            cat("Reproduction Running ----------------------------------------\n")
            # Reproduction module list:
            Repse = Repsect
            if(sx == "Male"){Repse = Repsect%>%stringr::str_subset("litter", negate = T)}
            repout$repr[[sx]] <- Rep_main(coresubset= data_sel, collection, parent, move,  
                                          Repsect = Repse,
                                          BirthType_parent = Birth_Type, BirthType_offspring = Birth_Type, 
                                          Global = Global, minInstitution = minInstitution, 
                                          minNrepro = minNrepro, minNparepro =  minNparepro,
                                          parentProb_Dam = parentProb_Dam, 
                                          parentProb_Sire = parentProb_Sire,
                                          minNlitter = minNlitter, Nday = Nday,
                                          minNseas =  minNseas)
          }
          
          # ----------------------------- #
          # ---- Body weight module: ----
          # ----------------------------- #
          # Growth module list:
          if ("gro" %in% Sections) {
            dir.create(file.path(PlotDir, "Growth"), showWarnings = FALSE)
            cat("Growth Running ----------------------------------------------\n")
            #take age at maturity
            agemat = NULL
            if(length(repout$repr[[sx]])>0){
              if(repout$repr[[sx]]$summary$amat_analyzed){
                agemat = repout$repr[[sx]]$agemat$ageMat
              }
            }
            repout$weig[[sx]] <- Gro_Main(data = weights, coresubse = data_sel,
                                          taxa = taxa, species = species,
                                          Birth_Type = Birth_Type, 
                                          agemat = agemat, percentiles = c(2.5,97.5),
                                          PlotDir = glue::glue("{PlotDir}/Growth/"), type = "weight",
                                          uncert_date = uncert_date,
                                          MeasureType = MeasureType,
                                          minInstitution = minInstitution,
                                          minNgro = minNgro, minNIgro = minNIgro, 
                                          models = models_gro,
                                          mindate = minDate, plotname = glue("{taxa}_{speciesname}_{sx}") )
            print(repout$weig[[sx]]$Captive$wSummar$error)
          }
        }
      }
    }
  }else{
    warnings(glue::glue("No data for {species}"))
  }
  
  return(repout)
}

```

```{r examples-tx_report}
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSdirtest = dirname(file)
data <- Load_Zimsdata	(taxa = "Reptilia",
                       species = list(Reptilia = "All"),
                       ZIMSdir = ZIMSdirtest,
                       Animal = TRUE, tables = c("Collection","DeathInformation"))

Animal<- Prep_Animal(data[["Reptilia"]]$Animal, extractDate="2024/08/29"  )
PlotDir = paste0(tempdir(check = TRUE),'\\temp')
dir.create(PlotDir)

out <- tx_report(species = "Testudo hermanni", taxa = "Reptilia",
                 Animal, data$Reptilia$Collection, 
                 Birth_Type = "All", uncert_birth = 3500,uncert_death = 3500, 
                 DeathInformation =data$Reptilia$DeathInformation,
                 PlotDir = PlotDir,Sections = c('sur'),
                 sexCats = c("Male", "Female"),
                 models_sur = "GO", shape = "simple",
                 models_gro = "vonBertalanffy",
                 niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3
)

list.files(PlotDir)
unlink(PlotDir, recursive = TRUE)

```


```{r tests-tx_report}
test_that("tx_report works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSdirtest = dirname(file)
  data <- Load_Zimsdata	(taxa = "Reptilia",
                         species = list(Reptilia = "All"), ZIMSdir = ZIMSdirtest,
                         Animal = TRUE, tables = c("Collection","DeathInformation", "Weight"))
  Animal<- Prep_Animal(data[["Reptilia"]]$Animal, extractDate= "2024/08/29" )
  PlotDir = paste0(tempdir(check = TRUE),'\\temp')
  dir.create(PlotDir)
  
  out <- tx_report(species = "Testudo hermanni", taxa = "Reptilia",
                   Animal, data$Reptilia$Collection, MinBirthKnown = 0,minlx =0.5,minNIgro=40,
                   Birth_Type = "All", uncert_birth = 3500,uncert_death = 3500, 
                   DeathInformation =data$Reptilia$DeathInformation, weights =data$Reptilia$Weight,
                   niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3,
                   PlotDir = PlotDir, Sections = c('sur','gro'),
                   sexCats = c("Male", "Female"),
                   models_sur = "GO", shape = "simple",
                   models_gro = "vonBertalanffy"
  )
  expect_named(out, c('general', "summary", 'surv', 'weig'))
  expect_named(out$general, c('Nraw', 'Ndate', 'Nglobal', 'Nbirthtype', 'Nuncertbirth', 'Nalive', 'firstDate', 'maxAgeraw', 'extractdate'))
  expect_named(out$sur, c('Male', "Female"))
  expect_named(out$sur$Male, c("from0"))
  expect_named(out$sur$Male$from0, c("summary", "bastaRes", "DICmods", "relex", "Sur1", "Sur5", 'L90', 'L50'))
  expect_named(out$weig, c('Male', "Female"))
  expect_named(out$weig$Male$All, c('wSummar', "weightQ"))
  expect_named(out$weig$Female$All, c('wSummar', "weightQ"))
  expect_true(file.exists(paste(PlotDir, "Long_dist\\Reptilia_Testudo_hermanni_Male_LongThres.pdf", sep = '\\')))
  expect_true(file.exists(paste(PlotDir, "Survival\\9_Reptilia_Testudo_hermanni_Male_0_surcheck.pdf", sep = '\\')))
  expect_true(file.exists(paste(PlotDir, "Survival\\9_Reptilia_Testudo_hermanni_Male_0_surplot.pdf", sep = '\\')))
  expect_true(file.exists(paste(PlotDir, "Growth\\Reptilia_Testudo_hermanni_Male_All_outliers.png", sep = '\\')))
  expect_true(file.exists(paste(PlotDir, "Growth\\Reptilia_Testudo_hermanni_Male_All_growth.png", sep = '\\')))
  unlink(PlotDir, recursive = TRUE)
})
```




# Prepare Animal Data

This function check dates and add the following columns to animal data: MinBirthDate, MaxBirthDate, MinDeathDate, MaxDeathDate, EntryDate, EntryType, DepartDate, DepartType, Birth_Uncertainty, and Death_Uncertainty. It includes the following argument:

* `Animal`data frame including at least the following columns *AnimalAnonID*,  *BirthDate*, *BirthDateEstimateType*, *BirthDateEstimateStart*, *BirthDateEstimateEnd*, *BirthType*, *FirstAcquisitionDate*, *DeathDate*, *DeathDateEstimateType*, *DeathDateEstimateStart*, *DeathDateEstimateEnd*, *LastCommentEntryDate*, *BirthObserved*, *GlobalStatus*, and  *LastTXDate*
* `extractDate`  Latest possible date in the data: date used when individuals are still alive

```{r function-Prep_Animal}
#' Prepare Animal data
#' 
#' Check dates and add needed columns to animal data
#'
#' @param Animal  \code{data.frame} including at least the following columns *AnimalAnonID*,  *BirthDate*, *BirthDateEstimateType*, *BirthDateEstimateStart*, *BirthDateEstimateEnd*, *BirthType*, *FirstAcquisitionDate*, *DeathDate*, *DeathDateEstimateType*, *DeathDateEstimateStart*, *DeathDateEstimateEnd*, *LastCommentEntryDate*, *BirthObserved*, *GlobalStatus*, and  *LastTXDate*
#' @param minBirthDate  \code{character}: Earlier possible date: date used when minimum birth or death date unknown
#' @param extractDate  \code{character}: Latest possible date in the data: date used when individuals are still alive
#'
#' @return The checked and prepared dataset
#' 
#' @details
#' This function add the columns: MinBirthDate, MaxBirthDate, MinDeathDate, MaxDeathDate, EntryDate, EntryType, DepartDate, DepartType, Birth_Uncertainty, and Death_Uncertainty. It removes individuals for which dates are not chronologically meaningful (i.e. birth date after death date) and for which Birth_Uncertainty is higher than \code{uncert_birth}.
#' 
#' @importFrom lubridate as_date
#' @importFrom tidyr replace_na
#' @export
#'
#' @examples
Prep_Animal <- function(Animal, minBirthDate = "1900-01-01",
                        extractDate) {
  minBirthDate = as.character(minBirthDate)
  extractDate = as.character(extractDate)
  
  assert_that(is.data.frame(Animal))
  assert_that(Animal  %has_name% c("AnimalAnonID",  "BirthDate", "BirthDateEstimateType", "BirthDateEstimateStart", "BirthDateEstimateEnd","BirthObserved", "GlobalStatus",
                                   "BirthType", "FirstAcquisitionDate", "DeathDate", "DeathDateEstimateType", "DeathDateEstimateStart", "DeathDateEstimateEnd", "LastCommentEntryDate", "LastTXDate"))
  
  
  # Min and max Birth and death Date
  Animal <- Animal%>%
    mutate(
      MinBirthDate = case_when(
        BirthDateEstimateType == "ApproxBefore" ~ minBirthDate,
        BirthDateEstimateType == "ApproxAfter" ~ BirthDate,
        BirthDateEstimateType == "Undetermined" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "Indeterminate" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "Range" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "ApproxVariance" ~ BirthDateEstimateStart,
        BirthDateEstimateType == "" ~ BirthDateEstimateStart),
      MaxBirthDate = case_when(
        BirthDateEstimateType == "ApproxBefore" ~ BirthDate,
        BirthDateEstimateType == "ApproxAfter" ~ extractDate,
        BirthDateEstimateType == "Undetermined" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "Indeterminate" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "Range" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "ApproxVariance" ~ BirthDateEstimateEnd,
        BirthDateEstimateType == "" ~ BirthDateEstimateEnd
      ),
      MinDeathDate = case_when(
        DeathDateEstimateType == "ApproxBefore" ~ minBirthDate,
        DeathDateEstimateType == "ApproxAfter" ~ DeathDate,
        DeathDateEstimateType == "Undetermined" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "Indeterminate" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "Range" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "ApproxVariance" ~ DeathDateEstimateStart,
        DeathDateEstimateType == "" ~ DeathDateEstimateStart),
      MaxDeathDate = case_when(
        DeathDateEstimateType == "ApproxBefore" ~ DeathDate,
        DeathDateEstimateType == "ApproxAfter" ~ extractDate,
        DeathDateEstimateType == "Undetermined" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "Indeterminate" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "Range" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "ApproxVariance" ~ DeathDateEstimateEnd,
        DeathDateEstimateType == "" ~ DeathDateEstimateEnd),
      MinBirthDate = lubridate::as_date(MinBirthDate),
      MaxBirthDate = lubridate::as_date(MaxBirthDate),
      BirthDate = lubridate::as_date(BirthDate),
      MinDeathDate = lubridate::as_date(MinDeathDate),
      MaxDeathDate = lubridate::as_date(MaxDeathDate),
      DeathDate = lubridate::as_date(DeathDate),
      FirstAcquisitionDate = lubridate::as_date(FirstAcquisitionDate),
      LastTXDate  = lubridate::as_date(LastTXDate),
      MinBirthDate = coalesce(MinBirthDate, BirthDate),
      MaxBirthDate = coalesce(MaxBirthDate, BirthDate),
      MinDeathDate = coalesce(MinDeathDate, DeathDate),
      MaxDeathDate = coalesce(MaxDeathDate, DeathDate))
  
  
  
  
  Animal <- Animal%>%
    filter ((BirthDate >= MinBirthDate)%>% replace_na(TRUE),
            (BirthDate <= MaxBirthDate)%>% replace_na(TRUE),
            (DeathDate >= MinDeathDate)%>% replace_na(TRUE),
            (DeathDate <= MaxDeathDate)%>% replace_na(TRUE)
    )
  
  # Entry and Depart
  Animal <- Animal%>%
    mutate(EntryDate = FirstAcquisitionDate,
           EntryType = ifelse(BirthObserved == "NO", "T", "B"),
           DepartDate = ifelse(is.na(DeathDate), LastTXDate, DeathDate),
           DepartDate = ifelse(GlobalStatus == "Alive", lubridate::as_date(extractDate), DepartDate),
           DepartType = ifelse(GlobalStatus == "Dead" | !is.na(DeathDate), "D", "C"),
           EntryDate = lubridate::as_date(EntryDate),
           DepartDate = lubridate::as_date( DepartDate))
  
  
  #Correct Entry Dates
  ID = which (Animal$EntryDate < Animal$MaxBirthDate)
  Animal$MaxBirthDate[ID]= Animal$EntryDate[ID] 
  
  ID = which (Animal$EntryType == "B" & Animal$EntryDate != Animal$BirthDate)
  Animal$EntryDate[ID] = Animal$MaxBirthDate[ID]
  
  ID = which (Animal$EntryType == "B" & is.na(Animal$EntryDate))
  Animal$EntryDate[ID] = Animal$MaxBirthDate[ID]
  
  
  
  #Correct Depart Dates
  Animal$DepartDate[Animal$DepartType == "D" & is.na(Animal$DeathDate)] = Animal$LastTXDate[Animal$DepartType == "D" & is.na(Animal$DeathDate)]
  Animal$DepartType[Animal$DepartType == "D" & is.na(Animal$DeathDate)] = "C"
  
  ID = which(is.na(Animal$DepartDate))
  Animal$DepartDate[ID] = Animal$LastCommentEntryDate[ID]
  Animal$DepartType[ID] = "C"
  
  #check Chronology in dates
  Animal <- Animal%>%
    filter ((BirthDate <= FirstAcquisitionDate)%>% replace_na(TRUE),
            (FirstAcquisitionDate <= EntryDate)%>% replace_na(TRUE),
            (EntryDate <= DepartDate)%>% replace_na(TRUE),
            (DepartDate <= DeathDate)%>% replace_na(TRUE),
            (DeathDate >= LastTXDate)%>% replace_na(TRUE),
            (BirthDate <= DeathDate)%>% replace_na(TRUE),
            (DeathDate >= FirstAcquisitionDate)%>% replace_na(TRUE),
            (BirthDate <= LastTXDate)%>% replace_na(TRUE),
            (FirstAcquisitionDate <= LastTXDate)%>% replace_na(TRUE))%>%
    dplyr::select (-c(DeathDateEstimateStart, DeathDateEstimateEnd, BirthDateEstimateEnd, BirthDateEstimateStart)) %>%
    mutate(Birth_Uncertainty =  MaxBirthDate-MinBirthDate,
           Death_Uncertainty =  MaxDeathDate-MinDeathDate)
  
  return(Animal)
}
```

```{r examples-Prep_Animal}
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSdirtest = dirname(file)

data <- Load_Zimsdata	(taxa = "Reptilia", 
                       species = list(Reptilia = "All"),
                       ZIMSdir = ZIMSdirtest,
                       Animal = TRUE)

Animal <- Prep_Animal(data$Reptilia$Animal, extractDate = lubridate::as_date("2023/12/23"))

unlink(ZIMSdirtest, recursive = FALSE)
```

```{r tests-Prep_Animal}
test_that("Prep_Animal works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSdirtest = dirname(file)
  
  data <- Load_Zimsdata	(taxa = "Reptilia",
                         species = list(Reptilia = "All"),
                         ZIMSdir = ZIMSdirtest,
                         Animal = TRUE)
  
  Animal <- Prep_Animal(data$Reptilia$Animal, extractDate = "2023/12/23")
  expect_named(Animal, c("AnimalAnonID", "Class", "Order", "Family", 'SpeciesName', "CommonName", "IUCNRedList", "CITES", "CITESE", "FirstHoldingInstitution", "FirstCollectionScopeType", "LastHoldingInstitution", "LastCollectionScopeType", "AnyLocalCollectionFlag", "LatitudeZone", "BirthDate", "BirthDateEstimateType", "BirthType", "BirthObserved", "FirstAcquisitionDate", "SexType", "PhysicalMoveCount", "DeathDate", "DeathDateEstimateType", "GlobalStatus", "AnimalType", "LastCommentEntryDate", "LastTXDate", 'binSpecies', "MinBirthDate", "MaxBirthDate", "MinDeathDate", "MaxDeathDate",  "EntryDate", "EntryType", "DepartDate", "DepartType", "Birth_Uncertainty", "Death_Uncertainty"))
  
})
```





# Extract Data

This function extracts the data of the specified species that fill the condition on minimum date and global collections. It includes the following argument:

* `speciesname` latin name of the species selected
* `coresubset`data.frame including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate* (\code{date}), *EntryDate* (\code{date}), *MaxBirthDate* (\code{date}), *MinBirthDate*, *EntryType*, *DepartType*, *DepartFrom*, *LastTXDate*, *DeathDate*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *GlobalStatus*, *LastCollectionScopeType*, and *FirstCollectionScopeType*
* `collection` data.frame including at least the following columns*RecordingInstitution*, *ChangeDate*, *ScopeType*, and *AnimalAnonID*.
* `uncert_birth` Maximum uncertainty accepted for birth date, in days
* `Birth_Type` Captive, Wild, or All
* `minDate`: Earlier date to include data
* `extractDate`: Date of data extraction
* `Global` Whether only individuals belonging to global collections should be used.


The output is a list including:
* The subseted dataset
* a summary of the data used:
- Nraw : Raw number of individuals selected from global collections
- Ndate : Number of individuals with an entry date posterior to the minimum date
- Nglobal: Number of individuals selected from global collections
- Nalive: Number of individuals still alive
- firstDate: Date of first record
- maxAgraw: Maximum observed age



```{r function-select_species}
#' Extract data
#' 
#' Extract data of the specified species that fill the condition on minimum date and global collections
#'
#' @param speciesname \code{character} latin name of the species selected
#' @param coresubset  \code{data.frame} including at least the following columns *AnimalAnonID*, *binSpecies*, *BirthDate* (\code{date}), *DepartDate* (\code{date}), *EntryDate* (\code{date}), *MaxBirthDate* (\code{date}), *MinBirthDate* (\code{date}), *MaxDeathDate* (\code{date}), *MinDeathDate* (\code{date}), *EntryType*, *DepartType*,  *LastTXDate*, *DeathDate*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *GlobalStatus*, *LastCollectionScopeType*, and *FirstCollectionScopeType*
#' @param collection \code{data.frame} including at least the following columns*RecordingInstitution*, *ChangeDate*, *ScopeType*, and *AnimalAnonID*.
#' @param minDate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param uncert_birth \code{numeric}: Maximum uncertainty accepted for birth dates, in days
#' @param Birth_Type \code{character} Captive, Wild, or All. Default =  "Captive"
#' @param extractDate \code{character 'YYYY-MM-DD'} Date of data extraction
#' @param Global \code{logical} Whether only individuals belonging to global collections should be used.
#'
#' @return The output of a list including:
#' * a summary of the data used:
#'- Nraw : Raw number of individuals selected from global collections
#'- Ndate : Number of individuals with an entry date posterior to the minimum date
#'- Nglobal: Number of individuals selected from global collections
#'- Nbirthtype: Number of individuals selected from birth type
#'- Nuncertbirth: Number of individuals selected from uncertainty in birth
#'- Nalive: Number of individuals still alive
#'- firstDate: Date of first record
#'- maxAgeraw: Maximum observed age
#'* The subseted dataset
#' @export
#'
#' @examples
select_species <- function(speciesname, coresubset, collection, uncert_birth = 365,                                     Birth_Type = "Captive",
                           minDate, extractDate, Global = TRUE) {
  
  minDate = lubridate::as_date(minDate)
  extractDate = lubridate::as_date(extractDate)
  assert_that(Birth_Type %in% c("Captive", "Wild", "All"))
  assert_that(is.numeric(uncert_birth))
  assert_that(is.data.frame(coresubset))
  assert_that(is.data.frame(collection))
  assert_that(coresubset  %has_name% c("AnimalAnonID", "binSpecies", "BirthDate", "DepartDate",
                                       "EntryDate", "MaxBirthDate", "MinBirthDate",
                                       "MaxDeathDate", "MinDeathDate", "EntryType", "DepartType",
                                       "LastTXDate", "DeathDate", "FirstHoldingInstitution", 
                                       "LastHoldingInstitution","GlobalStatus",
                                       "LastCollectionScopeType","FirstCollectionScopeType"))
  assert_that(collection  %has_name% c("RecordingInstitution", "ChangeDate", 
                                       "ScopeType", "AnimalAnonID"))
  assert_that(is.logical(Global))
  # Select Species
  coresubset0 <- coresubset%>%
    filter(binSpecies == speciesname)
  
  # Subset by min date
  coresubset1 <- coresubset0%>%
    filter(DepartDate >= minDate)
  
  
  summar = list(Nraw = nrow(coresubset0),
                Ndate = nrow(coresubset1),
                Nglobal = 0,
                Nbirthtype = 0,
                Nuncertbirth = 0,
                Nalive = 0,
                firstDate = NULL,
                maxAgeraw = NULL,
                extractdate = extractDate)
  
  if(summar$Ndate>0){
    if(Global){
      # Keep only Global individuals
      indglobloc = coresubset1%>%
        filter(LastCollectionScopeType == "Local",
               FirstCollectionScopeType == "Global"
        )
      if(nrow(indglobloc)>0){
        indglobloc = indglobloc%>%
          left_join(collection%>%
                      select(RecordingInstitution, ChangeDate, ScopeType, AnimalAnonID),
                    by = c("AnimalAnonID"))%>%
          group_by(AnimalAnonID, ScopeType)%>%
          mutate(maxtime = max(ChangeDate)) %>%
          ungroup()%>%
          filter(maxtime  == ChangeDate)
        #Warnings: there are sometimes 2 institutions for 1 individual for same date  ###!!! THIS SHOULD NOT HAPPEN
        indloc<-indglobloc%>%
          filter(ScopeType=="Local")%>%
          select(-RecordingInstitution)%>%
          left_join(indglobloc%>%
                      filter(ScopeType=="Global")%>%
                      select(AnimalAnonID, RecordingInstitution)%>%
                      group_by(AnimalAnonID )%>%
                      summarise(RecordingInstitution = min(RecordingInstitution)),  ###!!! TO BE CHANGED
                    by = "AnimalAnonID")%>%
          mutate(globStat ="Undetermined (Lost to follow up)",
                 lastInst = as.character(RecordingInstitution),
                 LastCollectionScopeType = "now Global",
                 DepartType = "C",
                 DepartFrom = "collections",
                 DeathDate = lubridate::as_date(NA),
                 LastTXDate = lubridate::as_date(ChangeDate),
                 DepartDate = lubridate::as_date(ChangeDate))%>%
          select(-ChangeDate, -ScopeType,-maxtime, -RecordingInstitution )%>%
          distinct()
      }else{indloc<-indglobloc}
      
      
      
      
      data_sel <- coresubset1%>%
        rows_update(indloc, by="AnimalAnonID")%>%
        mutate()%>%
        filter(FirstCollectionScopeType == "Global")
      summar$Nglobal = nrow(data_sel)
    }else { data_sel <- coresubset1}
    
    
    if (summar$Nglobal > 0) {  
       # Subset by birth type
      if (Birth_Type != "All"){
        data_sel <- data_sel  %>%
          filter(stringr::str_detect(BirthType, pattern = Birth_Type))
      }
      summar$Nbirthtype = nrow( data_sel)
      
      # Subset by uncertainty in birth
      data_sel1 <- data_sel %>%
        tidyr::drop_na(BirthDate)%>%
        filter((Birth_Uncertainty <= uncert_birth)%>% replace_na(TRUE))
      summar$Nuncertbirth = nrow( data_sel1)
      
      # Number alive by extraction date:
      summar$Nalive <- nrow(data_sel1%>%
                              filter(DepartDate == extractDate , 
                                     DepartType == "C"))
      
      # First record:
      summar$firstDate <- min(data_sel1$EntryDate)
      
      # Max Ages:
      data_age <- data_sel1%>%
        mutate(tempAges = as.numeric(DepartDate - BirthDate) / 365.25,
               tempAlive = as.numeric(DepartDate - EntryDate) / 365.25)
      
      
      summar$maxAgeraw <- max(c(data_age$tempAges,data_age$tempAlive))
    } 
    
  }else{data_sel1 = tibble()}
  
  
  sexDat <- list(summary = summar, data = data_sel1)
  
  return(sexDat)
}
```

```{r examples-select_species}
data(core)
data(collection)
out<- select_species(speciesname = "Testudo hermanni", coresubset = core, collection,
                     minDate = "1980-01-01", extractDate = "2023-01-01")
out$summary
out$data
```

```{r tests-select_species}
test_that("select_species works", {
  data(core)
  data(collection)
  out<- select_species (speciesname = "Testudo hermanni",
                        coresubset = core, collection,
                        minDate = "1980-01-01", extractDate = "2023-01-01")
  expect_named(out, c("summary",  "data"))
  expect_named(out$summary, c('Nraw', 'Ndate', 'Nglobal', 'Nbirthtype', 'Nuncertbirth', 'Nalive', 'firstDate', 'maxAgeraw', 'extractdate'))
  expect_equal(out$summary$Nraw,1000)
  expect_equal(out$summary$Ndate,996)
  expect_equal(out$summary$Nalive,0)
  expect_named(out$data, names(core))
  expect_equal(nrow(out$data),out$summary$Nuncertbirth)
  expect_true(is.numeric(out$summary$maxAgeraw))
  expect_true(is.date(out$summary$firstDate))
  
})
```



# Gap analysis in longevity

`select_Longthreshold()` runs a gap analysis on the distribution of longevity and gives the threshold value to use in this distribution to avoid having gaps in longevity. It plots the distribution of longevities with gaps. It can focus on a given sex using the following arguments:

*  `data.core`including at least the following columns *Birth.Date*, *Depart.Date*, *Entry.Date*, and *SexType*
* `sexCats` Male, Female or All
* `PlotDir` Directory to save the plots
* `maintitle` name of the graph to be saved
* ` minN` Minimum number of individuals

It returns the data with the selected sex and additional columns showing which individuals are above the percentiles 95%, 99% and 99.9%
and a summary list including the threshold value selected for the distribution of longevity.

```{r function-select_Longthreshold}
#' Gap analysis in longevity
#' 
#' Run a gap analysis on the distribution of longevity and give the threshold value to use in this distribution to avoid having gaps in longevities. Plot the distribution of longevities with gaps.
#' 
#' @param data.core \code{data.frame} including at least the following columns *Birth.Date* (\code{date}), *Depart.Date* (\code{date}), *Entry.Date* (\code{date}), and *SexType*
#' @param sexCats \code{character} Male, Female or All Default =  "All"
#' @param PlotDir \code{character} Directory to save the plots.
#' @param maintitle \code{character} name of the graph to be saved. Default = ""
#' @param minN \code{numeric} Minimum number of individuals. Default = 50
#'
#' @return A list including
#' * the data with the selected sex and additional columns showing which individuals are above the percentiles 95%, 99% and 99.9%
#' * A summary list with:
#' - Sex = the sex selected
#' - Nselect: the number of individuals of this sex
#' - Nlifespan : the number of individuals with estimated lifespan (i.e. estimated birth dates, censored individuals are also included)
#' - GapThresh : The threshold value selected for the distribution of longevity
#' - NThres : the number of individuals selected using this threshold
#' 
#' @export
#'
#' @examples
select_Longthreshold <- function(data.core,  sexCats = "All", 
                                 PlotDir = NULL, maintitle = '', minN = 50) {
  
  assert_that(is.data.frame(data.core ))
  assert_that(data.core  %has_name% c("BirthDate", "DepartDate",
                                      "EntryDate", "SexType"))
  assert_that(is.character(sexCats))
  assert_that(length(sexCats)==1, 
              msg = "You can chose only one sex category")
  assert_that(all(sexCats %in% c("Female", "Male", "All")))
  if(!is.null(PlotDir)){
    assert_that(is.character(PlotDir))
    checkmate::assert_directory_exists(PlotDir)}
  
  coresubset <- data.core%>%
    mutate(
      #longevities:
      lifespans = as.numeric(DepartDate - BirthDate) / 365.25,
      # Calculate time alive:
      alive = as.numeric(DepartDate - EntryDate) / 365.25)
  
  # Output table:
  outTab <- tibble( 
    Sex = sexCats,
    Nselect = nrow(coresubset),
    Nlifespan = 0,
    GapThresh = NA, 
    NThres = 0
  ) 
  
  if(sexCats %in% c('Male', 'Female')){
    coresex <- coresubset%>%filter(SexType ==sexCats)
  }else{coresex = coresubset}
  
  if(nrow(coresex)>0){
    # Check longevities:
    
    quant = quantile (coresubset$lifespans,c(0.95,0.99,0.999))
    
    coresex <-  coresex%>%
      mutate(`above95`= if_else(lifespans> quant[1], 1, 0),
             `above99`= if_else(lifespans> quant[2], 1, 0),
             `above99.9`= if_else(lifespans> quant[3], 1, 0)
      )
    
    # Find gaps in longevities:
    corelong <- coresex%>%tidyr::drop_na(lifespans)
    outTab$Nlifespan <- nrow(corelong)
    
    
    if (nrow(corelong) > minN) {
      gapsAlive <- find_gaps(corelong$alive, 
                             maxAlive = quantile(corelong$alive, 0.5, na.rm = TRUE), 
                             plot = F)
      if (nrow(gapsAlive) > 0) {
        maxAlive <-  gapsAlive$iniAge[1]
      } else {
        maxAlive <- max(corelong$alive, na.rm = TRUE)
      }
      if (maxAlive < 5) {
        maxAlive <- 5
      } else if (maxAlive > 50) {
        maxAlive <- 50
      }
      pdf(file = glue::glue("{PlotDir}/{maintitle}_LongThres.pdf"), width = 5, height = 5)
      
      par(mar = c(4, 4, 1, 1))
      gaps <- find_gaps(corelong$lifespans, maxAlive = maxAlive, plot = T,
                        main = maintitle, 
                        xlab = "")
      ngap = nrow( gaps)
      
      if (nrow(gaps) > 0) {
        allev <- 0
        while(allev < 3 & ngap>0) {
          allev <- allev + 1
          qlev <- c("99.9", "99", "95")[allev]
          abcol <- sprintf("above%s", qlev)
          gaps <- find_gaps(corelong$lifespans[corelong[[abcol]] == 0], 
                            maxAlive = maxAlive, plot = T,
                            main = paste(qlev, "%"), 
                            xlab = "")
          ngap = nrow( gaps)
        }
        outTab$GapThresh <-as.numeric(qlev)
        
        if (allev < 3) {
          for (ll in (allev + 1):3) {
            qlev <- c("99.9", "99", "95")[ll]
            abcol <- sprintf("above%s", qlev)
            plot(c(0, 1), c(0, 1), col = NA, axes = FALSE, xlab = "", 
                 ylab = "", main = paste(qlev, "%"))
            text(0.5, 0.5, "No gaps", cex = 2)
            box()
          }
        }
      } else {
        outTab$GapThresh <-100
      }
      outTab$NThres <- nrow(coresex)
      
      dev.off()
      
    } 
    
    
  }
  return(list(summar = outTab, data = coresex) )
}



```

```{r examples-select_Longthreshold}
TempDir <- paste0(tempdir(check = TRUE),'\\temp')
dir.create(TempDir)
data(core) #### CHANGE DATASET WITH ONE EXCLUDING ABOVE95 99 99.9
out <- select_Longthreshold (data.core = core,  sexCats = "All", 
                             PlotDir = TempDir, maintitle = "Testudo_hermanni")
list.files(TempDir)
#remove temporary folder
unlink(TempDir, recursive = TRUE)
```

```{r tests-select_Longthreshold}
test_that("select_Longthreshold works", {
  TempDir <- paste0(tempdir(check = TRUE),'\\temp')
  dir.create(TempDir)
  data(core) #### CHANGE DATASET WITH ONE EXCLUDING ABOVE95 99 99.9
  out <- select_Longthreshold (data.core = core,  sexCats = "All", 
                               PlotDir = TempDir, maintitle = "Testudo_hermanni")
  expect_true(file.exists(paste(TempDir, 'Testudo_hermanni_LongThres.pdf', sep = '\\')))
  #remove temporary folder
  unlink(TempDir, recursive = TRUE)
  expect_named(out, c("summar",  "data"))
  expect_true("above95" %in% names(out$data))
  expect_named(out$summar, c("Sex", 'Nselect', "Nlifespan", "GapThresh", "NThres"))
  expect_true(out$summar$Sex == "All" )
  expect_equal(out$summar$Nselect, nrow(core))
  unlink(TempDir, recursive = TRUE)
})
```


## Find gaps in a continuous variable

`find_gaps` Looks for gaps within a continuous variable. Number are rounded and gaps are found if one number is not represented. Gaps are returned only if the length of the gaps is 20% higher than the starting age of this gap. It uses the following arguments:

* `x` variable to analyze
* `maxAlive` Return gaps higher than this maximum, only. Default = NA
* other arguments pass to `hist()`

It returns a data frame where each line is a gap described by its initial/starting age, its final/ending age and its length

```{r function-find_gaps}
#' Find gaps in an integer variable
#' 
#' Looks for gaps within a continuous variable. Number are rounded and gaps are found if one number is not represented. Gaps are returned only if the length of the gaps is 20% higher than the starting age of this gap.
#'
#' @param x \code{vector of numeric} variable to analyze
#' @param maxAlive \code{numeric} Return gaps higher than this maximum, only. Default = NA
#' @param plot \code{logical} whether to actually plot the histogram
#' @param ... arguments pass to hist()
#'
#' @return
#' A data frame where each line is a gap described by its initial/starting age, its final/ending age and its length
#' 
#' @export
#'
#' @importFrom graphics abline box hist par text
#'
#' @examples
find_gaps <- function(x,maxAlive = NA, plot = FALSE,...) {
  
  assert_that(is.numeric(x))
  if(is.na(maxAlive)){
    maxAlive = max(x)
  }else{
    assert_that(is.numeric(maxAlive))}
  
  
  breaks <- floor(min(x, na.rm = TRUE)):ceiling(max(x, na.rm = TRUE))
  hs <- hist(x, breaks = breaks, plot = plot, ...)
  xc <- hs$counts
  xc[hs$counts > 0] <- 1
  
  fin <- FALSE
  i <- 1
  n <- length(xc)
  gaps <- tibble(iniAge= numeric(1), finAge= numeric(1), Gap= numeric(1))
  while(!fin & i < n) {
    id0st <- which(xc[i:n] == 0)[1]
    if (!is.na(id0st)) {
      id0fin <- which(xc[(i + id0st - 1):n] == 1)[1] - 1
      gaps <- rbind(gaps, c(hs$breaks[i + id0st - 1], 
                            hs$breaks[i + id0st + id0fin - 2], id0fin))
      i <- i + id0st + id0fin - 1
    } else {
      fin <- TRUE
    }
  }
  if(is.na(maxAlive))(maxAlive = max(x))
  
  idgap <- gaps%>%
    filter(Gap/iniAge > 0.2 ,
           finAge  >= maxAlive)
  
  if (nrow(idgap) > 0 & plot) {abline(v = idgap$iniAge, col = 2)}
  return(idgap)
}
```

```{r examples-find_gaps}
x = runif(10,0,40)
out<-find_gaps(x,maxAlive = 5, plot = FALSE)
```

```{r tests-find_gaps}
test_that("find_gaps works", {
  x = runif(10,0,40)
  out<-find_gaps(x,maxAlive = 5, plot = FALSE)
  expect_named(out,c('iniAge', 'finAge', 'Gap'))
  expect_equal(out$finAge-out$iniAge+1, out$Gap)
})
```



```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_select.Rmd", vignette_name = "Data Selection")
```

