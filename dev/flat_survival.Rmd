---
title: "flat_additional.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(tidyverse)
library(glue)
# library(extractZIMS)

```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Taxon profile: Main survival Analysis

`Sur_main()` runs the survival analysis (see next function : `Sur_ana()`) and the remaining life expectancy analysis (see `Sur_relex()`) on each sex category. In addition to the arguments of `Sur_ana()`, `Sur_main()` includes the following arguments:

* `data.core`the core data of the species from ZIMS including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, *BirthType* and *RelevantDeathInformationType*.
* `DeathInformation` data.frame including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
* `Birth_Type`: When separated the analysis by sex category, the birth type to be selected: Captive, Wild, or All
* `PlotDir`: Directory to save the plots of the best models

It return a list per sex category including:
* a summary of the data used
* the basta fit of the best model
* the DIC table comparing the different fit of the models
* the remaining life expectancy per age

```{r function-Sur_main}
#' Main survival analysis for taxon profiles
#' 
#' Run the survival analysis per sex and per birth type
#'
#' @param data.core \code{data.frame} including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param Birth_Type \code{character} When separated the analysis by sex category, the birth type to be selected: Captive, Wild, or All Default =  "All"
#' @param outlLev1 \code{numeric} Start threshold used to selected for the data: 100%, 99.9, 99 or 95%
#' @param models \code{vector of characters} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param XMAX \code{numeric} Maximum possible age. Default = 120
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death date, in days
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param minNsur \code{numeric} Minimum number of individual records needed to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the survival analysis. Default = 2
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#' @param firstyear \code{logical} Whether to do the analysis only on first year. Default = FALSE
#' @param minlx  \code{numeric} between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis. Default = 0.1
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data. Default = 0.3
#' @param Min_MLE \code{numeric} Goodness of fit: Minimum survivorship at Mean life expectancy
#' @param MaxLE \code{numeric} Goodness of fit: Maximum remaining life expectancy at max age
#' @param niter  \code{numeric}. number of MCMC iterations to run. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#' @param PlotDir \code{character} Directory to save the plots. Default = NULL, no plot is saved
#' @param plotname \code{character} Name used to save the plot. Default = ""
#' @param lastdead  \code{logical} Whether the longest lived individuals should be considered dead. Default = FALSE
#' 
#' @return The output of a list including per sex categories:
#' * a summary of the data used:
#'- NGlobal: Number of captive born individuals selected from global collections
#'- NBasta: Number of data (individuals) selected for the BaSTA/survival analysis
#'- Ndead:Number of individuals with known age of death used in the BaSTA/survival analysis
#'- maxAge: Maximum age of known age individuals
#'- maxAlive:Maximum number of years spent ex situ
#'- lxMin:Minimum survivorship reached with the raw Kaplan-Meier model
#'-  OutLev: threshold selected for the distribution of  time spent alive: 100%, 99.9, 99 or 95%
#'- a logical indicated if the survival analysis was performed
#'-  If the survival analysis was not performed, an error and its number (Nerr) are returned: The possibility for  this functions are: 2/Nuncertdeath < minNsur; 3/NBasta = 0; 4/ %known births < MinBirthKnown; 5/Data from 1 Institution; 6/Nbasta < minNsur; 7/Nbasta > maxNsur; 8/no DIC from Basta; 9/Kaplan-Meier does not fit; 10/Min(Life_exp) >= MaxLE; 11/"lx_MLE < Min_MLE"; 12/"lxmin > minlx"; 13/Kaplan-Meier does not fit
#'- A goodness of fit tested the trend in the residuals between the model prediction and the kaplan meier estimator
#'* the basta fit of the best model
#'* the DIC table comparing the different fit of the models
#'* the estimated remaining life expectancy per age
#'* the age at which 90% of the population died
#'* the estimated probability to live one year more
#'* the estimated probability to live five years more
#' If PlotDir is filled, 2 plots are produced: one showing the outliers removed from the data, and one showing the fit of the model on the data.
#'
#' @export

#' @examples
Sur_main <- function(data.core,   DeathInformation, Birth_Type = "All",
                     models = "GO", shape= "simple", firstyear =FALSE,
                     outlLev1 = NA,minAge =0,
                     mindate = "1980-01-01", minNsur = 50, maxNsur = NULL,
                     minInstitution = 2,uncert_death=365,
                     minlx = 0.1, MinBirthKnown = 0.3, 
                     Min_MLE = 0.1, MaxLE = 2,XMAX=120,lastdead = FALSE,
                     niter = 25000, burnin = 5001, thinning = 20, nchain = 3, 
                     ncpus = 2, PlotDir = NULL, plotname = '') {
  
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(data.core))
  assert_that(data.core  %has_name% c("AnimalAnonID", "BirthDate", "DepartDate",
                                      "EntryDate", "MaxBirthDate", "MinBirthDate",
                                      "EntryType", "DepartType", "FirstHoldingInstitution", 
                                      "LastHoldingInstitution", "SexType", "BirthType"))
  assert_that(is.data.frame(DeathInformation))
  assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  if(!is.na(outlLev1)){
    assert_that(is.numeric(outlLev1))
    assert_that(outlLev1 <= 100)
  }else(outlLev1 = 100)
  assert_that(is.numeric(minAge))
  assert_that(is.numeric(minNsur))
  assert_that(is.numeric(uncert_death))
  if(!is.null(maxNsur)) assert_that(is.numeric(maxNsur))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(Min_MLE))
  assert_that(is.numeric(MaxLE))
  assert_that(MinBirthKnown <1)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models))
  assert_that(is.character(plotname))
  assert_that(all(models %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  assert_that(is.character(Birth_Type))
  assert_that(length(Birth_Type) == 1, msg = "You can use only one birth type for each sex analysis")
  assert_that(Birth_Type %in% c("Captive", "Wild", "All"))
  if(!is.null(PlotDir)){
    checkmate::assert_directory_exists(PlotDir)
  }
  out = list()
  # Run analyses:
  if (Birth_Type != "All"){
    sexData<- data.core %>%
      filter(stringr::str_detect(BirthType, pattern = Birth_Type))
  }else{sexData<- data.core}
  # Survival Analysis
  for(j in 1:length(minAge)){
    
    out[[paste0("from",minAge[j])]]<- Sur_ana(sexData, DeathInformation = DeathInformation,
                                              outlLev1 = outlLev1, 
                                              models = models, shape = shape,
                               mindate = mindate,      uncert_death = uncert_death, 
                               lastdead = lastdead, minAge = minAge[j],
                               minNsur = minNsur, maxNsur = maxNsur,
                               minInstitution = minInstitution,
                               MinBirthKnown = MinBirthKnown, 
                               niter = niter, burnin = burnin, thinning = thinning, 
                               nchain = nchain, ncpus = ncpus) 
  out[[paste0("from",minAge[j])]] <- append( out[[paste0("from",minAge[j])]], 
                                             list(relex = NULL, Sur1 = NULL, Sur5 = NULL, L90 = NULL, L50 = NULL))
  
  
  if (out[[paste0("from",minAge[j])]]$summary$analyzed) {
    
    out[[paste0("from",minAge[j])]]  <-Sur_out(out[[paste0("from",minAge[j])]] , shape= shape, 
                                XMAX=XMAX,ncpus = ncpus, minAge = minAge[j],
                                PlotDir = PlotDir, plotname = paste0(plotname,"_",minAge[j]),
                               minlx = minlx, Min_MLE = Min_MLE, MaxLE = MaxLE
    )
  }
  }
  if(firstyear){
  
  out[["firstyear"]]<- Sur_ana1(sexData, DeathInformation = DeathInformation, 
                                models = models, shape = shape,
                                mindate = mindate,      uncert_death = uncert_death, 
                                uncert_birth = 30, 
                                minNsur = minNsur, maxNsur = maxNsur, minInstitution = minInstitution,
                                niter = niter, burnin = burnin, thinning = thinning, nchain = nchain, ncpus = ncpus) 
  out[["firstyear"]] <- append(out[["firstyear"]], list(Sur1 = NULL))
  if (out[["firstyear"]]$summary$analyzed) {
    
    out[["firstyear"]] <-Sur_out(out[["firstyear"]], shape= shape, 
                                 XMAX=XMAX,ncpus = ncpus, firstyear = TRUE,
                                 PlotDir = PlotDir, plotname = paste0(plotname,"_1yo"),
                                 minlx = minlx,Min_MLE = Min_MLE, MaxLE = MaxLE
    )
  }
  }
  return(out)
}

```

```{r examples-Sur_main}
data(core)
data(deathinformation)
out <- Sur_main(core, DeathInformation = deathinformation, Birth_Type = "All",
                models = "GO", shape = "simple",
                niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
```

```{r tests-Sur_main}
test_that("Sur_main works", {
  data(core)
  data(deathinformation)
  out <- Sur_main(core, DeathInformation = deathinformation, Birth_Type = "Captive", 
                  models = "LO", shape = "bathtub",
                  niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
  expect_named(out, c("from0"))
  expect_named(out$from0, c("summary",  "bastaRes", "DICmods", "relex", 'Sur1', 'Sur5', 'L90', 'L50'))
  expect_named(out$from0$summary, c("NSelect", 'NUncertdeath', "NBasta", "Ndead", "maxAge", "maxAlive", "lxMin", "outLev", "analyzed", "Nerr", "error", "Gof_KM_coeff1", "Gof_KM_coeff2"))
  expect_named(out$from0$DICmods, c("models", "DIC"))
})
```

# Survival Analysis

This functions runs basta models on the data after checking conditions for correct convergence of the models. It includes the following arguments:
* `sexData`including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*.
* `DeathInformation` data.frame including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
* `models` names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
* `uncert_death` Maximum uncertainty accepted for death date, in days
* ` minNsur` Minimum number of individual records needed to run the survival analysis
* `maxNsur` Maximum number of individual records to run the survival analysis
* `minlx` Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis
* `MinBirthKnown` Minimum proportion of individuals with a known birth month in the data
* `minInstitution` Minimum number of institutions that should hold records to run the survival analysis

It return a list including:
* a summary of the data used
* the basta fit of the best model
* the DIC table comparing the different fit of the models

```{r function-Sur_ana}
#' Survival Analysis
#' 
#' Run basta models on the data after checking conditions for correct convergence of the models
#'
#' @param sexData \code{data.frame} including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param outlLev1 \code{numeric} Start threshold used to selected for the data: 100%, 99.9, 99 or 95%
#' @param models \code{vector of characters} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param minAge \code{numeric} Age at which the analysis should start.  see ?basta for more information. Default = 0
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death date, in days
#' @param minNsur \code{numeric} Minimum number of individual records needed to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the survival analysis. Default = 1
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data. Default = 0.3
#' @param niter  \code{numeric}. number of MCMC iterations to run. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#' @param lastdead  \code{logical} Whether the longest lived individuals should be considered dead. Default = FALSE
#'
#' @return The output of a list including:
#' * a summary of the data used:
#'- NSelect: Number of individuals selected from filters
#'- NUncertdeath: Number of individuals selected after filter uncertainty in death
#'- NBasta: Number of data (individuals) selected for the BaSTA/survival analysis
#'- Ndead:Number of individuals with known age of death used in the BaSTA/survival analysis
#'- maxAge: Maximum age of known age individuals
#'- maxAlive:Maximum number of years spent ex situ
#'- lxMin:Minimum survivorship reached with the raw Kaplan-Meier model
#'-  OutLev: threshold selected for the distribution of  time spent alive: 100%, 99.9, 99 or 95%
#'- a logical indicated if the growth analysis was performed
#'-  If the survival analysis was not performed, an error and its number (Nerr) are returned: The possibility for  this functions are: 2/Nuncertdeath < minNsur; 3/lxMin > minlx; 4/NBasta = 0; 5/ %known births < MinBirthKnown; 6/Data from 1 Institution; 7/Nbasta < minNsur; 8/Nbasta < maxNsur; 9/no DIC from Basta.
#'* the basta fit of the best model
#'* the DIC table comparing the different fit of the models
#' 
#' @export
#'
#' @examples
Sur_ana <- function(sexData, DeathInformation, outlLev1 = 100, models = "GO", shape = "simple",
                    minAge = 0, mindate = "1980-01-01", minNsur = 50,maxNsur = NULL, uncert_death=365,
                    MinBirthKnown = 0.3, minInstitution = 1,lastdead = FALSE,
                    niter = 25000, burnin = 5001, thinning = 20, nchain = 3, ncpus = 2) {
  
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(sexData))
  assert_that(sexData %has_name% c("AnimalAnonID", "BirthDate", "DepartDate",
                                   "EntryDate", "MaxBirthDate", "MinBirthDate",
                                   "EntryType", "DepartType", "FirstHoldingInstitution", 
                                   "LastHoldingInstitution", "SexType", "BirthType"))
  assert_that(is.data.frame(DeathInformation))
  assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  assert_that(outlLev1 <= 100)
  assert_that(is.numeric(minNsur))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(uncert_death))
  if(!is.null(maxNsur)) {
    assert_that(is.numeric(maxNsur))
  }else{maxNsur = nrow(sexData)}
  assert_that(minNsur > 0)
  assert_that(is.numeric(MinBirthKnown))
  assert_that(MinBirthKnown >= 0)
  assert_that(MinBirthKnown <1)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models))
  assert_that(all(models %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  assert_that(is.logical(lastdead))
   
   #Initialize
  summar = list(
    NSelect =  nrow(sexData), NUncertdeath = 0,  NBasta = 0, Ndead = 0, 
    maxAge = NULL, maxAlive = NULL, 
    lxMin = NULL, outLev = NULL, 
    analyzed = FALSE, Nerr = 0,  error ="")
  bastaRes = NULL
  DICmods = NULL
  
   #Remove individuals with uncertainty in death date
  sexData <- sexData%>%
    filter((Death_Uncertainty < uncert_death)%>% replace_na(TRUE))
summar$NUncertdeath =nrow(sexData)

  
   if(nrow(sexData)> minNsur){
sexDat <- select_Longthreshold( sexData, minN = minNsur )
 outlLev = sexDat$summar$GapThresh
 
    #Find the minimum threshold for which lxmin  >.1
    summar$lxMin <- 1
    outLev2 = min(outlLev1, outlLev)
    while(summar$lxMin > 0.1 & outLev2 >= 95){
      summar$outLev = outLev2
      if (summar$outLev ==100){
        data_sel <-  sexData
      }else{
        data_sel <-  sexData%>%
          filter(!!sym(paste0("above", summar$outLev))==0)
      }
      data_sel <- data_sel%>%
        mutate(
          deparAge = (DepartDate - BirthDate) / 365.25,
          entryAge = (EntryDate - BirthDate) / 365.25
        )
      
      if (!all(data_sel$DepartType == "C")) {
        rawPLE <- Sur_ple(data_sel)
        # Minimum value of lx:
        summar$lxMin <- rawPLE$ple[nrow(rawPLE)-1]
      }
      if( summar$outLev == 100){outLev2 = 99.9}
      if( summar$outLev == 99.9){outLev2 = 99}
      if( summar$outLev == 99){outLev2 = 95}
      if( summar$outLev == 95){outLev2 = 90}
    }
    
    #raw median life expectancy
    # summar$MedLE = median(deparAge[deparType == "D"])
    
 
      # Extract BaSTA table:
      bastalist <- surv_Bastab(data_sel, DeathInformation = DeathInformation, earliestDate = mindate,
                               excludeStillbirth = TRUE)
      bastatab <- bastalist%>%
        mutate(
          bdun = Max.Birth.Date-Min.Birth.Date,
          aliveTime = (Depart.Date - Entry.Date) / 365.25)
      
      if(lastdead){
        bastatab$Depart.Type[bastatab$aliveTime == max(bastatab$aliveTime)]="D"
      }
      
      

      summar$NBasta <- nrow(bastatab)
      summar$Ndead <- nrow(bastatab%>%filter(Depart.Type =="D"))
      summar$maxAge <- as.numeric(max(bastatab$Depart.Date - bastatab$Birth.Date, na.rm = TRUE))
      summar$maxAlive <- as.numeric(max(bastatab$Depart.Date - bastatab$Entry.Date, na.rm = TRUE))
      
      if(summar$NBasta>0){
        #Check the percentage of individuals with known births
        Perbirthknown =  length(which(bastatab$bdun<32 & bastatab$Entry.Type=="B")) / 
          summar$NBasta
        if(Perbirthknown >= MinBirthKnown){
          #Check that we have more than 1 institution
          Instb =  unique(data_sel$FirstHoldingInstitution[data_sel$AnimalAnonID %in% bastatab$AnimalAnonID])
          Instl =  unique(data_sel$LastHoldingInstitution[data_sel$AnimalAnonID %in% bastatab$AnimalAnonID])
          if(length(unique(c(Instb,Instl)))>=minInstitution){
            if (summar$NBasta >= minNsur) {
              if(summar$NBasta <= maxNsur){
                tempList <- list()
                DICmods <- tibble(models,
                                  DIC = 0)
                for (imod in 1:length(models)) {
                  print(models[imod])
                  tempList[[models[imod]]] <- BaSTA::basta(
                    bastatab, dataType = "census", shape = shape, minAge = minAge, 
                    model = models[imod], parallel = TRUE, 
                    ncpus = ncpus, nsim = nchain,
                    niter = niter, burnin = burnin, thinning = thinning)
                  
                  if (!is.na( tempList[[models[imod]]]$DIC[1])) {
                    DICmods$DIC[imod] <-  tempList[[models[imod]]]$DIC["DIC"]
                  }
                }
                if (all(DICmods$DIC == 0)) {
                  print("more chains")
                  for (imod in 1:length(models)) {
                    print(models[imod])
                    tempList[[models[imod]]] <- BaSTA::basta(
                      bastatab, dataType = "census", shape = shape, minAge = minAge, 
                      ncpus = ncpus, nsim = nchain, 
                      niter = niter*4, burnin = burnin*4-3, thinning = thinning)
                    if (!is.na(tempList[[models[imod]]]$DIC[1])) {
                      DICmods$DIC[imod] <-tempList[[models[imod]]]$DIC["DIC"]
                    }
                    
                    
                  } 
                }
                
                # BaSTA outputs:
                if (any(DICmods$DIC != 0)) {
                  a = which(DICmods$DIC == 0)
                   DICmods2 = DICmods
                  if(length(a)>0){
                    DICmods2 = DICmods2[-a,]
                  }
                  idModSel <- which(DICmods$DIC == min(DICmods2$DIC, na.rm = TRUE))
                  bastaRes <- tempList[[idModSel]]
                  summar$analyzed = TRUE
                } else {
                  summar$error = 'no DIC from Basta'
                  summar$Nerr = 8
                }
              } else {
                summar$error = "Nbasta > maxNsur"
                summar$Nerr = 7
              }} else {
                summar$error = "Nbasta < minNsur"
                summar$Nerr = 6
              }
          }else{
            summar$error = "Data from 1 Institution"
            summar$Nerr = 5
          }
        }else{ 
          summar$error = "%known births < MinBirthKnown"
          summar$Nerr = 4
        }
      }else{
        summar$error = "NBasta = 0"
        summar$Nerr = 3
      }
  } else {
    summar$ error = "Nuncertdeath < minNsur"
    summar$ Nerr = 2
  }
  
  return(list(summary = summar, bastaRes = bastaRes, DICmods = DICmods))
}
```

```{r examples-Sur_ana}
data(core)
data(deathinformation)
out <- Sur_ana(core,  DeathInformation = deathinformation, models = "GO", shape = "simple",
               niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
```

```{r tests-Sur_ana}
test_that("Sur_ana works", {
  data(core)
  data(deathinformation)
  out <- Sur_ana(core, DeathInformation = deathinformation, models = "GO", shape = "bathtub",
                 niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
  expect_named(out, c("summary",  "bastaRes", "DICmods"))
  expect_named(out$DICmods, c("models",  "DIC"))
  expect_equal(nrow(out$DICmods),1)
  expect_named(out$summary, c("NSelect","NUncertdeath", "NBasta", "Ndead", "maxAge", "maxAlive", "lxMin",    "outLev", "analyzed", "Nerr", "error"))
  # expect_true(out$summary$analyzed )
  expect_true(is.numeric(out$summary$NSelect ))
  expect_true(is.numeric(out$summary$NBasta ))
  expect_true(is.numeric(out$summary$Ndead ))
  expect_true(is.numeric(out$summary$maxAge ))
  expect_true(is.numeric(out$summary$maxAlive))
  expect_true(is.numeric(out$summary$lxMin ))
  expect_true(is.numeric(out$summary$outLev ))
  expect_true(is.numeric(out$summary$Nerr ))
  # expect_true(class(out$bastaRes) == "basta")
})
```




# First-year survival Analysis

This functions runs survival basta models on the first year after checking conditions for correct convergence of the models. It includes the following arguments:
* `sexData`including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*.
* `DeathInformation` data.frame including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
* `models` names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
* `uncert_death` Maximum uncertainty accepted for death date, in days
* `uncert_birth` Maximum uncertainty accepted for birth date, in days
* ` minNsur` Minimum number of individual records needed to run the survival analysis
* `maxNsur` Maximum number of individual records to run the survival analysis
* `minInstitution` Minimum number of institutions that should hold records to run the survival analysis

It return a list including:
* a summary of the data used
* the basta fit of the best model
* the DIC table comparing the different fit of the models

```{r function-Sur_ana1}
#' First-year survival Analysis
#' 
#' Run basta models on the first year after checking conditions for correct convergence of the models
#'
#' @param sexData \code{data.frame} including at least the following columns *AnimalAnonID*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, *DepartType*, *FirstHoldingInstitution*, *LastHoldingInstitution*, *SexType*, and *BirthType*
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param models \code{vector of characters} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param mindate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death date, in days
#' @param uncert_birth \code{numeric}: Maximum uncertainty accepted for birth date, in days
#' @param minNsur \code{numeric} Minimum number of individual records needed to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the survival analysis. Default = 1
#' @param niter  \code{numeric}. number of MCMC iterations to run. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#'
#' @return The output of a list including:
#' * a summary of the data used:
#'- NGlobal: Number of captive born individuals selected from global collections
#'- NBasta: Number of data (individuals) selected for the BaSTA/survival analysis
#'- Ndead:Number of individuals with known age of death used in the BaSTA/survival analysis
#'- maxAge: Maximum age of known age individuals
#'- maxAlive:Maximum number of years spent ex situ
#'- lxMin:Minimum survivorship reached with the raw Kaplan-Meier model
#'-  OutLev: threshold selected for the distribution of  time spent alive: 100%, 99.9, 99 or 95%
#'- a logical indicated if the growth analysis was performed
#'-  If the survival analysis was not performed, an error and its number (Nerr) are returned: The possibility for  this functions are: 1/Nglobal < minNsur; 2/lxMin > minlx; 3/NBasta = 0; 4/ %known births < MinBirthKnown; 5/Data from 1 Institution; 6/Nbasta < minNsur; 7/Nbasta < maxNsur; 8/no DIC from Basta.
#'* the basta fit of the best model
#'* the DIC table comparing the different fit of the models
#' 
#' @export
#'
#' @examples
Sur_ana1 <- function(sexData, DeathInformation, models = "GO", shape = "simple",
                     minNsur = 50,maxNsur = NULL, mindate = "1980-01-01",
                     uncert_birth=30,uncert_death=30,minInstitution = 1,
                     niter = 25000, burnin = 5001, thinning = 20, nchain = 3, ncpus = 2) {
  
  mindate = lubridate::as_date(mindate)
  assert_that(is.data.frame(sexData))
  assert_that(sexData %has_name% c("AnimalAnonID", "BirthDate", "DepartDate",
                                   "EntryDate", "MaxBirthDate", "MinBirthDate",
                                   "EntryType", "DepartType", "FirstHoldingInstitution", 
                                   "LastHoldingInstitution", "SexType", "BirthType"))
  assert_that(is.data.frame(DeathInformation))
  assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  assert_that(is.numeric(minNsur))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(uncert_death))
  assert_that(is.numeric(uncert_birth))
  if(!is.null(maxNsur)) {
    assert_that(is.numeric(maxNsur))
  }else{maxNsur = nrow(sexData)}
  assert_that(minNsur > 0)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models))
  assert_that(all(models %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
    #Remove individuals with uncertainty in death date
  sexData <- sexData%>%
    filter((Death_Uncertainty < uncert_death)%>% replace_na(TRUE),
           (Birth_Uncertainty < uncert_birth)%>% replace_na(TRUE))%>%
    mutate(
      deparAge = (DepartDate - BirthDate) ,
      entryAge = (EntryDate - BirthDate) ,
      DepartType = ifelse(deparAge>365.25, "C", DepartType),
    )%>%
    filter(entryAge <= 365)
  sexData$DepartDate= as.Date(sexData$DepartDate)
  sexData$DepartDate[sexData$deparAge>365.25]= as.Date(sexData$EntryDate)[sexData$deparAge>365.25]+ 366
  

  
  #Initialize
  summar = list(
    NGlobal =  nrow(sexData), NBasta = 0, Ndead = 0, 
    maxAge = NULL, maxAlive = NULL, 
    lxMin = NULL, outLev = NULL, 
    analyzed = FALSE, Nerr = 0,  error ="")
  bastaRes = NULL
  DICmods = NULL
  
  if(nrow(sexData)>= minNsur){
    
    # Extract BaSTA table:
    bastalist <- surv_Bastab(sexData, DeathInformation = DeathInformation, earliestDate = mindate,
                             excludeStillbirth = TRUE)
    bastatab <- bastalist%>%
      mutate(
        bdun = Max.Birth.Date-Min.Birth.Date,
        aliveTime = (Depart.Date - Entry.Date) / 365.25)
    
 
    summar$NBasta <- nrow(bastatab)
    summar$Ndead <- nrow(bastatab%>%filter(Depart.Type =="D"))
    summar$maxAge <- as.numeric(max(bastatab$Depart.Date - bastatab$Birth.Date, na.rm = TRUE))
    summar$maxAlive <- as.numeric(max(bastatab$Depart.Date - bastatab$Entry.Date, na.rm = TRUE))
    
    if(summar$NBasta>0){
      if(summar$Ndead>0){
      #Check the percentage of individuals with known births
      #Check that we have more than 1 institution
      Instb =  unique(sexData$FirstHoldingInstitution[sexData$AnimalAnonID %in% bastatab$AnimalAnonID])
      Instl =  unique(sexData$LastHoldingInstitution[sexData$AnimalAnonID %in% bastatab$AnimalAnonID])
      if(length(unique(c(Instb,Instl)))>=minInstitution){
        if (summar$NBasta >= minNsur) {
          if(summar$NBasta <= maxNsur){
            tempList <- list()
            DICmods <- tibble(models,
                              DIC = 0)
            for (imod in 1:length(models)) {
              print(models[imod])
              tempList[[models[imod]]] <- BaSTA::basta(
                bastatab, dataType = "census", shape = shape, 
                model = models[imod], parallel = TRUE, 
                ncpus = ncpus, nsim = nchain,
                niter = niter, burnin = burnin, thinning = thinning)
              
              if (!is.na( tempList[[models[imod]]]$DIC[1])) {
                DICmods$DIC[imod] <-  tempList[[models[imod]]]$DIC["DIC"]
              }
            }
            if (all(DICmods$DIC == 0)) {
              print("more chains")
              for (imod in 1:length(models)) {
                print(models[imod])
                tempList[[models[imod]]] <- BaSTA::basta(
                  bastatab, dataType = "census", shape = shape,
                  ncpus = ncpus, nsim = nchain, 
                  niter = niter*4, burnin = burnin*4-3, thinning = thinning)
                if (!is.na(tempList[[models[imod]]]$DIC[1])) {
                  DICmods$DIC[imod] <-tempList[[models[imod]]]$DIC["DIC"]
                }
                
                
              } 
            }
            
            # BaSTA outputs:
            if (any(DICmods$DIC != 0)) {
                       a = which(DICmods$DIC == 0)
                   DICmods2 = DICmods
                   if(length(a)>0){
                     DICmods2 = DICmods2[-a,]
                   }
idModSel <- which(DICmods$DIC == min(DICmods$DIC, na.rm = TRUE))
              bastaRes <- tempList[[idModSel]]
              summar$analyzed = TRUE
            } else {
              summar$error = 'no DIC from Basta'
              summar$Nerr = 9
            }
          } else {
            summar$error = "Nbasta > maxNsur"
            summar$Nerr = 8
          }
        } else {
          summar$error = "Nbasta < minNsur"
          summar$Nerr = 7
        }
      }else{
        summar$error = "Data from 1 Institution"
        summar$Nerr = 6
      }
    }else{
      summar$error = "Ndead = 0"
      summar$Nerr = 5
    }
  }else{
      summar$error = "NBasta = 0"
      summar$Nerr = 4
    }
    } else {
    summar$ error = "Nglobal < minNsur"
    summar$ Nerr = 2
  }
  
  return(list(summary = summar, bastaRes = bastaRes, DICmods = DICmods))
}
```

```{r examples-Sur_ana1}
data(core)
data(deathinformation)
out <- Sur_ana1(core,  DeathInformation = deathinformation, models = "GO", shape = "simple",
                niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
```

```{r tests-Sur_ana1}
test_that("Sur_ana1 works", {
  data(core)
  data(deathinformation)
  out <- Sur_ana1(core, DeathInformation = deathinformation, models = "GO", shape = "simple",
                  niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
  expect_named(out, c("summary",  "bastaRes", "DICmods"))
  expect_named(out$DICmods, c("models",  "DIC"))
  expect_equal(nrow(out$DICmods),1)
  expect_named(out$summary, c("NGlobal", "NBasta", "Ndead", "maxAge", "maxAlive", "lxMin",    "outLev", "analyzed", "Nerr", "error"))
  expect_true(out$summary$analyzed )
  expect_true(is.numeric(out$summary$NGlobal ))
  expect_true(is.numeric(out$summary$NBasta ))
  expect_true(is.numeric(out$summary$Ndead ))
  expect_true(is.numeric(out$summary$maxAge ))
  expect_true(is.numeric(out$summary$maxAlive))
  expect_true(is.numeric(out$summary$Nerr ))
})
```





# Outputs for survival analysis

`Sur_out()` return plot for the survival models and the remaining life expectancy . It includes the following arguments:

* `out`: The output of the survival analysis
* `PlotDir`: Directory to save the plots of the best models

It return the output of the survival analysis including:
* the remaining life expectancy per age
* L50: The age at which 50% of the population died
* L90: The age at which 90% of the population died
* Age-specific survival
* Probability to live five years more
It creates the associated plot

```{r function-Sur_out}
#' Create output and plots for the survival analysis
#' 
#' Estimate remaning life expectancy, L90, L50 and age-specific survival.
#'
#' @param out \code{numeric} The output of the survival analysis
#' @param XMAX \code{numeric} Maximum possible age. Default = 120
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param Min_MLE \code{numeric} Goodness of fit: Minimum survivorship at Mean life expectancy
#' @param MaxLE \code{numeric} Goodness of fit: Maximum remaining life expectancy at max age
#' @param minlx  \code{numeric} between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis. Default = 0.1
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#' @param PlotDir \code{character} Directory to save the plots. Default = NULL, no plot is saved
#' @param plotname \code{character} Name used to save the plot. Default = ""
#' @param firstyear \code{logical} Whether the analysis was done only on first year. Default = FALSE
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#' 
#' @return The output list of the survival analysis including in addition:
#' * a summary of the data used:
##'- A goodness of fit tested the trend in the residuals between the model prediction and the kaplan meier estimator
#'* the estimated remaining life expectancy per age
#'* the age at which 90% of the population died
#'* the age at which 50% of the population died
#'* the estimated probability to live one year more
#'* the estimated probability to live five years more
#' If PlotDir is filled, 2 plots are produced: one showing the outliers removed from the data, and one showing the fit of the model on the data.
#'
#' @export
#'
#' @importFrom grDevices pdf dev.off
#' @importFrom graphics lines
#'
#' @examples
Sur_out <- function(out, shape= "simple", 
                    XMAX=120,ncpus = 2, minAge = 0,
                    PlotDir = NULL, plotname = '',
                    Min_MLE = 0.1, MaxLE = 2,
                    minlx = 0.1,
                    firstyear = FALSE) {
  
  assert_that(is.numeric(Min_MLE))
  assert_that(is.numeric(MaxLE))
    assert_that(is.numeric(minlx))
  assert_that(minlx > 0)
  assert_that(minlx <1)
assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(plotname))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  if(!is.null(PlotDir)){
    checkmate::assert_directory_exists(PlotDir)
  }
  
  # Find age at S(x) = 0.005:
  Sx <- out$bastaRes$surv$nocov[1,]
  idxMax <- out$bastaRes$x[which(Sx < 0.005)][1]
  if (is.na(idxMax)) {
    xMax <- min(max(out$bastaRes$x),XMAX)
  } else {xMax = idxMax}
    paramax = length(out$bastaRes$names)
    if("lambda" %in% out$bastaRes$names){paramax = paramax-1}
 
  if(!firstyear){
    
     
    # Remaining life expectancy:
    out$relex <- Sur_relex(theMat = out$bastaRes$params[,1:paramax], 
                           model = out$bastaRes$modelSpecs["model"], 
                           shape = shape, ncpus = ncpus, 
                           xMax = xMax, dx = 0.01, minAge = minAge)
    
    # L90 : Age at which 90% of the individuals died
    out$L90 <- Sur_xx(theMat = out$bastaRes$params[,1:paramax],  
                      model = out$bastaRes$modelSpecs["model"], 
                      shape = shape, ncpus = ncpus, xx = 0.1,
                      ageMax = xMax, dage = 0.01, minAge = minAge)
    # L50 : Age at which 50% of the individuals died
    out$L50 <- Sur_xx(theMat = out$bastaRes$params[,1:paramax],  
                      model = out$bastaRes$modelSpecs["model"], 
                      shape = shape, ncpus = ncpus, xx = 0.5,
                      ageMax = xMax, dage = 0.01, minAge = minAge)
    # Proba to live 5 year more:
    if(xMax >=5){
      out$Sur5 <- Sur_age(theMat = out$bastaRes$params[,1:paramax], 
                          model =out$bastaRes$modelSpecs["model"], 
                          shape = shape, ncpus = ncpus,  minAge = minAge,
                          ageMax = xMax,  dage = 0.01, Nyear = 5)
    }else{out$Sur5 = "Error : Age max lower than 5 years"}
   # Proba to live 1 year more:
  out$Sur1 <- Sur_age(theMat = out$bastaRes$params[,1:paramax],  
                      model = out$bastaRes$modelSpecs["model"], 
                      shape = shape, ncpus = ncpus, minAge = minAge,
                      ageMax = xMax, dage = 0.01, Nyear = 1)
  
  }else{
  # Proba to live 1 year more:
  out$Sur1m <- Sur_age(theMat = out$bastaRes$params[,1:paramax],  
                      model = out$bastaRes$modelSpecs["model"], 
                      shape = shape, ncpus = ncpus, minAge = 0,
                      ageMax = 1, dage = 1/12, Nyear = 1/12)
  }
  
  # Goodness of fit tests
    
      
  if(!firstyear){
      xmaxobs = max(out$bastaRes$lifeTable$noCov$Mean$Ages)
  ##Test if the life expectancy at max age observed is below MaxLE years old
  idxmax = ifelse(max(out$relex$Age) > xmaxobs, which(out$relex$Age==xmaxobs), length(out$relex$Age))
  if(out$relex$RemLExp[idxmax]>= MaxLE){
    out$summary$error = "Min(Life_exp) >= MaxLE"
    out$summary$Nerr=10
  }
    ##Test if the survivorship at mean life expectancy is higher than Min_MLE
    lx <-out$bastaRes$lifeTable$noCov$Mean$lx
    #age for mle
    dif <-abs(out$bastaRes$lifeTable$noCov$Mean$Ages - out$bastaRes$PS$nocov$PS[1,1])
    
    if(lx[which(dif == min(dif))]< Min_MLE){
       out$summary$error = "lx[MLE] < Min_MLE"
      out$summary$Nerr = 11
      # out$bastaRes <- list()   
    }
    
     if( out$summary$lxMin<minlx){
       out$summary$error = "lxmin > minlx"
      out$summary$Nerr = 12
      # out$bastaRes <- list()   
    }
  }  
 
     ##Test if residuals of predicted lx vs. kaplan meier estimator has a trend
  # id = which(out$bastaRes$x %in% seq(0,round(XMAX)),0.5)
  # m = min(length(id),(round(XMAX)+1), length(out$bastaRes$lifeTable$noCov$Mean$lx))
  # if(length(id)>m){ id = which(out$bastaRes$x %in% out$bastaRes$lifeTable$noCov$Mean$Ages)}
  # res = out$bastaRes$surv$nocov[1,id] - out$bastaRes$lifeTable$noCov$Mean$lx[1:m]
  # b = summary(lm(res~c(1:m)))
  # out$summary$Gof_KM = b$coefficients[2,4] > 0.01
  # out$summary$Gof_KM_coeff =b$coefficients[2,1]
  
  #test if kaplan-meier estimator is within the estimated 95CI
  Lx= tibble(Meann = out$bastaRes$surv$nocov[1,],
             Lower = out$bastaRes$surv$nocov[2,],
             Upper = out$bastaRes$surv$nocov[3,],
             Ages =out$bastaRes$x )%>%
    filter(Ages >=minAge)
  #correct estimates when minAge >0
  Lx$Meann=Lx$Meann/Lx$Meann[1]
  Lx$Lower=Lx$Lower/Lx$Lower[1]
  Lx$Upper=Lx$Upper/Lx$Upper[1]
  
  LT = out$bastaRes$lifeTable$noCov$ple%>%
    mutate(Ages = round(Ages/0.05)*0.05)%>%
    filter(Ages >=minAge)
#correct estimates when minAge >0
  LT$ple   =  LT$ple/ LT$ple[1]
    LT = LT%>%
    group_by(Ages)%>%
    summarise(ple = max(ple))%>%
    left_join(Lx)%>%
    tidyr::drop_na(Lower, Upper)%>%
    mutate(check = (ple <= Upper & ple >= Lower),
           residual = Meann - ple,
           sign = ifelse(residual <0, -1,1),
           diff = 0)
LT$diff[2:nrow(LT)] =ifelse(LT$sign[1:(nrow(LT)-1)] == LT$sign[2:nrow(LT)], 0,1)
LT$diff = cumsum(LT$diff)

v <- LT%>%
  group_by(diff)%>%
  summarise(resi = abs(sum (residual)))
  
  check = length(which(LT$check))/nrow(LT)
  out$summary$Gof_KM_coeff1 =check
  out$summary$Gof_KM_coeff2 =max(v$resi)

 if(max(v$resi)>=2 & out$summary$Nerr==0 ){
    out$summary$error = "Kaplan-Meier does not fit:2"
      out$summary$Nerr = 13
    }
  if(check < 0.8){
   out$summary$error = "Kaplan-Meier does not fit"
      out$summary$Nerr = 9
    }



 
  #Plots
  if(!is.null(PlotDir)){
       pdf(file = paste0(PlotDir,"/",out$summary$Nerr,'_', plotname, "_surcheck.pdf", sep=""), width = 6, height = 6)
   if(firstyear){
    plot(out$bastaRes, main = plotname)
    plot(out$bastaRes, plot.type = 'demorates', xlim = c(0,1))
    plot(out$bastaRes, plot.type = 'gof', xlim = c(0,1))
    dev.off()
    
     pdf(file = paste0(PlotDir,"/", out$summary$Nerr,'_', plotname, "_surplot.pdf", sep=""), width = 6, height = 6)
           out$Sur1m$Agem=round(out$Sur1m$Age*12,2)
      plot(out$Sur1m$Sur ~  out$Sur1m$Agem, 
           xlab = "Age (month)", ylab = 'Month-specific survival', type = "l")
      lines(out$Sur1m$Lower ~  out$Sur1m$Agem, lty = 2)
      lines(out$Sur1m$Upper ~  out$Sur1m$Agem, lty = 2)
         dev.off()

    }else{
       plot(out$bastaRes, main = plotname)
    plot(out$bastaRes, plot.type = 'demorates')
    plot(out$bastaRes, plot.type = 'gof')
    dev.off()
    
      pdf(file = paste0(PlotDir,"/", out$summary$Nerr,'_', plotname, "_surplot.pdf", sep=""), width = 6, height = 6)
      plot(out$relex$RemLExp~  out$relex$Age, main = plotname, xlab = "Age (year)", 
           ylab = "Remaining life expectancy", type = "l")
      lines(out$relex$Lower ~  out$relex$Age, lty = 2)
      lines(out$relex$Upper ~  out$relex$Age, lty = 2)
      
      plot(out$Sur1$Sur ~  out$Sur1$Age, 
           xlab = "Age (year)", ylab = 'Age-specific survival', type = "l")
      lines(out$Sur1$Lower ~  out$Sur1$Age, lty = 2)
      lines(out$Sur1$Upper ~  out$Sur1$Age, lty = 2)
      
      if(xMax >=5){
        plot(out$Sur5$Sur ~  out$Sur5$Age, 
             xlab = "Age (year)", ylab = 'p(survive 5 more years)', type = "l")
        lines(out$Sur5$Lower ~  out$Sur5$Age, lty = 2)
        lines(out$Sur5$Upper ~  out$Sur5$Age, lty = 2)
      }
      dev.off()
    }
    
  }
  
  
  return(out)
}

```

```{r examples-Sur_out}
data(core)
data(deathinformation)
out <- Sur_ana(core,  DeathInformation = deathinformation, models = "GO", shape = "simple",
               niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)

out <- Sur_out(out, shape = "simple", ncpus = 3)
```

```{r tests-Sur_out}
test_that("Sur_out works", {
  data(core)
  data(deathinformation)
  out <- Sur_ana(core,  DeathInformation = deathinformation, models = "GO", shape = "simple",
                 niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3)
  
  out <- Sur_out(out, shape = "simple", ncpus = 3)
  expect_named(out, c("summary",  "bastaRes", "DICmods", "relex", 'L90', 'L50', 'Sur5', 'Sur1'))
  expect_named(out$summary, c('NSelect', 'NUncertdeath',  "NBasta", "Ndead", "maxAge", "maxAlive", "lxMin", "outLev", "analyzed", "Nerr", "error", "Gof_KM_coeff1", "Gof_KM_coeff2"))
  expect_named(out$relex, c("Age", "RemLExp", "Lower", "Upper"))
  expect_true(is.numeric(out$relex$Upper))
  expect_true(is.numeric(out$relex$Age))
  expect_true(is.numeric(out$relex$RemLExp))
  expect_true(is.numeric(out$relex$Lower))
  expect_true(out$relex$Lower[1]<out$relex$RemLExp[1])
  expect_true(out$relex$RemLExp[1]<out$relex$Upper[1])
  expect_named(out$Sur5, c("Age", "Lower",  "Upper", "Sur"))
  expect_true(is.numeric(out$Sur5$Lower))
  expect_true(is.numeric(out$Sur5$Sur))
  expect_named(out$L90, c("L", "Lower",  "Upper"))
  expect_true(out$L90$L >5)
})
```


# Create Basta data frame

This functions format the data prior to run basta models. It checks column names and the succession of dates for each individual. It includes the following arguments:

* `coresubset` data frame including at least the following columns *AnimalAnonID*, *binSpecies*, *Class*, *Order*, *Family*, *CommonName*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, and *DepartType*
* `DeathInformation` data.frame including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
* `earliestDate` Earlier date to be included.
* `latestDate` LAtest date to be included.
* `otherCovars` Additional variables to include in the data
* `excludeStillbirth` Whether to exclude still births.

This function return the subset dataset excluding individuals:
* with NA in the columns BirthDate, MinBirthDate, MaxBirthDate, EntryDate, and DepartDate.
* for which the dates from min birth date/ entry date to Depart date do not follow one another.
* Still born if required
* with depart date anterior to earliest date
* with entry date posterior to latest date
* Depart date posterior to latest date are changed to latest date. These individuals are considered as right-censored.



```{r function-surv_Bastab}
#' Create Basta data frame
#' 
#' Check column names and succession of dates to prepare the data for BASTA.
#'
#' @param coresubset  \code{data.frame} including at least the following columns *AnimalAnonID*, *binSpecies*, *Class*, *Order*, *Family*, *CommonName*, *BirthDate*, *DepartDate*, *EntryDate*, *MaxBirthDate*, *MinBirthDate*, *EntryType*, and *DepartType*
#' @param DeathInformation  \code{data.frame} including at least the following columns *AnimalAnonID* and *RelevantDeathInformationType*
#' @param earliestDate \code{character 'YYYY-MM-DD'} Earlier date to be included. Default = NA
#' @param latestDate \code{character 'YYYY-MM-DD'} LAtest date to be included. Default = NA
#' @param otherCovars \code{vector of character}. Additional variables to include in the data Default = NA
#' @param excludeStillbirth \code{logical} Whether to exclude still births. Default = FALSE
#' 
#' @details
#' This function removes:
#' * individuals with NA in the columns BirthDate, MinBirthDate, MaxBirthDate, EntryDate, and DepartDate.
#' * individuals for which the dates from min birth date/ entry date to Depart date do not follow one another.
#' * Still born individuals if required
#' * individuals with depart date anterior to earliest date
#' * individuals with entry date posterior to latest date
#' * Depart date posterior to latest date are changed to latest date. These individuals are considered as right-censored.
#'
#' @return the subset dataset in the basta format
#' 
#' @export
#' @importFrom tidyr replace_na
#'
#' @examples
surv_Bastab <- function (coresubset, DeathInformation, earliestDate = NA, latestDate = NA, 
                         otherCovars = NA, excludeStillbirth = FALSE) 
{ 
  inclcols <- c("AnimalAnonID", "binSpecies", "Class", 
                "Order", "Family", "CommonName", "BirthDate", "MinBirthDate", 
                "MaxBirthDate", "EntryDate", "DepartDate", "EntryType", 
                "DepartType")
  assert_that(coresubset %has_name% inclcols)
  assert_that(DeathInformation %has_name% c("AnimalAnonID","RelevantDeathInformationType"))
  assert_that(is.logical(excludeStillbirth))
  
  
  if (!is.na(otherCovars)) {
    assert_that(coresubset %has_name% otherCovars)
    inclcols <- c(inclcols, otherCovars)
   }
  
  bastadat <- coresubset[, inclcols]%>%
    left_join(DeathInformation%>%select(AnimalAnonID, RelevantDeathInformationType)%>%
                filter(RelevantDeathInformationType %in% c("Stillborn","Fetal death")), by = "AnimalAnonID")
  if (!is.na(otherCovars)) {
  colnames(bastadat) <- c("AnimalAnonID", "binSpecies", "Class", 
                          "Order", "Family", "CommonName", "Birth.Date", "Min.Birth.Date", 
                          "Max.Birth.Date", "Entry.Date", "Depart.Date", "Entry.Type", 
                          "Depart.Type",otherCovars, "RelevantDeathInformationType")
  }else{
     colnames(bastadat) <- c("AnimalAnonID", "binSpecies", "Class", 
                          "Order", "Family", "CommonName", "Birth.Date", "Min.Birth.Date", 
                          "Max.Birth.Date", "Entry.Date", "Depart.Date", "Entry.Type", 
                          "Depart.Type","RelevantDeathInformationType")

  }
  
  #Earliest and latest dates
  if (is.na(earliestDate)) {
    earliestDate <- min(bastadat$Min.Birth.Date, na.rm = TRUE)
  }else{
    earliestDate <- lubridate::as_date(earliestDate)
  }
  if (is.na(latestDate)) {
    latestDate <- lubridate::today()
  }else{
    latestDate <- lubridate::as_date(latestDate)
  }
  
  bastadat <- bastadat%>%
    mutate(Depart.Date = lubridate::as_date(Depart.Date),
           Entry.Date = lubridate::as_date(Entry.Date),
           Min.Birth.Date = lubridate::as_date(Min.Birth.Date),
           Max.Birth.Date = lubridate::as_date(Max.Birth.Date),
           Birth.Date = lubridate::as_date(Birth.Date)
    )%>%
    filter(Depart.Date >= earliestDate,
           Entry.Date <= latestDate)%>%
    tidyr::drop_na(c(Birth.Date, Min.Birth.Date, Max.Birth.Date, Entry.Date, Depart.Date))%>%
    filter((Min.Birth.Date <= Birth.Date)%>% replace_na(TRUE), 
           (Birth.Date <= Max.Birth.Date)%>% replace_na(TRUE), 
           (Birth.Date <= Entry.Date)%>% replace_na(TRUE), 
           (Entry.Date <= Depart.Date)%>% replace_na(TRUE))%>%
    mutate(Depart.Type = if_else (Depart.Date > latestDate, "C", Depart.Type),
           Depart.Date = if_else (Depart.Date > latestDate, latestDate, Depart.Date),
           Entry.Type  = if_else (Entry.Date < earliestDate, "C", Entry.Type),
           Entry.Date  = if_else (Entry.Date < earliestDate, earliestDate, Entry.Date)
    )
  
  if(excludeStillbirth){
    #Remove Stillborn
    bastadat <- bastadat%>%
      filter((Depart.Date != Birth.Date)%>% replace_na(TRUE),
             stringr::str_detect(RelevantDeathInformationType, "Stillborn", negate = T)%>% replace_na(TRUE),
             stringr::str_detect(RelevantDeathInformationType, "Fetal death", negate = T)%>% replace_na(TRUE))
  }%>%
    select(-"RelevantDeathInformationType")
  
  
  return(bastadat)
}
```

```{r examples-surv_Bastab}
data(core)
data(deathinformation)
out<- surv_Bastab(core, DeathInformation = deathinformation,
                  earliestDate = '1990-01-01', latestDate = '2020-12-31', 
                  otherCovars = "SexType", excludeStillbirth = TRUE)


```

```{r tests-surv_Bastab}
test_that("surv_Bastab works", {
  data(core)
  data(deathinformation)
  out<- surv_Bastab(core, DeathInformation = deathinformation, earliestDate = '1990-01-01', latestDate = '2020-12-31', 
                    otherCovars = NA, excludeStillbirth = TRUE)
  expect_named(out, c("AnimalAnonID", "binSpecies", "Class", "Order", "Family", "CommonName", "Birth.Date", "Min.Birth.Date", "Max.Birth.Date", "Entry.Date", "Depart.Date", "Entry.Type", "Depart.Type", "RelevantDeathInformationType" ))
  expect_true(min(out$Entry.Date)>= lubridate::as_date('1990-01-01'))
  expect_true(max(out$Depart.Date)<=lubridate::as_date('2020-12-31'))
})
```




# Estimate raw survivorship from life table

This function takes sexData, a data frame including at least the following columns *deparAge*, *entryAge* (\code{date}), and *DepartType*

```{r function-Sur_ple}
#' Estimate raw survivorship from life table
#' 
#' @param sexData \code{data.frame} including at least the following columns *deparAge*, *entryAge* (\code{date}), and *DepartType* 
#'
#' @return A data frame including 3 colummns:
#' * Ages: the different ages
#' * Surv: survivorship
#' * event = 1 if the individual was dead at this age 
#' vs. 0 is the individual was left-censored at this age
#' 
#' @export
#'
#' @examples

# Product limit estimator:
Sur_ple <- function(sexData) {
  assert_that(is.data.frame(sexData))
  assert_that(sexData %has_name% c("deparAge", "DepartType", "entryAge"))
  # Find records with same first and last age:
  sexData <- sexData%>%
    rowwise()%>%
    mutate(idsame = entryAge == deparAge,
           deparAge = round(ifelse(idsame, deparAge + 1/365.25, deparAge),1))%>%
    arrange(deparAge)
  
  # Number of ages:
  nage <-unique(sexData$deparAge)
  
  # Cx and delta:
  Cx <- rep(0, length(nage))
  delx <- rep(0, length(nage))
  
  # Fill up Cx and delta:
  ii = 0
  for (agev in nage) {
    ii = ii + 1
    idNx <-sexData %>%filter(entryAge <= agev,
                             deparAge >= agev)
    delx[ii] <- length(which(sexData$DepartType == "D"  & sexData$deparAge ==agev))
    Cx[ii] <- 1- delx[ii]/nrow(idNx)
    
  }
  
  # Calculate product limit estimator:
  ple <- cumprod(Cx)
  ple[ple<0]=0
  
  # Add age 0:
  if (nage[1] > 0) {
    nage <- c(0, nage)
    ple <- c(1, ple)
    delx<- c(0, delx)
  }
  
  # Output:
  pleTab <- data.frame(Ages = nage, ple = ple, event = delx)
  
  return(pleTab)
}

```

```{r examples-Sur_ple}
entryAge = sample(c(1:10), 200, replace = TRUE)
data <- data.frame(
  entryAge = entryAge,
  deparAge =  entryAge + sample(c(0:10), 200, replace = TRUE),
  DepartType = sample(c('C', 'D'), 200, replace = TRUE))


out<-Sur_ple(data)
```

```{r tests-Sur_ple}
test_that("Sur_ple works", {
  entryAge = sample(c(1:10), 200, replace = T)
  data <- data.frame(
    entryAge = entryAge,
    deparAge =  entryAge + sample(c(0:10), 200, replace = T),
    DepartType = sample(c('C', 'D'), 200, replace = T))
  out<-Sur_ple(data)
  expect_named(out, c("Ages", "ple", "event"))
  expect_true(min(out$ple)>=0)
  expect_true(max(out$ple)<=1)
})
```


# Remaining life expectancy

`Sur_relex()` estimate the remaining life expectancy over ages. It includes the following arguments: 

* `theMat` including the posteriors estimates of the model parameter
* `model` names of the basta models to run: "G0", "EX", "LO" and/or "WE".
* `shape` character shape of the basta model: "simple", "Makeham", "bathtub". 
* `xMax` Maximum age in years
* `ncpus`; the number of core to use

```{r function-Sur_relex}
#' Remaining life expectancy
#' 
#' Estimate remaining life expectancy over age from the parameters outputs of a Basta model.
#' 
#'
#' @param theMat \code{array} including the posteriors estimates of the model parameter
#' @param model \code{character} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param ncpus  \code{numeric} Number of core to use
#' @param xMax \code{numeric} Maximum age in years Default = 120
#' @param dx \code{numeric} precision for age Default = 0.01
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#'
#' @return a data frame including age, the mean and 95% credible interval of the remaining life expectancy
#' 
#' @export
#' 
#' @importFrom paramDemo CalcSurv
#' @importFrom snowfall sfInit sfLibrary sfClusterApplyLB  sfStop
#' 
#' @examples
Sur_relex <- function(theMat, model = 'GO', shape = 'bathtub', ncpus = 1,
                      xMax = 120, dx = 0.01,minAge = 0) {
  
  assert_that(is.array(theMat))
  assert_that(is.numeric(xMax))
  assert_that(xMax > 1)
  assert_that(is.numeric(dx))
  assert_that(dx > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(model))
  assert_that(all(model %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  
  iseq <- floor(seq(0, nrow(theMat), length = ncpus + 1))
  xv <- seq(0, xMax, by = dx)
  
  # run parallel estimation:
  sfInit(parallel = TRUE, cpus = ncpus)
  # Upload paramDemo:
  # sfLibrary(paramDemo)
  # export variables:
  # sfExport(list = c("iseq", "theMat", "model", "shape", "xMax", "dx"))
  # Run parallel function:
  exparal <- sfClusterApplyLB(1:ncpus, Sur_relex_0, theMat = theMat,
                              model = model, shape = shape,  
                              iseq = iseq, 
                              xMax = xMax, dx = dx, xv = xv )
  
  # Stop application:
  sfStop()
  
  # Gather estimates:
  for (jj in 1:ncpus) {
    if (jj == 1) {
      exMat <- exparal[[jj]]
    } else {
      exMat <- rbind(exMat, exparal[[jj]])
    }
  }
  
  exQuants <- data.frame(Age = xv[which(xv <= xMax)] + minAge, 
                         RemLExp = apply(exMat, 2,quantile, 0.5), 
                         Lower = apply(exMat, 2, quantile, 0.025),
                         Upper = apply(exMat, 2, quantile, 0.975))
  return(exQuants)
}

```

```{r examples-Sur_relex}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))


out <- Sur_relex(theMat, model = 'GO', shape = 'simple', ncpus = 2,
                 xMax = 50, dx = 0.1)
```

```{r tests-Sur_relex}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))

test_that("Sur_relex works", {
  out <- Sur_relex(theMat, model = 'GO', shape = 'simple', ncpus = 2,
                   xMax = 50, dx = 0.1)
  expect_named(out, c("Age", "RemLExp", "Lower", "Upper"))
  expect_true(is.numeric(out$RemLExp))
})
```

```{r function-Sur_relex_0}
#' Raw remaining life expectancy
#'
#' @return a data frame including age, the mean and 95% credible interval of the remaining life expectancy
#' 
#' @importFrom paramDemo CalcSurv
#' 
#'
#' @examples
#' @noRd
Sur_relex_0 <- function(sim= 1, theMat ,model = 'GO', shape = 'bathtub',  
                        iseq = 1:nrow(theMat), xMax = 120, dx = 0.01 , xv = seq(0, xMax, by = dx)
) {
  
  idseq <- (iseq[sim] + 1):iseq[sim + 1]
  
  remex <- t(sapply(idseq, function(ith) {
    theta <- theMat[ith, ]
    Sx <- paramDemo::CalcSurv(theta = theta, x = xv, model = model, shape = shape)
    ex <- Sx * 0
    idn0 <- which(Sx > 0.001)
    ex[idn0] <- rev(cumsum(rev(Sx[idn0] * dx))) / Sx[idn0]
    return(ex)
  }))
  return(remex)
}
```



# Age-specific survival

`Sur_age()` estimate the age-specific survival. It includes the following arguments: 

* `theMat` including the posteriors estimates of the model parameter
* `model` names of the basta models to run: "G0", "EX", "LO" and/or "WE".
* `shape` character shape of the basta model: "simple", "Makeham", "bathtub". 
* `xMax` Maximum age in years
* `ncpus`; the number of core to use

```{r function-Sur_age}
#' Age-specific survival
#' 
#' Estimate age-specific survival (i.e. the probability to leave at least a given number of years) from the parameters outputs of a Basta model.
#' 
#'
#' @param theMat \code{array} including the posteriors estimates of the model parameter
#' @param Nyear \code{numeric} number of year to survive Default = 1#
#' @param model \code{character} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param ncpus  \code{numeric} Number of core to use
#' @param ageMax \code{numeric} Maximum age in years Default = 120
#' @param dage \code{numeric} precision  for age Default = 0.01
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#'
#' @return a data frame including age, the mean and 95% credible interval of the remaining life expectancy
#' 
#' @export
#' 
#' @importFrom paramDemo CalcSurv
#' @importFrom snowfall sfInit sfLibrary sfClusterApplyLB  sfStop
#' 
#' @examples
Sur_age <- function(theMat, Nyear = 1, model = 'GO', shape = 'bathtub', ncpus = 1,
                    ageMax = 120, dage = 0.01,minAge = 0) {
  
  assert_that(is.array(theMat))
  assert_that(is.numeric(ageMax))
  assert_that(ageMax >= 1)
  assert_that(is.numeric(Nyear))
  assert_that(Nyear > 0)
  assert_that(is.numeric(dage))
  assert_that(dage > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(model))
  assert_that(all(model %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  
  iseq <- floor(seq(0, nrow(theMat), length = ncpus + 1))
  xv <- seq(0, ageMax, by = dage)
  
  # run parallel estimation:
  sfInit(parallel = TRUE, cpus = ncpus)
  # Upload paramDemo:
  # sfLibrary(paramDemo)
  # export variables:
  # sfExport(list = c("iseq", "theMat", "model", "shape", "xMax", "dx"))
  # Run parallel function:
  exparal <- sfClusterApplyLB(1:ncpus, Sur_age_0, theMat = theMat,
                              model = model, shape = shape,  
                              iseq = iseq, Nyear = Nyear,
                              xv = xv )
  
  # Stop application:
  sfStop()
  
  # Gather estimates:
  for (jj in 1:ncpus) {
    if (jj == 1) {
      exMat <- exparal[[jj]]
    } else {
      exMat <- rbind(exMat, exparal[[jj]])
    }
  }
  exMat[is.nan(exMat)]=0
  exQuants <- tibble(Age = xv[1:ncol(exMat)]+minAge , 
                     Lower = apply(exMat, 2, quantile, 0.025),
                     Upper = apply(exMat, 2, quantile, 0.975))%>%
    mutate(Sur = apply(exMat, 2, mean))
  return(exQuants)
}

```

```{r examples-Sur_age}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))


out <- Sur_age(theMat, model = 'GO', shape = 'simple', ncpus = 2,
               ageMax = 50, dage = 0.1, Nyear = 5)
```

```{r tests-Sur_age}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))

test_that("Sur_age works", {
  out <- Sur_age(theMat, model = 'GO', shape = 'simple', ncpus = 2,
                 ageMax = 50, dage = 0.1, Nyear = 1)
  expect_named(out, c("Age", "Lower", "Upper", "Sur"))
  expect_true(is.numeric(out$Sur))
  expect_equal(nrow(out), 50*10-10+1)
})
```

```{r function-Sur_age_0}
#' Raw age specific survival
#'
#' @return a data frame including age, the mean and 95% credible interval of survival
#' 
#' @importFrom paramDemo CalcSurv
#' 
#'
#' @examples
#' @noRd
Sur_age_0 <- function(sim= 1, theMat ,model = 'GO', shape = 'bathtub',  
                      iseq = 1:nrow(theMat), Nyear = 1, 
                      xv = seq(0, 50, by = 0.01)
) {
  
  idseq <- (iseq[sim] + 1):iseq[sim + 1]
  dep = which(xv == Nyear)
  surage <- t(sapply(idseq, function(ith) {
    theta <- theMat[ith, ]
    Sx <- paramDemo::CalcSurv(theta = theta, x = xv, model = model, shape = shape)
    idn0 <- length(Sx)
    ex = Sx[dep:idn0]/Sx[1:(idn0-dep+1)]
    return(ex)
  }))
  return( surage)
}
```

# Maximum Longveity

`Sur_xx()` estimate the age at which xx% of the population is still alive. It includes the following arguments: 

* `theMat` including the posteriors estimates of the model parameter
* `model` names of the basta models to run: "G0", "EX", "LO" and/or "WE".
* `shape` character shape of the basta model: "simple", "Makeham", "bathtub". 
* `xx`  % of the population still alive
* `xMax` Maximum age in years
* `ncpus`; the number of core to use

```{r function-Sur_xx}
#' Maximum Longevity
#' 
#' Estimate Lxx: age at which xx% of the population is still alive
#' 
#' @param theMat \code{array} including the posteriors estimates of the model parameter
#' @param model \code{character} names of the basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the basta model: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param xx  \code{numeric} % of the population still alive
#' @param ncpus  \code{numeric} Number of core to use
#' @param ageMax \code{numeric} Maximum age in years Default = 120
#' @param dage \code{numeric} precision  for age Default = 0.01
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#'
#' @return a data frame including age, the mean and 95% credible interval of the L90
#' 
#' @export
#' 
#' @importFrom paramDemo CalcSurv
#' @importFrom snowfall sfInit sfLibrary sfClusterApplyLB  sfStop
#' 
#' @examples
Sur_xx <- function(theMat,  model = 'GO', shape = 'bathtub', ncpus = 1,
                   ageMax = 120, dage = 0.01, xx = 0.5, minAge =0) {
  
  assert_that(is.array(theMat))
  assert_that(is.numeric(ageMax))
  assert_that(ageMax >= 1)
  assert_that(is.numeric(dage))
  assert_that(dage > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.numeric(xx))
  assert_that(xx > 0)
  assert_that(xx <1)
  assert_that(is.character(model))
  assert_that(all(model %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  
  iseq <- floor(seq(0, nrow(theMat), length = ncpus + 1))
  xv <- seq(0, ageMax, by = dage)
  
  # run parallel estimation:
  sfInit(parallel = TRUE, cpus = ncpus)
  # Run parallel function:
  exparal <- sfClusterApplyLB(1:ncpus, Sur_xx_0, theMat = theMat,
                              model = model, shape = shape,  
                              iseq = iseq,  xv = xv , xx=xx)
  # Stop application:
  sfStop()
  
  # Gather estimates:
  for (jj in 1:ncpus) {
    if (jj == 1) {
      exMat <- exparal[[jj]]
    } else {
      exMat <- c(exMat, exparal[[jj]])
    }
  }
  
  out <- list(L = mean(exMat+minAge), Lower = quantile(exMat+minAge,0.025), Upper =  quantile(exMat+minAge,0.975))
  
  return(out)
}

```

```{r examples-Sur_90}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))


out <- Sur_xx(theMat, model = 'GO', shape = 'simple', ncpus = 2,
              ageMax = 50, dage = 0.1, xx = 0.1)
```

```{r tests-Sur_90}
theMat = as.matrix(data.frame( b0 = rnorm(10, -6, 0.01),
                               b1= rnorm(10, 0.1, 0.01)))

test_that("Sur_xx works", {
  out <- Sur_xx(theMat, model = 'GO', shape = 'simple', ncpus = 2,
                ageMax = 50, dage = 0.1, xx = 0.1)
  expect_named(out, c("L", "Lower", "Upper"))
  expect_true(is.numeric(out$L))
})
```


```{r function-Sur_90_0}
#' Age at which xx% of the population still alive
#'
#' @return Lxx
#' 
#' @importFrom paramDemo CalcSurv
#' 
#'
#' @examples
#' @noRd
Sur_xx_0 <- function(sim= 1, theMat ,model = 'GO', shape = 'bathtub',  
                     iseq = 1:nrow(theMat), xx =0.5,
                     xv = seq(0, 50, by = 0.01)
) {
  
  idseq <- (iseq[sim] + 1):iseq[sim + 1]
  surage <- t(sapply(idseq, function(ith) {
    theta <- theMat[ith, ]
    Sx <- paramDemo::CalcSurv(theta = theta, x = xv, model = model, shape = shape)
    Lxx <- xv[max(which(Sx>=xx))]
    return(Lxx)
  }))
  return(surage)
}
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_survival.Rmd", vignette_name = "Survival")
```

