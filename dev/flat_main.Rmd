---
title: "Load data and run taxon profiles"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(assertthat)
library(glue)
library(tidyverse)
library(checkmate)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Run Taxon Profiles

`run_txprofile()` loads the data needed and runs or updates demographic analyses for the list of species selected. It uses the following main arguments (see the help of the function for more):

* `taxa` 
* `Species_list
* `ZIMSdir` directory where to find data
* `AnalysisDir`  directory where to save results
* `PlotDir`: Directory to save the plots of the best models
* `extractDate `  Date of data extraction
* `minDate`  Earlier date to include data
* `Birth_Type` Captive, Wild, or All
* `Sections` names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro"
* `sexCats` Male, Female or/and All
* `models_sur` names of the survival basta models to run and compared: "G0", "EX", "LO" and/or "WE".
* `models_gro` indicating the growth models that need to be run and compared. The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial.

The result files are saved using the following directory \code{{analysisDir}\{taxa}\{species}.Rdata}, where `analysisDir` and `taxa` are argument of the function. `species` is the latin name of each species



```{r function-run_txprofile}
#' Run Taxon Profiles
#' 
#' Load data needed and run or update demographic analyses for the list of species selected
#'
#' @param taxa  \code{character} the name of the taxa studied
#' @param Species_list \code{vector of character} Species selected
#' @param ZIMSdir \code{character} directory where to find data
#' @param AnalysisDir \code{character} directory where to save results
#' @param PlotDir \code{character} Directory to save the plots. Default = NULL, no plot is saved
#' @param extractDate \code{character 'YYYY-MM-DD'} Date of data extraction
#' @param minBirthDate  \code{character}: Earlier possible date: date used when minimum birth or death date unknown
#' @param Birth_Type \code{character} Captive, Wild, or All. Default =  "Captive"
#' @param minDate \code{character 'YYYY-MM-DD'} Earlier date to include data
#' @param Sections \code{vector of character} names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro". Default = c("sur", "rep", "gro")
#' @param erase_previous \code{logical} whether the current result file should be deleted (before being replaced). Default = FALSE
#' @param sexCats \code{character} Male, Female or All Default =  "All"
#' @param Global \code{logical} Whether only individuals belonging to global collections should be used.
#' @param inparallel \code{logical} Whether this function is run in parallel on different computer. In other words: should the species list be divided? Default = FALSE
#' @param ipara \code{numeric} Id number of the computer used to select the species to run
#' @param npara \code{numeric} number of computers used in parallel
#' @param minN \code{numeric} Minimum number of individuals. Default = 50
#' @param maxOutl \code{numeric} Maximum threshold for the longevity distribution. Default = NULL
#' @param spOutLev \code{vector of character} List of species for which the Maximum threshold for the longevity distribution.XXXXXXXXXXXXXXXXXXXXXXXXX
#' @param minInstitution \code{numeric} Minimum number of institutions that should hold records to run the analyses. Default = 2
#' @param uncert_birth \code{numeric}: Maximum uncertainty accepted for birth dates, in days
#' @param uncert_death \code{numeric}: Maximum uncertainty accepted for death dates, in days. Default = 365
#' @param uncert_date \code{numeric}: Maximum uncertainty accepted for measurement dates: weight, in days. Default = 365
#' @param minNsur \code{numeric} Minimum number of individuals to run the survival analysis. Default = 50
#' @param maxNsur \code{numeric} Maximum number of individual records to run the survival analysis. Default = NULL
#' @param minlx  \code{numeric} between 0 and 1. Minimum reached survivorship from the raw Kaplan Meier analysis needed to run the survival analysis. Default = 0.1
#' @param MinBirthKnown  \code{numeric} between 0 and 1. Minimum proportion of individuals with a known birth month in the data. Default = 0.3
#' @param XMAX \code{numeric} Maximum possible age. Default = 120
#' @param Min_MLE \code{numeric} Goodness of fit: Minimum survivorship at Mean life expectancy
#' @param MaxLE \code{numeric} Goodness of fit: Maximum remaining life expectancy at max age
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#' @param firstyear \code{logical} Whether to do the analysis only on first year. Default = FALSE
#' @param models_sur \code{vector of characters} names of the survival basta models to run: "G0", "EX", "LO" and/or "WE". see ?basta for more information. Default = "GO"
#' @param shape \code{character} shape of the survival basta model to run: "simple", "Makeham", "bathtub".  see ?basta for more information. Default = "simple"
#' @param lastdead  \code{logical} Whether the longest lived individuals should be considered dead. Default = FALSE
#' @param niter  \code{numeric}. number of MCMC iterations to run the survival model. see ?basta for more information. Default = 25000
#' @param burnin  \code{numeric} Number of iterations removed so that the survival model has time to converge. see ?basta for more information. Default = 5001
#' @param thinning  \code{numeric} Number of iteration to run the survival model before saving a set of parameters. see ?basta for more information. Default = 20
#' @param nchain  \code{numeric} Number of chains to run the survival model. Default = 5001
#' @param ncpus  \code{numeric} Number of computer core to use. Default = 2
#' @param Repsect \code{character} names of the reproductive analyses to run: "agemat", "litter" and/or ...
#' @param Nday \code{numeric} Number of consecutive days over which the birth dates of a litter/clutch can be spread. Default = 7
#' @param parentProb_Dam \code{numeric} Minimum percentage of parentage probability to include for Dam. Default = 80
#' @param parentProb_Sire \code{numeric} Minimum percentage of parentage probability to include for Sire. Default = 80
#' @param minNlitter \code{numeric} Minimum number of litters to run the analysis. The data frame for litter size will be produced in all cases. Default = 30
#' @param minNrepro \code{numeric} Minimum number of birth records needed to run reproductive analyses. Default = 50
#' @param minNparepro \code{numeric} Minimum number of unique parent records needed to run reproductive analyses. Default = 30
#' @param minNseas \code{numeric} XXXXXXXXXXX
#' @param minNgro \code{numeric} Minimum number of weight needed to fit the growth models
#' @param minNIgro \code{numeric} Minimum number of unique individuals needed to fit the growth models
#' @param MeasureType \code{vector of characters} Name of the type of measurements that should be included.  Default = NULL, all measurement type are included.
#' @param models_gro \code{vector of characters} indicating the growth models that need to be fit.The following models are supported : logistic, gompertz, chapmanRichards, vonBertalanffy, polynomial. default = "vonBertalanffy"
#'
#' @return Save and replace the result file for each specie sin the list. The file is saved in {analysisDir}\\Rdata\\{taxa}_{species}.Rdata
#' @export
#'
#' @examples
run_txprofile <- function(taxa, Species_list, ZIMSdir, 
                          AnalysisDir, PlotDir,
                          extractDate, minDate = "1980-01-01",
                          Sections, erase_previous = FALSE,
                          sexCats = c('Male', 'Female'), minBirthDate = "1900-01-01",
                          inparallel = FALSE, ipara = 1, npara = 1, 
                          minN= 50,  maxOutl =99,  spOutLev = NULL, Global = TRUE,
                          uncert_birth = 365,  uncert_death = 365,  uncert_date = 365, 
                          minNsur = 50, maxNsur = NULL, minInstitution = 2,
                          minlx = 0.1, MinBirthKnown = 0.3, XMAX =120,
                          Min_MLE = 0.1, MaxLE = 2, minAge = 0,firstyear =FALSE,
                          models_sur = "GO", shape = "bathtub",
                          niter = 25000, burnin = 5001, thinning = 20, 
                          nchain = 3, ncpus = 2,
                          Repsect = c('agemat', 'litter'),
                          Birth_Type = "Captive", lastdead = FALSE,
                          parentProb_Sire = 80, parentProb_Dam = 80, minNlitter = 20,Nday = 7,
                          minNrepro = 100, minNparepro = 30, minNseas = 50, 
                          minNgro =100,minNIgro = 50, MeasureType = "Live weight",
                          models_gro = "vonBertalanffy"
                          
){
  
  assert_that(is.character(taxa))
  assert_that(is.character(Sections))
  assert_that(all(Sections %in% c("sur", "gro", "rep")))
  assert_that(is.character(Species_list))
  assert_that(is.logical(Global))
  minDate = lubridate::as_date(minDate)
  extractDate = lubridate::as_date(extractDate)
  assert_that(Birth_Type %in% c("Captive", "Wild", "All"))
  assert_that(is.logical( erase_previous))
  assert_that(is.logical(inparallel))
  assert_that(is.numeric( ipara))
  assert_that(is.numeric( npara))
  assert_that(ipara <= npara)
  assert_that(is.numeric( maxOutl))
  assert_that(is.numeric(minAge))
  assert_that(minAge>=0)
  assert_that(is.logical(firstyear))
  assert_that( maxOutl <= 100)
  assert_that(is.numeric(uncert_birth))
  assert_that(is.numeric(uncert_death))
  assert_that(is.numeric(uncert_date))
  assert_that(is.double(minInstitution))
  assert_that(is.numeric(Min_MLE))
  assert_that(is.numeric(MaxLE))
  assert_that(is.numeric(minNsur))
  assert_that(minNsur > 0)
  if(!is.null(maxNsur)) assert_that(is.numeric(maxNsur))
  assert_that(is.numeric(minlx))
  assert_that(minlx > 0)
  assert_that(minlx < 1)
  assert_that(is.numeric(MinBirthKnown))
  assert_that(MinBirthKnown >= 0)
  assert_that(MinBirthKnown <1)
  assert_that(is.numeric(niter))
  assert_that(niter > 0)
  assert_that(is.numeric(burnin))
  assert_that(burnin > 0)
  assert_that(burnin < niter)
  assert_that(is.numeric(thinning))
  assert_that(thinning > 0)
  assert_that(thinning < niter)
  assert_that(is.numeric(nchain))
  assert_that(nchain > 0)
  assert_that(is.numeric(ncpus))
  assert_that(ncpus > 0)
  assert_that(is.character(models_sur))
  assert_that(all(models_sur %in% c("GO", "EX", "LO", "WE")))
  assert_that(is.character(shape))
  assert_that(all(shape %in% c("simple", "bathtub", "Makeham")))
  assert_directory_exists(ZIMSdir)
  assert_directory_exists(AnalysisDir)
  assert_directory_exists(glue("{AnalysisDir}/Rdata"))
  assert_directory_exists(PlotDir)
  
  assert_that(all(Repsect %in% c("agemat", "litter")))
  assert_that(is.numeric(parentProb_Dam))
  assert_that(parentProb_Dam > 0)
  assert_that(is.numeric(parentProb_Sire))
  assert_that(parentProb_Sire > 0)
  assert_that(is.numeric(minNrepro))
  assert_that(minNrepro > 0)
  assert_that(is.numeric(minNparepro))
  assert_that(minNparepro > 0)
  assert_that(is.numeric(minNlitter))
  assert_that(minNlitter > 0)
  assert_that(is.numeric( minNseas))
  assert_that( minNseas > 0)
  assert_that(is.numeric( Nday))
  assert_that( Nday >= 0)
  
  assert_that(is.numeric( minNIgro))
  assert_that( minNIgro > 0)
  assert_that(is.numeric(minNgro))
  assert_that(minNgro > 0)
  assert_that(is.character(MeasureType))
  assert_that(is.character(models_gro ))
  assert_that(all(models_gro %in% c("logistic", "gompertz", "chapmanRichards", "vonBertalanffy", "polynomial", "gam")), msg = "The growth models supported are: logistic, gompertz, chapmanRichards, vonBertalanffy, and polynomial, in addition to GAM.")
  
  assert_that(is.character( sexCats))
  assert_that(all(sexCats %in% c("Male", "Female", "All")))
  
  
  
  # ======================#
  # ==== Load data ========
  # ======================#
  cat("Loading Data\n")
  tables = c("Collection")
  if("sur" %in% Sections){
    tables = c(tables, "DeathInformation")
  }
  if("gro" %in% Sections){
    tables = c(tables, "Weight")
  }
  if("rep" %in% Sections){
    tables = c(tables, "Parent", "Contraception", "Move")
  }
  species_list = list()
  species_list [[taxa]] = Species_list
  data <- Load_Zimsdata	(taxa = taxa, ZIMSdir = ZIMSdir, 
                         species = species_list,
                         Animal = TRUE,
                         tables = tables,
                         silent = TRUE) 
  
  # ======================#
  # ==== Species List =====
  # ======================#
  if(all(Species_list == "All")){
    spAll <- unique(data[[taxa]]$Animal$binSpecies)%>%
      stringr::str_subset(pattern = ' sp.', negate = TRUE)
  }else{
    spAll <-Species_list
  }
  if (inparallel){
    # IDs of species to run per version:
    idsprun <- seq(ipara, length(spAll), by = npara)
  }else{
    idsprun <- c(1:length(spAll))}
  
  # ======================#
  # ==== RUN ANALYSES: ====
  # ======================#
  core <- Prep_Animal(data[[taxa]]$Animal, extractDate= extractDate,minBirthDate =minBirthDate )
  # #subset Tables
  if("sur" %in% Sections){
    DeathInformation <- data[[taxa]]$DeathInformation
  }else{DeathInformation <- NULL}
  if("gro" %in% Sections){
    weights = data[[taxa]]$Weight
  }else{
    weights <-NULL
  }
  if("rep" %in% Sections){
    parents = data[[taxa]]$Parent
    move = data[[taxa]]$Move
    contraceptions = data[[taxa]]$Contraception
  }else{
    parents =contraceptions = move = NULL
  }
  
  # Start counter:
  icount <- 0
  
  # Loop over species
  for (isp in idsprun) {
    # Extract species:
    species <- spAll[isp]
    
    # # progress count:
    icount <- icount + 1
    
    
    # Report progress:
    cat("\n====================\nClass:   ", taxa, "\nSpecies: ", species, 
        "\nProgress:", round(icount / length(idsprun) * 100, 0), 
        "%\n=====================\n")
    cat("Species running...\n ")
    
    speciesname = stringr::str_replace(species, " ", "_")
    
    #Load previous taxon profile to update it
    if(erase_previous){
      repout = list()
    }else{
      if(length(list.files(glue::glue("{AnalysisDir}/Rdata/"), glue::glue("{taxa}_{speciesname}.RData")))>0){
        load(glue::glue("{AnalysisDir}/Rdata/{taxa}_{speciesname}.RData"))
      }else{repout = list()}
    }
    if (species %in% spOutLev) {maxOutl1 <- 99.9
    }else{maxOutl1 <- maxOutl}
    
    
    # Create report:
    repout <- tx_report(species, taxa, 
                        Animal =  core, collection = data[[taxa]]$Collection, 
                        DeathInformation = DeathInformation,
                        PlotDir = PlotDir, extractDate= extractDate, minBirthDate = minBirthDate,
                        weights = weights, parents = parents, contraceptions = contraceptions, move = move,
                        repout = repout, Sections = Sections, Birth_Type = Birth_Type,
                        sexCats = sexCats, minN= minN, minDate= minDate, Global = Global,
                        uncert_birth = uncert_birth, uncert_death= uncert_death,
                        uncert_date = uncert_date,minAge =minAge,firstyear = firstyear,
                        maxOutl = maxOutl1, minlx = minlx, minInstitution = minInstitution,
                        minNsur = minNsur, maxNsur = maxNsur, MinBirthKnown = MinBirthKnown,
                        Min_MLE = Min_MLE, MaxLE =  MaxLE,XMAX = XMAX,
                        models_sur = models_sur, shape = shape,lastdead = lastdead,
                        niter = niter, burnin =  burnin, thinning = thinning,
                        nchain = nchain,  ncpus = ncpus,
                        Repsect = Repsect, parentProb_Dam = parentProb_Dam,
                        parentProb_Sire = parentProb_Sire, minNrepro = minNrepro,
                        minNlitter = minNlitter, Nday = Nday,
                        minNparepro = minNparepro, minNseas = minNseas, 
                        minNgro =minNgro,minNIgro = minNIgro, 
                        MeasureType = MeasureType, models_gro = models_gro
    )
    
    # ----------------------- #
    # ---- Save results: ----
    # ----------------------- #
    # Save species list:
    save("repout", file = glue::glue("{AnalysisDir}/Rdata/{taxa}_{speciesname}.RData"))
    cat(" done.\n")
  }
}

```

```{r examples-run_txprofile}
# Here is an example but use directly your own ZIMSdir (directory to find data) 
# and analysisDir (directory to save analysis)
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSdir = dirname(file)
AnalysisDir = paste0(tempdir(check = TRUE),'\\temp')
PlotDir = paste0(tempdir(check = TRUE),'\\temp\\plot')
dir.create(AnalysisDir)
dir.create(paste0(tempdir(check = TRUE),'\\temp\\Rdata'))
dir.create(PlotDir)

#This code run the survival analysis
run_txprofile(taxa = "Reptilia", Species_list = "All",
              ZIMSdir = ZIMSdir, AnalysisDir = AnalysisDir,
              PlotDir = PlotDir,
              extractDate = "",
              minDate = "1980-01-01",
              Sections = c("sur"),
              sexCats = c('Male', 'Female'),
              niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3
)

list.files(PlotDir)
list.files(paste0(AnalysisDir,'\\Rdata'))

unlink(AnalysisDir, recursive = TRUE)
unlink(PlotDir, recursive = TRUE)

```


```{r dev-run_txprofile}
# Here is an example but use directly your own ZIMSdir (directory to find data) 
# and analysisDir (directory to save analysis)
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSdir = dirname(file)
PlotDir = paste0(tempdir(check = TRUE),'\\temp')
dir.create(PlotDir)

#This code run the survival analysis
run_txprofile(taxa = "Reptilia", Species_list = "All",
              ZIMSdir = ZIMSdir, AnalysisDir = ZIMSdir,
              PlotDir = PlotDir,minlx=0.4,
              extractDate = "", MeasureType="Live weight",
              minDate = "1980-01-01",
              Sections = c("sur",'rep',"gro"),
              sexCats = c('Male', 'Female'),
              niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3
)

list.files(PlotDir)
unlink(PlotDir, recursive = TRUE)
```



```{r tests-run_txprofile}
test_that("run_txprofile works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSdir = dirname(file)
  PlotDir = paste0(tempdir(check = TRUE),'\\tem')
  dir.create(PlotDir)
  
  #This code run the survival analysis
  run_txprofile(taxa = "Reptilia", Species_list = "All",
                ZIMSdir = ZIMSdir, AnalysisDir = ZIMSdir,
                PlotDir = PlotDir, MeasureType="Live weight",
                extractDate = "",minlx=0.4,
                minDate = "1980-01-01",
                Sections = "sur",
                sexCats = c('Male', 'Female'),
                niter = 1000, burnin = 101, thinning = 10, nchain = 3, ncpus = 3
  )
  
  expect_true(file.exists(paste(ZIMSdir, "Rdata\\Reptilia_Testudo_hermanni.Rdata", sep = '\\')))
  unlink(PlotDir, recursive = TRUE)
  
})

```

# Summary tables & plots

`make_summary()` produces summary tables and plots of the demographic analyses made for all species. It uses the following arguments:

* `AnalysisDir` character} directory where to find the .Rdata files
* `SaveDir` character} directory where to save summary plots and tables
* `taxaList` names of the taxa studied.
* `BySex` list of the taxa names indicating the sexes analyzed. 
* `Sections` names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro"

it returns the main summary table

```{r function-make_summary}
#' Summarize taxon profiles analyses
#' 
#' Produce summary tables and plots of the demographic analyses made for all species
#'
#' @param AnalysisDir  \code{character} directory where to find the .Rdata files
#' @param SaveDir  \code{character} directory where to save summary plots and tables
#' @param namefile \code{character} Suffix to add to the name of files produced if needed. Default = ""
#' @param taxaList \code{vector of character} names of the taxa studied. Default= "Mammalia"
#' @param BySex \code{list} of the taxa names indicating the sexes analyzed. Default=list(Mammalia = c("Male", "Female"))
#' @param Sections \code{vector of character} names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro". Default = c("sur", "rep", "gro")
#' @param minAge \code{numeric} Ages at which the analyses should start.  see ?basta for more information. Default = 0
#' @param firstyear \code{logical} Whether to do the analysis only on first year. Default = FALSE
#'
#' @return It saves summary tables and plots for each Sections and a general summary table. It returns the main summary table
#' @export
#' 
#' @importFrom ggplot2 ggplot scale_fill_brewer facet_wrap geom_bar labs position_dodge coord_flip
#' @importFrom ggpubr ggarrange
#' 
#' @examples
make_summary <- function (AnalysisDir, SaveDir, namefile = "",
                          taxaList = "Mammalia", 
                          BySex = list(Mammalia = c("Male", "Female")) , 
                          Sections = c("sur", 'rep', 'gro'), minAge = 0, firstyear = FALSE
){
  nullToNA <- function(x) {
    x[sapply(x, is.null)] <- NA
    return(x)
  }
  assert_that(is.character(taxaList))
  # assert_that(taxaList %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
  #                             "Chondrichthyes", "Actinopterygii"),
  #             msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
  #                         'Chondrichthyes', or 'Actinopterygii'")
  assert_that(is.character(Sections))
  assert_that(all(Sections %in% c("sur", "gro", "rep")))
  checkmate::assert_directory_exists(AnalysisDir)
  checkmate::assert_directory_exists(SaveDir)
  assert_that(is.character(namefile))
  assert_that(is.list(BySex))
  assert_that(all(taxaList %in% names(BySex)), msg = "BySex should be a list with names identical to taxaList")
  assert_that(is.numeric(minAge))
  assert_that(minAge>=0)
  assert_that(is.logical(firstyear))
  
  # List of available SRGs:
  SRGlist <- list.files(AnalysisDir, pattern = ".RData")
  assert_that(length(SRGlist) > 0, 
              msg = glue::glue("There are no result file in {AnalysisDir}"))
  SRGsps <- gsub(".RData", "", SRGlist)
  
  
  # Start counter:
  icount <- 0
  for (taxa in taxaList) {
    
    SRGsps_ta = SRGsps%>%stringr::str_subset(taxa)
    SRGspecies <- SRGsps_ta%>%
      stringr::str_remove(pattern = paste0(taxa, '_'))%>%
      stringr::str_replace("_", " ")
    
    sexCats <- BySex [[taxa]]
    
    icount <- icount + 1
    
    table<-tibble(Class = rep(taxa, length(SRGsps_ta)),
                  Species = SRGspecies,
                  Sex = "All",
                  Nraw = numeric(1),
                  Ndate = numeric(1),
                  Nglobal = numeric(1),
                  Nbirthtype = numeric(1),
                  Nuncertbirth = numeric(1),
                  Nalive = numeric(1),
                  firstDate = as.Date(x = integer(1), origin = "1980-01-01"),
                  maxAgeraw = numeric(1),
                  extractdate =  as.Date(x = integer(1), origin = "1980-01-01"),
                  
    )
    AnyAna<- tibble(Class = rep(taxa, length( SRGsps_ta )*length(sexCats)),
                    Species = rep(SRGspecies, each = length(sexCats)),
                    Sex = rep(sexCats, length(SRGspecies)),
                    Nselect = numeric(1),
                    Nlifespan = numeric(1),
                    GapThresh = numeric(1),
                    NThres = numeric(1))
    # Taxa data table:
    if ("sur" %in% Sections){
      models = paste0("from", minAge)
      if(firstyear) models = c(models, "firstyear")
      tempsur <- tibble(Class = rep(taxa, length( SRGsps_ta )*length(sexCats)*length(models)),
                        Species = rep(SRGspecies, each = length(sexCats)*length(models)),
                        Sex = rep(rep(sexCats,each = length(models)), length(SRGspecies)),
                        model = rep(models, length(SRGspecies)*length(sexCats)),
                        NSelect  = numeric(1), 
                        NUncertdeath = numeric(1), 
                        NBasta = numeric(1), 
                        Ndead = 0, 
                        lxMin = numeric(1),
                        maxAlive = numeric(1),
                        outLev = numeric(1),
                        analyzed = FALSE, 
                        Nerr = 1, 
                        error = "Nselect < minN",
                        Gof_KM_coeff1 = numeric(1),
                        Gof_KM_coeff2 = numeric(1))
      Finsur =  tibble( Species = character(0),
                        Sex = character(0),
                        model = character(0),
                        Life_expe = numeric(0), 
                        Remex0 = numeric(0), 
                        # Remex1 = numeric(0), 
                        L50 = numeric(0), 
                        L90 = numeric(0)
      )
      
    }else{tempsur = tibble()}
    if ("gro" %in% Sections){
      tempgro <-  tibble(Class = rep(taxa, length( SRGsps_ta )*length(sexCats)),
                         Species = rep(SRGspecies, each = length(sexCats)),
                         Sex = rep(sexCats, length(SRGspecies)),
                         NWeight_raw = numeric(1), NInd_raw = numeric(1), 
                         NWeight_val = numeric(1), NInd_val = numeric(1), 
                         agemat = numeric(1), 
                         NJuv = numeric(1),NJuv_keep = numeric(1),
                         NAd = numeric(1), NAd_keep = numeric(1),
                         NWeight = numeric(1), NInd = numeric(1), 
                         analyzed = FALSE, 
                         Nerr = 1, 
                         error = "Nselect < minN",)
    }else{tempgro = tibble()}
    if ("rep" %in% Sections){
      temprep <-  tibble(Class = rep(taxa, length( SRGsps_ta )*length(sexCats)),
                         Species = rep(SRGspecies, each = length(sexCats)),
                         Sex = rep(sexCats, length(SRGspecies)),
                         Nbirths = numeric(1),
                         Nadults= numeric(1),
                         NOffsp= numeric(1),
                         NParent= numeric(1),
                         NOffsp_age=numeric(1),
                         NParent_age=numeric(1),
                         analyzed = FALSE, 
                         Nerr = 1, 
                         error = "Nselect < minN",
                         amat_analyzed = logical(1),  
                         litt_analyzed = logical(1))
    }else{temprep = tibble()}
    i = 0
    # Loop over species
    for (isp in SRGsps_ta) {
      i = i+1
      specie =isp%>%
        stringr::str_remove(pattern = paste0(taxa, '_'))%>%
        stringr::str_replace("_", " ")
      
      cat("\n", taxa,": ", SRGspecies[i], "--", round(i / length(SRGsps_ta) * 100, 1),"%")
      
      # SRG file:
      load(glue::glue("{AnalysisDir}/{isp}.RData"))
      
      table = table%>%
        rows_update(repout$general%>%nullToNA%>%as_tibble %>% 
                      mutate(Species = specie, Sex = "All"), 
                    by = c("Species", "Sex"), unmatched = "ignore")
      
      # Fill up data list:
      for (sx in sexCats) {
        if(length(repout$summar[[sx]])>0){
          AnyAna = AnyAna%>%
            rows_update(repout$summar[[sx]]%>%nullToNA%>%as_tibble() %>% 
                          mutate(Species = specie, Sex = sx), 
                        by = c("Sex", "Species"), unmatched = "ignore")
        }
        if("sur" %in% Sections){
          nam = names(repout$surv[[sx]])
          for( n in 1:length(nam)){
            if(length(repout$surv[[sx]][[n]]$summary)>0){
              tempsur <- tempsur%>%
                rows_update(repout$surv[[sx]][[n]]$summary%>%nullToNA%>%
                              as_tibble() %>% dplyr::select(-maxAge)%>%
                              mutate(Species = specie, Sex = sx, model = nam[[n]]), 
                            by = c("Sex", "Species", "model"), unmatched = "ignore")
              
              MLE = tibble( Species = specie, Sex = sx, model = nam[[n]],
                            Life_expe= repout$surv[[sx]][[n]]$bastaRes$PS$nocov$PS[1,1], 
                            Remex0 = repout$surv[[sx]][[n]]$relex$RemLExp[c(1)], 
                            # Remex1 = repout$surv[[sx]][[n]]$relex$RemLExp[c(101)],
                            L50 = repout$surv[[sx]][[n]]$L50$L, L90 = repout$surv[[sx]][[n]]$L90$L)  
              Finsur = Finsur%>%rows_append(MLE)
              
            }}
        }
        if("gro" %in% Sections){
          if(length(repout$weig[[sx]]$Captive$wSummar)>0){
            tempgro <- tempgro%>%
              rows_update(repout$weig[[sx]]$Captive$wSummar%>%nullToNA%>%as_tibble() %>% 
                            mutate(Species = specie, Sex = sx), 
                          by = c("Sex", "Species"), unmatched = "ignore")
          }
        }
        if("rep" %in% Sections){
          if(length(repout$rep[[sx]]$summary)>0){
            temprep <- temprep%>%
              rows_update(repout$rep[[sx]]$summary%>%as_tibble() %>% 
                            mutate(Species = specie, Sex = sx), 
                          by = c("Sex", "Species"), unmatched = "ignore")
          }}
      }
    }
    tempsur <- tempsur%>%
      left_join(  Finsur, by = c("Sex", "Species", "model") )
    if (icount == 1) {
      SummTab <-table
      SurTab <- tempsur
      RepTab <- temprep
      GroTab <- tempgro
    } else {
      SummTab <- rbind(SummTab, table)
      SurTab <- rbind(SurTab, tempsur)
      RepTab <- rbind(RepTab, temprep)
      GroTab <- rbind(GroTab, tempgro)
    }
    
  }
  
  if("sur" %in% Sections){  
    AnyAna <-AnyAna%>%
      left_join(SurTab%>%
                  select(c(Species, Sex, NBasta, analyzed, error))%>%
                  rename(Surv_Ana = analyzed, Surv_error = error), 
                by = c("Species", "Sex"))
    
    utils::write.csv(SurTab, file = glue::glue("{SaveDir}/SRGs_Survival{namefile}.csv"),
                     row.names = FALSE)
    readr::write_excel_csv2(SurTab, file = glue::glue("{SaveDir}/SRGs_Survival{namefile}2.csv"))
    
    Surtabsum <- SurTab %>% 
      mutate(error =ifelse(error =="", "Analyzed",error),
             error = factor(error, levels = c('Analyzed','Nselect < minN','Nuncertdeath < minNsur', 
                                              "NBasta = 0", "%known births < MinBirthKnown",
                                              "Data from 1 Institution","Nbasta > maxNsur",
                                              "Nbasta < minNsur",
                                              "lxMin > minlx",
                                              "no DIC from Basta", 
                                              "Kaplan-Meier does not fit",
                                              "lx[MLE] < Min_MLE",
                                              "Min(Life_exp) >= MaxLE",
                                              "Kaplan-Meier does not fit:2"), 
                            ordered = T)) %>% 
      group_by(Class, Sex, error)%>% summarize(N = n())
    p<- ggplot(data = Surtabsum, aes(x = error, y = N, fill = Sex)) +
      geom_bar(stat = "identity", position = position_dodge()) +
      scale_fill_brewer(palette = "Spectral")+
      labs(x = "") + facet_wrap(~ Class, scales = "free")+
      coord_flip()
    ggsave( glue::glue("{SaveDir}/Survival_error{namefile}.pdf"), p, width = 20, height = 6)
    
  }
  
  # if("rep" %in% Sections){ 
  #   AnyAna <-AnyAna%>%
  #     left_join(RepTab%>%
  #                 select(Species, Sex, NOffsp_raw, NParent_raw, NOffsp,NParent, 
  #                        NAdult_rep, Fert_Analyzed,Fert_error,
  #                        NOffsp_prob,NParent_prob, NReprEvent,Litt_Analyzed,Litt_error,
  #                        SeasNorth_Analyzed, SeasNorth_error, SeasNorth_Nbirth,
  #                        SeasSouth_Analyzed, SeasSouth_error, SeasSouth_Nbirth)%>%
  #                 rename(Fert_Ana = Fert_Analyzed,
  #                        Litt_Ana = Litt_Analyzed,
  #                        SeasNorth_Ana = SeasNorth_Analyzed,
  #                        SeasSouth_Ana = SeasSouth_Analyzed), 
  #               by = c("Species", "Sex"))
  #   
  #   
  #   utils::write.csv(RepTab, file =  glue::glue("{SaveDir}/SRGs_Reproduction{namefile}.csv", globDir),
  #                    row.names = FALSE)
  #   
  #   Ferttabsum <- RepTab  %>% tidyr::drop_na(Fert_error)%>% 
  #     mutate(Fert_error = ifelse(Fert_error =="", "Analyzed",Fert_error),
  #            Fert_error = factor(Fert_error, levels =c('Analyzed','NThres == 0', 
  #                                                      "NAdult == 0", "NOffspr_age == 0",
  #                                                      "NParent_bd == 0", 
  #                                                      "Data from 1 Institution",
  #                                                      "NOffsp < minNrepro",
  #                                                      "NParent < minNparepro"), 
  #                                ordered = T)) %>% 
  #     group_by(Class, Sex, Fert_error)%>% summarize(N = n())
  #   fert<- ggplot(data=Ferttabsum, aes(x=Fert_error, y=N, fill=Sex)) +
  #     geom_bar(stat="identity", position=position_dodge()) +
  #     scale_fill_brewer(palette="Spectral")+
  #     labs(x = "Fertility")+
  #     facet_wrap(~Class, nrow = 1, scales = "free")+
  #     coord_flip()
  #   Litttabsum <- RepTab  %>% tidyr::drop_na(Litt_error) %>% 
  #     filter(Sex!="Male")%>%
  #     mutate(Litt_error =ifelse(Litt_error =="", "Analyzed",Litt_error),
  #            Litt_error =ifelse(Litt_error =="NOffsp  < minNrepro",
  #                               "NOffsp < minNrepro",Litt_error),
  #            Litt_error = factor(Litt_error, levels = c('Analyzed','NThres == 0', 
  #                                                       "NParent_bd == 0", 
  #                                                       "NAdult == 0", "NOffspr_age == 0",
  #                                                       "NOffsp < minNrepro", 
  #                                                       "NParent < minNparepro",
  #                                                       "Data from 1 Institution",
  #                                                       "NOffsp_prob < minNrepro"), 
  #                                ordered = T))%>% 
  #     group_by(Class, Sex, Litt_error)%>% summarize(N = n())
  #   lit<- ggplot(data=Litttabsum, aes(x=Litt_error, y=N, fill=Sex)) +
  #     geom_bar(stat="identity", position=position_dodge()) +
  #     scale_fill_brewer(palette="Spectral")+
  #     labs(x = "Litter Size")+
  #     facet_wrap(~Class, nrow = 1, scales = "free")+
  #     coord_flip()
  #   SeaNtabsum <- RepTab  %>% tidyr::drop_na(SeasNorth_error)%>%
  #     filter(Sex=="Female" | Class == "Actinopterygii")%>%
  #     mutate(SeasNorth_error =ifelse(SeasNorth_error =="", "Analyzed",SeasNorth_error),
  #            SeasNorth_error = factor(SeasNorth_error, levels = c('Analyzed',"NThres == 0", 
  #                                                                 "No exact birth month",
  #                                                                 "Data from 1 Institution",
  #                                                                 "Nbirth <= minNseas"), 
  #                                     ordered = T)) %>% 
  #     group_by(Class, SeasNorth_error)%>% summarize(N = n())
  #   seaN<- ggplot(data=SeaNtabsum, aes(x=SeasNorth_error, y=N)) +
  #     geom_bar(stat="identity", position=position_dodge()) +
  #     labs(x = "Seasonality North")+
  #     facet_wrap(~Class, nrow = 1, scales = "free")+
  #     coord_flip()
  #   SeaStabsum <- RepTab  %>% tidyr::drop_na(SeasSouth_error)%>% 
  #     filter(Sex=="Female" | Class == "Actinopterygii")%>%
  #     mutate(SeasSouth_error =ifelse(SeasSouth_error =="", "Analyzed",SeasSouth_error),
  #            SeasSouth_error = factor(SeasSouth_error, levels = c('Analyzed',"NThres == 0", 
  #                                                                 "No exact birth month", 
  #                                                                 "Data from 1 Institution",
  #                                                                 "Nbirth <= minNseas"), 
  #                                     ordered = T)) %>% 
  #     group_by(Class, SeasSouth_error)%>% summarize(N = n())
  #   seaS<- ggplot(data=SeaStabsum, aes(x=SeasSouth_error, y=N)) +
  #     geom_bar(stat="identity", position=position_dodge()) +
  #     labs(x = "Seasonality South")+
  #     facet_wrap(~Class, nrow = 1, scales = "free")+
  #     coord_flip()
  #   figure <- ggarrange(fert, lit, seaN,seaS,
  #                       # labels = c("A", "B", "C"),
  #                       ncol = 1, nrow = 4)
  #   ggsave( glue::glue("{SaveDir}/Reproduction_error{namefile}.pdf"), figure, width = 25, height = 15)
  #   
  # }          
  # 
  if("gro" %in% Sections){            
    AnyAna <-AnyAna%>%
      left_join(GroTab%>%
                  select(Species, Sex, NWeight_raw , NWeight, analyzed,error)%>%
                  rename(Gro_Ana = analyzed, Gro_error = error), 
                by = c("Species", "Sex"))
    
    
    utils::write.csv(GroTab, file = glue::glue("{SaveDir}/SRGs_Growth{namefile}.csv"),
                     row.names = FALSE)
    
    Grotabsum <- GroTab  %>% tidyr::drop_na(error)%>% 
      mutate(error =ifelse(error =="", "Analyzed",error),
             error = factor(error, levels = c('Analyzed',"No known Sex", 
                                              "No weight for this sex category",
                                              "No valid weight measure", "Data from 1 Institution",
                                              "NWeight < minNgro", "NInds < minNIgro", "Model did not fit"), 
                            ordered = T)) %>%
      group_by(Class, Sex, error)%>% summarize(N = n())
    p<- ggplot(data=Grotabsum, aes(x=error, y=N, fill=Sex)) +
      geom_bar(stat="identity", position=position_dodge()) +
      scale_fill_brewer(palette="Spectral")+
      labs(x = "Growth")+facet_wrap(~Class, nrow = 2, scales = "free")+
      coord_flip()
    ggsave( glue::glue("{SaveDir}/Growth_error{namefile}.pdf"), p, width = 20, height = 6)
    
  }
  
  
  AnyAna <-AnyAna%>%
    rowwise%>%
    mutate( Any_Ana = any(across(ends_with("Ana"))),
            All_Ana = all(across(ends_with("Ana"))))
  utils::write.csv(AnyAna, file =  glue::glue("{SaveDir}/SRGs_Any_Ana{namefile}.csv"),
                   row.names = FALSE)
  
  
  utils::write.csv(SummTab, file =  glue::glue("{SaveDir}/SRGs_Analyses{namefile}.csv"),
                   row.names = FALSE)
  return(SummTab)
}
```

```{r examples-make_summary}
file = system.file("sci_Animal.csv", package = 'ISRverse')
AnalysisDir  = paste0(dirname(file),'\\Rdata')
SaveDir = paste0(tempdir(check = TRUE),'\\temp')
dir.create(SaveDir)

SummTab <- make_summary(AnalysisDir, SaveDir,
                        taxaList = "Reptilia",
                        BySex = list(Reptilia = c("Male", "Female")) ,
                        Sections = c("sur", 'gro')
)
list.files(SaveDir)

unlink(SaveDir, recursive = TRUE)
```

```{r tests-make_summary}

test_that("make_summary works", {
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  AnalysisDir  = paste0(dirname(file),'\\Rdata')
  TempDir = paste0(tempdir(check = TRUE),'\\temp')
  dir.create(TempDir,showWarnings =FALSE)
  
  SummTab <- make_summary(AnalysisDir, TempDir,
                          taxaList = "Reptilia",
                          BySex = list(Reptilia = c("Male", "Female")) ,
                          Sections = c("sur", 'gro')
  )
  expect_true(file.exists(paste(TempDir, 'Survival_error.pdf', sep = '\\')))
  expect_true(file.exists(paste(TempDir, 'SRGs_Survival.csv', sep = '\\')))
  expect_true(file.exists(paste(TempDir, 'Growth_error.pdf', sep = '\\')))
  expect_true(file.exists(paste(TempDir, 'SRGs_Growth.csv', sep = '\\')))
  expect_true(file.exists(paste(TempDir, 'SRGs_Analyses.csv', sep = '\\')))
  expect_named(SummTab , c("Class", "Species", "Sex", "Nraw", "Ndate", "Nglobal", 
                           "Nbirthtype", "Nuncertbirth","Nalive", "firstDate", 
                           "maxAgeraw","extractdate"))
  
  unlink(TempDir, recursive = TRUE)
})

```

# Load zims core data

`Load_Zimsdata()` load ZIMS data frames of the taxa selected in a list. It uses the following arguments:

* `taxa` the name of the taxa studied
* `ZIMSdir` directory where to find data
* `species` names of the species studied
* `Animal` Whether the core animal data should be loaded
* `tables` of data to load: "Contraception", "HealthStatus", "Institution","InstitutionAssociation", "Move","Parent", "Weight", "Length","DeathInformation", and/or "Collection".

```{r function-Load_Zimsdata}
#' Load Zims data
#' 
#' Check if selected data are already in the global environment. If not, it load them.
#'
#' @param taxa  \code{character} the name of the taxa studied
#' @param ZIMSdir \code{character} directory where to find data
#' @param species  \code{list of character} names of the species studied. A list per taxa name should be used, or Default = "All"
#' @param Animal \code{logical} Whether the core animal data should be loaded Default = TRUE
#' @param tables \code{vector character} the type of data to load. 
#' @param silent \code{logical} Whether information of advancement should be printed
#' 
#' @details
#' \code{type} can take the following values : "Contraception", "HealthStatus", "DeathInformation","Institution","InstitutionAssociation", "Move","Parent", "Weight", "Length","DeathInformation", "Collection"
#'
#' @return A list of the data frames
#' @importFrom glue glue
#' @importFrom utils read.csv
#' @importFrom checkmate assert_directory_exists
#' @export
#'
#' @examples
Load_Zimsdata	<- function (taxa, ZIMSdir,
                           species ,
                           Animal = FALSE,
                           tables = c(),
                           silent = FALSE) 
{ 
  out <- list()
  checkmate::assert_directory_exists(ZIMSdir)
  assert_that(is.character(taxa))
  
  idtaxa <- list.files(glue::glue("{ZIMSdir}/"), "Split")%>%
    stringr::str_remove("Split_")
  assert_that(taxa %in% c(idtaxa, "All"),
              msg = glue::glue("taxa must one of {stringr::str_flatten_comma(idtaxa)}, or 'All'"))
  if (taxa == "All") taxa = c("Mammalia", "Aves", "Reptilia", "Amphibia", 
                              "Chondrichthyes", "Osteichthyes")
  assert_that(is.logical( silent))
  assert_that(is.list(species))
  assert_that (all(taxa %in% names(species)), 
               msg = "species must be a list with the different taxa as names")
  if(length(tables)>0){  
    assert_that(is.character(tables))
    assert_that(all(tables %in%  c("Contraception", "HealthStatus", 
                                   "Institution","InstitutionAssociation", 
                                   "Move","Parent", "Weight", "Length",
                                   'DeathInformation', 'Collection')), msg = "The table names must be 'Contraception', 'HealthStatus', 'Institution','InstitutionAssociation', 'Move','Parent', 'Weight', 'Length', 'DeathInformation', and/or 'Collection'")
  }
  
  for (ta in taxa){
    if (!silent) {
      cat(glue::glue("{ta}"))
    }
    if(any(species[[ta]] != "All")){Species = species[[ta]]}
    #Load Animal File
    idfiles <- list.files(glue::glue("{ZIMSdir}/Split_{ta}/"), "Animal.csv")
    
    assert_that(length(idfiles )> 0,
                msg =glue::glue("Animal file for {ta} not found.")
    )
    assert_that(length(idfiles) < 2,
                msg = glue::glue("More than one Animal file for {ta}.")
    )
    
    Ani <- read.csv(glue::glue("{ZIMSdir}/Split_{ta}/{idfiles}"), sep = "@",  header = T, skipNul = TRUE)
    
    
    if(any(species[[ta]] != "All")){
      Ani <- Ani%>%
        filter(binSpecies %in% Species)
    }
    if(nrow(Ani) == 0) warnings("There are no data for selected species of {ta}")
    
    if(Animal){out[[ta]][["Animal"]]<- Ani}
    
    if(length(tables)>0){  
      for (ty in tables){
        
        idfiles <- list.files(glue::glue("{ZIMSdir}/Split_{ta}/"), glue::glue("{ty}.csv"))
        
        if(length(idfiles)== 0) error(glue::glue("{ty} file of {ta} not found."))
        
        if(length(idfiles) >= 2) error(glue::glue("More than one {ty} file for {ta}."))
        
        if (!silent) {
          cat(glue::glue("Loading {ty} of {ta}.\n"))
        }
        
        b <- read.csv(glue::glue("{ZIMSdir}/Split_{ta}/{idfiles}"), sep = "@",  header = T, skipNul = TRUE)
        
        if("AnimalAnonID" %in% colnames(b)){
          b <- b%>%
            filter(AnimalAnonID %in% Ani$AnimalAnonID)
        }
        out[[taxa]][[ty]]<- b
      }
    }
    if (!silent) {
      cat(glue::glue("{taxa} Done.\n"))
    }
  }
  return(out)
}
```

```{r examples-Load_Zimsdata}
file = system.file("sci_Animal.csv", package = 'ISRverse')
ZIMSdirtest = dirname(file)
Split_Zimsdata	(ZIMSdir = ZIMSdirtest)

data <- Load_Zimsdata	(taxa = "Reptilia", 
                       ZIMSdir = ZIMSdirtest, 
                       species = list(Reptilia = "All"),
                       Animal = TRUE,
                       tables = 'Weight') 
data$Reptilia$Animal
unlink(glue::glue("{ZIMSdirtest}/Split_Reptilia"), recursive = FALSE)
```

```{r tests-Load_Zimsdata}
test_that("Load_Zimsdata works", {
  
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSdirtest = dirname(file)
  Split_Zimsdata	(ZIMSdir = ZIMSdirtest)
  
  data <- Load_Zimsdata	(taxa = "Reptilia", 
                         ZIMSdir = ZIMSdirtest, 
                         species = list(Reptilia = "All"),
                         Animal = TRUE,
                         tables = 'Weight') 
  
  expect_named(data$Reptilia, c("Animal",  "Weight"))
  expect_true(is.data.frame(data$Reptilia$Animal))
  expect_true(is.data.frame(data$Reptilia$Weight))
  expect_named(data$Reptilia$Weight, c("AnimalAnonID", "RecordingInstitution", "MeasurementType", "RecordType", "MeasurementValue", "EstimatedMeasurement", "ExcludededFromNorms", "MeasurementDate", "MeasurementDateEstimateType", "MeasurementDateEstimateStart", "MeasurementDateEstimateEnd", "CollectionScopeType",  "AnimalAgeMonths", "AnimalAgeDays", "Age", "UnitOfMeasure")) 
  
}
)
```



# Split Initial extract

`Split_Zimsdata()` loads the science extract and:
* splits it by taxa 
* selects only "Individual" for Animal Type
* adds binSpecies name
* weights and lengths: checks that measurement are > 0 and adds the following columns: Age in years, UnitOfMeasure and MeasurementValue. 

It uses the following arguments:

* `ZIMSdir` directory where to find data
* `extractDate` Extraction Date in character


```{r function-Split_Zimsdata}
#' Split raw extracted data
#' 
#' Check Data and split tables per taxa
#'
#' @param ZIMSdir \code{character} directory where to find data
#' @param extractDate \code{character} Extraction Date
#' @param silent \code{logical} Whether information of advancement should be printed
#' 
#' @return A list of the data frames
#' 
#' @importFrom glue glue
#' @importFrom readr write_delim
#' @importFrom stringr str_remove str_detect
#' @importFrom checkmate assert_directory_exists
#' @export
#'
#' @examples
#' 
Split_Zimsdata	<- function (ZIMSdir,
                            extractDate = NULL,
                            silent = FALSE) 
{ 
  checkmate::assert_directory_exists(ZIMSdir)
  assert_that(is.logical( silent))
  if(!is.null(extractDate)){
    extractDate = lubridate::date(extractDate)
  }else{extractDate = ""}
  
  idfiles <- list.files(ZIMSdir, "sci_")
  idfilesAni <- list.files(ZIMSdir, "Animal.csv")
  idfiles = str_subset(idfiles, pattern = "Animal.csv", negate = TRUE)
  
  
  #Load Animal File
  assert_that(length(idfilesAni)> 0,
              msg =glue::glue("Animal file not found.")
  )
  assert_that(length(idfilesAni) < 2,
              msg = glue::glue("More than one Animal file.")
  )
  if (!silent) {
    cat(glue::glue("Splitting Animal file.\n"))
  }
  Ani <- read.csv(glue::glue("{ZIMSdir}/{idfilesAni}"), sep = "@",  header = T, skipNul = TRUE)
  Ani <- Ani%>%filter(AnimalType == "Individual")%>%select(-GAN)
  
  temp= stringr::str_split(Ani$SpeciesName, " ", simplify = T)
  temp2 = temp[,2]
  temp[,2][temp2 == ""] = "sp."
  Ani$binSpecies = stringr::str_c(temp[,1], temp[,2], sep = " ")
  taxaList = unique(Ani$Class)
  
  #split Animal data and create sub_directory
  for (taxa in taxaList){
    dir.create(path = glue::glue("{ZIMSdir}/Split_{taxa}/"), showWarnings = FALSE)
    
    
    Ani_taxa = Ani%>% filter(Class == taxa)
    write_delim(Ani_taxa, file = glue::glue("{ZIMSdir}/Split_{taxa}/{taxa}{extractDate}_Animal.csv"), delim = "@")
  }
  
  
  #Split all other files
  for (file in idfiles){
    if (!silent) {
      cat(glue::glue("Splitting {file}.\n"))
    }
    name = str_remove(file, "sci_")
    fi <- read.csv(glue::glue("{ZIMSdir}/{file}"), sep = "@",  header = T, skipNul = TRUE)
    
    for (taxa in taxaList){
      fi_taxa = fi
      Ani_taxa = Ani%>% filter(Class == taxa)
      if("AnimalAnonID" %in% names(fi)){
        fi_taxa <- fi_taxa %>% filter(AnimalAnonID %in% Ani_taxa$AnimalAnonID)}
      if("InstitutionAnonID" %in% names(fi)){
        fi_taxa <- fi_taxa %>% filter(InstitutionAnonID %in% Ani_taxa$InstitutionAnonID)}
      
      if (name == "AnimalWeight.csv"){
        fi_taxa <-fi_taxa%>%
          filter(WeightValueKg>0)%>%
          rename(MeasurementValue = WeightValueKg)%>%
          mutate(Age = AnimalAgeDays/365,
                 UnitOfMeasure = "kg")
      }
      if (name == "AnimalLength.csv"){
        fi_taxa <-fi_taxa%>%
          filter(LengthValueCm>0)%>%
          rename(MeasurementValue = LengthValueCm)%>%
          mutate(Age = AnimalAgeDays/365,
                 UnitOfMeasure = "cm")
      }
      write_delim(fi_taxa,
                  file = glue::glue("{ZIMSdir}/Split_{taxa}/{taxa}{extractDate}_{name}"), 
                  delim = "@")
    }
  }
  
  if (!silent) {
    cat(" Done.\n")
  }
}
```

```{r examples-Split_Zimsdata}
file = system.file("sci_Animal.csv", package = "ISRverse")
ZIMSdirtest = dirname(file)

Split_Zimsdata(ZIMSdir = ZIMSdirtest)

list.files(ZIMSdirtest, recursive = TRUE)
```

```{r tests-Split_Zimsdata}
test_that("Split_Zimsdata works", {
  
  file = system.file("sci_Animal.csv", package = 'ISRverse')
  ZIMSdirtest = dirname(file)
  Split_Zimsdata	(ZIMSdir = ZIMSdirtest)
  expect_true(file.exists(glue::glue("{ZIMSdirtest}/Split_Reptilia/Reptilia_Animal.csv")))
  expect_true(file.exists(glue::glue("{ZIMSdirtest}/Split_Reptilia/Reptilia_AnimalParent.csv")))
  
})
```


# Output for Dev team

`make_summary()` produces summary tables and plots of the demographic analyses made for all species. It uses the following arguments:

* `SpeciesTable` Data frame including 2 columns: *Class* and *Species*
* `AnalysisDir` directory where to find the .Rdata files
* `SaveDir` directory where to save summary plots and tables
* `taxaList` names of the taxa studied.
* `BySex` list of the taxa names indicating the sexes analyzed. 
* `Sections` names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro"

it returns the main summary table

```{r function-Tx_devout}
#' Summarize taxon profiles analyses
#' 
#' Produce summary tables and plots of the demographic analyses made for all species
#'
#' @param SpeciesTable \code{Data.frame} including 2 columns: *Class* and *Species*
#' @param AnalysisDir  \code{character} directory where to find the .Rdata files
#' @param SaveDir  \code{character} directory where to save the json files
#' @param namefile \code{character} Suffix to add to the name of files produced if needed. Default = ""
#' @param taxaList \code{vector of characters} name of the taxa studied. Default= "Mammalia"
#' @param BySex \code{List} indicating the sexes analyzed. Default= list(Mammalia= c("Male", "Female"))
#' @param Sections \code{vector of character} names of the sections to update in the taxon profile results: "sur", "rep" and/or "gro". Default = c("sur", "rep", "gro")
#'
#' @return It saves summary tables and plots for each Sections and a general summary table. It returns the main summary table
#' @export
#' 
#' @importFrom ggplot2 ggplot scale_fill_brewer facet_wrap geom_bar labs position_dodge coord_flip
#' @importFrom ggpubr ggarrange
#' 
#' @examples
Tx_devout <- function (SpeciesTable, AnalysisDir, SaveDir, namefile = "",
                       taxaList = "Mammalia",
                       BySex = list(Mammalia= c("Male", "Female")) , 
                       Sections = c("sur", 'rep', 'gro')
){
  
  assert_that(is.data.frame(SpeciesTable))
  
  assert_that(SpeciesTable  %has_name% c("Class", "Species"))
  assert_that(is.character(taxaList))
  # assert_that(taxaList %in% c("Mammalia", "Aves", "Reptilia", "Amphibia", 
  #                             "Chondrichthyes", "Actinopterygii"),
  #             msg = "taxa must one of 'Mammalia', 'Aves', 'Reptilia', 'Amphibia', 
  #                         'Chondrichthyes', or 'Actinopterygii'")
  assert_that(is.character(Sections))
  assert_that(all(Sections %in% c("sur", "gro", "rep")))
  checkmate::assert_directory_exists(AnalysisDir)
  checkmate::assert_directory_exists(SaveDir)
  assert_that(is.character(namefile))
  assert_that(is.list(BySex))
  assert_that(all(taxaList %in% names(BySex)), msg = "BySex should be a list with names identical to taxaList")
  
  # List of available SRGs:
  SRGlist <- list.files(AnalysisDir, pattern = ".RData")
  assert_that(length(SRGlist) > 0, 
              msg = glue::glue("There are no result file in {AnalysisDir}"))
  
  for (taxa in taxaList) {
    
    SRGspecies = SpeciesTable%>%filter(Class==taxa)%>%pull(Species)
    SRGspeciesta = SRGspecies %>%stringr::str_replace(" ", "_")
    i = 0
    # Loop over species
    for (isp in SRGspeciesta) {
      i = i+1
      specie =isp%>%
        stringr::str_remove(pattern = paste0(taxa, '_'))%>%
        stringr::str_replace("_", " ")
      
      cat("\n", taxa," -------Species: ", SRGspecies[i], "Progress:", round(i / length(SRGspecies) * 100, 1),"%")
      
      # SRG file:
      load(file = glue::glue("{AnalysisDir}/{taxa}_{isp}.RData"))
      TPout = list()
      
      # Fill up data list:
      for (sx in  BySex[[taxa]]) {
        if("sur" %in% Sections){
          TPout$survival[[sx]]$Nbasta = repout$surv[[sx]]$from0$summary$NBasta
          TPout$survival[[sx]]$Lx = cbind(Age = repout$surv[[sx]]$from0$bastaRes$x, t(repout$surv[[sx]]$from0$bastaRes$surv$nocov))
          TPout$survival[[sx]]$relex = repout$surv[[sx]]$from0$relex
          TPout$survival[[sx]]$Sur1= repout$surv[[sx]]$from0$Sur1
          
        }
        
      }
      write(rjson::toJSON(TPout), file = glue("{SaveDir}/{namefile}{taxa}_{isp}.json"))
    }
    
    if("gro" %in% Sections){
      print("There is no growth output for now")
    }
    if("rep" %in% Sections){
      print("There is no reproduction output for now")
      
    }
  }
}
```

```{r examples-Tx_devout}
# file = system.file("sci_Animal.csv", package = 'ISRverse')
# AnalysisDir  = paste0(dirname(file),'\\Rdata')
# SaveDir = paste0(tempdir(check = TRUE),'\\temp')
# dir.create(SaveDir)
# SpeciesTable = data.frame( Class = "Reptilia", Species = "Testudo hermanni")
# Tx_devout(SpeciesTable, AnalysisDir, SaveDir,
#                         taxaList = "Reptilia",
#                         BySex = list(Reptilia = c("Male", "Female")) ,
#                         Sections = c("sur", 'gro')
# )
# list.files(SaveDir)
# unlink(SaveDir, recursive = TRUE)
```

```{r tests-Tx_devout}
# test_that("Tx_devout works", {
#   file = system.file("sci_Animal.csv", package = 'ISRverse')
#   AnalysisDir  = paste0(dirname(file),'\\Rdata')
#   TempDir = paste0(tempdir(check = TRUE),'\\temp')
#   dir.create(TempDir,showWarnings =FALSE)
#   SpeciesTable = data.frame( Class = "Reptilia", Species = "Testudo hermanni")
# Tx_devout(SpeciesTable, AnalysisDir, SaveDir =TempDir ,
#                         taxaList = "Reptilia",
#                         BySex = list(Reptilia = c("Male", "Female")) ,
#                         Sections = c("sur", 'gro')
# )
#   expect_true(file.exists(paste(TempDir, 'Reptilia_Testudo_hermanni.json', sep = '\\')))
# 
#   unlink(TempDir, recursive = TRUE)
# })

```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_main.Rmd", vignette_name = "Taxon profiles")
```




